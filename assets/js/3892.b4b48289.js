"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[3892],{28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var a=s(96540);const t={},i=a.createContext(t);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),a.createElement(i.Provider,{value:n},e.children)}},31511:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>o});const a=JSON.parse('{"id":"types/aliases","title":"Type Aliases","description":"When you have complicated types that you want to reuse in multiple places, you","source":"@site/docs/types/aliases.md","sourceDirName":"types","slug":"/types/aliases","permalink":"/en/docs/types/aliases","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/types/aliases.md","tags":[],"version":"current","frontMatter":{"title":"Type Aliases","slug":"/types/aliases"},"sidebar":"docsSidebar","previous":{"title":"Classes","permalink":"/en/docs/types/classes"},"next":{"title":"Opaque Type Aliases","permalink":"/en/docs/types/opaque-types"}}');var t=s(74848),i=s(28453);const r={title:"Type Aliases",slug:"/types/aliases"},l=void 0,c={},o=[{value:"Type Alias Syntax",id:"toc-type-alias-syntax",level:2},{value:"Type Alias Generics",id:"toc-type-alias-generics",level:4}];function p(e){const n={a:"a",code:"code",em:"em",h2:"h2",h4:"h4",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["When you have complicated types that you want to reuse in multiple places, you\ncan alias them in Flow using a ",(0,t.jsx)(n.strong,{children:"type alias"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type MyObject = {\n  foo: number,\n  bar: boolean,\n  baz: string,\n};\n"})}),"\n",(0,t.jsx)(n.p,{children:"These type aliases can be used anywhere a type can be used."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type MyObject = {\n  // ...\n};\n\nconst val: MyObject = { /* ... */ };\nfunction method(val: MyObject) { /* ... */ }\nclass Foo { constructor(val: MyObject) { /* ... */ } }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Type aliases are just that: aliases. They don't create a ",(0,t.jsx)(n.em,{children:"different"})," type, just another name for one.\nThis means that a type alias is completely interchangeable with the type it is equal to."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type MyNumber = number;\ndeclare const x: MyNumber;\ndeclare function foo(x: number): void;\nfoo(x); // ok, because MyNumber = number\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"../opaque-types",children:"Opaque type aliases"})," offer an alternative for when you don't want to treat the\ntypes as the same."]}),"\n",(0,t.jsx)(n.h2,{id:"toc-type-alias-syntax",children:"Type Alias Syntax"}),"\n",(0,t.jsxs)(n.p,{children:["Type aliases are created using the keyword ",(0,t.jsx)(n.code,{children:"type"})," followed by its name, an\nequals sign ",(0,t.jsx)(n.code,{children:"="}),", and a type definition."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"type Alias = Type;\n"})}),"\n",(0,t.jsx)(n.p,{children:"Any type can appear inside a type alias."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type NumberAlias = number;\ntype ObjectAlias = {\n  property: string,\n  method(): number,\n};\ntype UnionAlias = 1 | 2 | 3;\ntype AliasAlias = ObjectAlias;\n"})}),"\n",(0,t.jsx)(n.h4,{id:"toc-type-alias-generics",children:"Type Alias Generics"}),"\n",(0,t.jsxs)(n.p,{children:["Type aliases can also have their own ",(0,t.jsx)(n.a,{href:"../generics",children:"generics"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type MyObject<A, B, C> = {\n  property: A,\n  method(val: B): C,\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Type alias generics are ",(0,t.jsx)(n.a,{href:"../generics#toc-parameterized-generics",children:"parameterized"}),".\nWhen you use a type alias you need to pass parameters for each of its generics."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type MyObject<A, B, C> = {\n  foo: A,\n  bar: B,\n  baz: C,\n};\n\nvar val: MyObject<number, boolean, string> = {\n  foo: 1,\n  bar: true,\n  baz: 'three',\n};\n"})})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}}}]);