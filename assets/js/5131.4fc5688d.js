"use strict";(globalThis.webpackChunknew_website=globalThis.webpackChunknew_website||[]).push([[5131],{15131(e,n,s){s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"types/const-expression","title":"Const Expressions","description":"Sometimes it is useful to specify that a literal expression is expected to be immutable.","source":"@site/docs/types/const-expression.md","sourceDirName":"types","slug":"/types/const-expression","permalink":"/en/docs/types/const-expression","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/types/const-expression.md","tags":[],"version":"current","frontMatter":{"title":"Const Expressions","slug":"/types/const-expression"},"sidebar":"docsSidebar","previous":{"title":"Type Casting Expressions","permalink":"/en/docs/types/casting"},"next":{"title":"Utility Types","permalink":"/en/docs/types/utilities"}}');var o=s(74848),i=s(28453),r=s(86543);const c={title:"Const Expressions",slug:"/types/const-expression"},l=void 0,a={},d=[{value:"Typing for Const Expressions",id:"toc-const-expression-typing",level:2},{value:"Typical const-expression example",id:"toc-const-expression-example",level:2},{value:"Const Expressions for React JSX <SinceVersion></SinceVersion>",id:"toc-const-expression-jsx",level:2},{value:"Adoption of <code>as const</code> syntax",id:"adoption-of-as-const-syntax",level:2},{value:"<code>const</code> Type Parameters",id:"const-type-parameters",level:2},{value:"Adoption of <code>const</code> type parameter syntax",id:"adoption-of-const-type-parameter-syntax",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["Sometimes it is useful to specify that a literal expression is expected to be immutable.\nIn such cases, you can annotate the expression with the ",(0,o.jsx)(n.code,{children:"as const"})," modifier. We\nrefer to these expressions as const-expressions."]}),"\n",(0,o.jsx)(n.h2,{id:"toc-const-expression-typing",children:"Typing for Const Expressions"}),"\n",(0,o.jsxs)(n.p,{children:["The inferred type of const-expressions is the ",(0,o.jsx)(n.a,{href:"../literals",children:"singleton type"})," for primitive values\nand the read-only versions for container types. Array literals are inferred as tuple types."]}),"\n",(0,o.jsx)(n.p,{children:"Here are some examples of primitive values:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'42 as const; // inferred type is 42\n\n"hello" as const; // inferred type is "hello"\n'})}),"\n",(0,o.jsx)(n.p,{children:"Containers become read-only and the modifier is applied deeply"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'{ f: 42 } as const; // {+f: 42}\n\n[42, "hello"] as const; // Readonly<[42, "hello"]>\n\n{ f: { g: 42 } } as const; // {+f: {+g: 42}}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Note that the effect of the modifier does not persist through variables. For example\nin"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const nonConstObject = { g: 42 };\nconst constObject = { f: nonConstObject } as const;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["the type of ",(0,o.jsx)(n.code,{children:"nonConstObject"})," will be ",(0,o.jsx)(n.code,{children:"{g: number}"})," and the type of ",(0,o.jsx)(n.code,{children:"constObject"})," will\nbe ",(0,o.jsx)(n.code,{children:"{+f: {g: number}}"}),". In other words, only the top-level property ",(0,o.jsx)(n.code,{children:"prop"})," will\nbe read-only."]}),"\n",(0,o.jsxs)(n.p,{children:["Finally, it is an error to apply ",(0,o.jsx)(n.code,{children:"as const"})," to non-literal expressions:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"const x = 1;\nconst y = x as const;\n"})}),"\n",(0,o.jsx)(n.h2,{id:"toc-const-expression-example",children:"Typical const-expression example"}),"\n",(0,o.jsx)(n.p,{children:"A common pattern where const-expressions are useful is in enum-like\nstructures that are not expected to be mutated. For example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"export const STATUS = {\n  INIT: 'INIT',\n  LOADING: 'LOADING',\n  SUCCESS: 'SUCCESS',\n  ERROR: 'ERROR',\n} as const;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The type of ",(0,o.jsx)(n.code,{children:"STATUS.INIT"})," is ",(0,o.jsx)(n.code,{children:'"INIT"'}),", the type of ",(0,o.jsx)(n.code,{children:"STATUS.LOADING"})," is ",(0,o.jsx)(n.code,{children:'"LOADING"'})," and so on."]}),"\n",(0,o.jsx)(n.p,{children:"With this definition it is also possible to effectively lift the values of the various fields\nto type annotations. For example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"type State =\n  | { +kind: typeof STATUS.INIT; }\n  | { +kind: typeof STATUS.LOADING; progress: number; }\n  | { +kind: typeof STATUS.SUCCESS; result: string; }\n  | { +kind: typeof STATUS.ERROR; msg: string; };\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Without the use of ",(0,o.jsx)(n.code,{children:"as const"})," the type ",(0,o.jsx)(n.code,{children:"typeof STATUS.INIT"})," would be ",(0,o.jsx)(n.code,{children:"string"}),", which\nwould make it unsuitable as a distinguishing tag in a disjoint union."]}),"\n",(0,o.jsxs)(n.h2,{id:"toc-const-expression-jsx",children:["Const Expressions for React JSX ",(0,o.jsx)(r.V,{version:"0.284"})]}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["Check out ",(0,o.jsx)(n.a,{href:"../../react/render-types/",children:"render types"})," and ",(0,o.jsx)(n.a,{href:"../../react/types/",children:"react type references"})," if you are not familiar with React typing in Flow."]})}),"\n",(0,o.jsx)(n.p,{children:"Since version 0.284, Flow will infer a more general type for React JSX elements by default."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const div1 = <div />; // `<div />` has type `React.MixedElement`\ndeclare component Foo();\nconst foo1 = <Foo />; // `<Foo />` has type `renders Foo`\n"})}),"\n",(0,o.jsx)(n.p,{children:"However, if the JSX element is in a position that can be contextually typed, Flow will infer a more specific type, so it can be accepted by more restrictive APIs:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"type ExactDiv = ExactReactElement_DEPRECATED<'div'>;\ndeclare function onlyAllowsExactDiv(div: ExactDiv): void;\ndeclare component OnlyAllowsExactDiv(children: ExactDiv);\n\nconst divGeneral = <div />;\nonlyAllowsExactDiv(divGeneral); // Error\n<OnlyAllowsExactDiv>{divGeneral}</OnlyAllowsExactDiv>; // Error\nonlyAllowsExactDiv(<div />); // OK\n<OnlyAllowsExactDiv><div /></OnlyAllowsExactDiv>; // OK\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If you want to have the jsx to have a more specific type in a position that cannot be contextually typed, you can wrap it with ",(0,o.jsx)(n.code,{children:"as const"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"declare function onlyAllowsExactDiv(div: ExactDiv): void;\ndeclare component OnlyAllowsExactDiv(children: ExactDiv);\n\nconst divSpecific = <div /> as const;\nonlyAllowsExactDiv(divSpecific); // OK\n<OnlyAllowsExactDiv>{divSpecific}</OnlyAllowsExactDiv>; // OK\n"})}),"\n",(0,o.jsxs)(n.h2,{id:"adoption-of-as-const-syntax",children:["Adoption of ",(0,o.jsx)(n.code,{children:"as const"})," syntax"]}),"\n",(0,o.jsxs)(n.p,{children:["To use the ",(0,o.jsx)(n.code,{children:"as const"})," syntax, you need to upgrade your infrastructure:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Flow and Flow Parser: 0.256+"}),"\n",(0,o.jsx)(n.li,{children:"Prettier: 3.1+"}),"\n",(0,o.jsxs)(n.li,{children:["Babel: use the ",(0,o.jsx)(n.a,{href:"https://www.npmjs.com/package/babel-plugin-syntax-hermes-parser",children:"babel-plugin-syntax-hermes-parser"})," plugin version 0.19+, see our ",(0,o.jsx)(n.a,{href:"../../tools/babel",children:"Babel guide"})," for more details."]}),"\n",(0,o.jsxs)(n.li,{children:["ESLint: use ",(0,o.jsx)(n.a,{href:"https://www.npmjs.com/package/hermes-eslint",children:"hermes-eslint"})," plugin version 0.19+, see our ",(0,o.jsx)(n.a,{href:"../../tools/eslint",children:"ESLint guide"})," for more details."]}),"\n"]}),"\n",(0,o.jsxs)(n.h2,{id:"const-type-parameters",children:[(0,o.jsx)(n.code,{children:"const"})," Type Parameters"]}),"\n",(0,o.jsxs)(n.p,{children:["Sometimes it is useful to specify that an argument to a function is always expected\nto be a const-expression. In such cases, you can annotate the type parameter with\nthe ",(0,o.jsx)(n.code,{children:"const"})," modifier. We refer to these type parameters as const-type parameters."]}),"\n",(0,o.jsxs)(n.p,{children:["When are ",(0,o.jsx)(n.code,{children:"const"})," type parameters useful?"]}),"\n",(0,o.jsxs)(n.p,{children:["One example is when you want to enforce that all arguments passed to a function\n",(0,o.jsx)(n.code,{children:"foo"})," with signature"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"declare function foo<X>(x: X): X;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["need to be treated as const-expressions. One way to support this is by always\ncalling ",(0,o.jsx)(n.code,{children:"foo"})," with ",(0,o.jsx)(n.code,{children:"as const"})," on its argument:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const x1 = foo({ f: 42 } as const);\nconst x2 = foo([42, "hello"] as const);\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The variables ",(0,o.jsx)(n.code,{children:"x1"})," and ",(0,o.jsx)(n.code,{children:"x2"})," will have the type ",(0,o.jsx)(n.code,{children:"{+f: 42}"})," and ",(0,o.jsx)(n.code,{children:'Readonly<[42, "hello"]>'}),",\nrespectively."]}),"\n",(0,o.jsxs)(n.p,{children:["To avoid repeating and potentially forgetting to pass ",(0,o.jsx)(n.code,{children:"as const"}),", you can use the\n",(0,o.jsx)(n.code,{children:"const"})," modifier on type parameter ",(0,o.jsx)(n.code,{children:"X"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"declare function constFoo<const X>(x: X): X;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Now you can call ",(0,o.jsx)(n.code,{children:"constFoo"})," without ",(0,o.jsx)(n.code,{children:"as const"})," and have the same effect as before:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const y1 = constFoo({ f: 42 });\nconst y2 = constFoo([42, "hello"]);\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The variables ",(0,o.jsx)(n.code,{children:"y1"})," and ",(0,o.jsx)(n.code,{children:"y2"})," will have the same type as ",(0,o.jsx)(n.code,{children:"x1"})," and ",(0,o.jsx)(n.code,{children:"x2"}),", respectively."]}),"\n",(0,o.jsxs)(n.h2,{id:"adoption-of-const-type-parameter-syntax",children:["Adoption of ",(0,o.jsx)(n.code,{children:"const"})," type parameter syntax"]}),"\n",(0,o.jsxs)(n.p,{children:["To use the ",(0,o.jsx)(n.code,{children:"as const"})," syntax, you need to upgrade your infrastructure:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Flow and Flow Parser:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["0.267 and 0.268 and passing the ",(0,o.jsx)(n.code,{children:"experimental.const_type_params=true"})," flag in the flowconfig"]}),"\n",(0,o.jsx)(n.li,{children:"0.269+ without the flag."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.li,{children:"Prettier: 3.5+"}),"\n",(0,o.jsxs)(n.li,{children:["Babel: use the ",(0,o.jsx)(n.a,{href:"https://www.npmjs.com/package/babel-plugin-syntax-hermes-parser",children:"babel-plugin-syntax-hermes-parser"})," plugin version 0.26+, see our ",(0,o.jsx)(n.a,{href:"../../tools/babel",children:"Babel guide"})," for more details."]}),"\n",(0,o.jsxs)(n.li,{children:["ESLint: use ",(0,o.jsx)(n.a,{href:"https://www.npmjs.com/package/hermes-eslint",children:"hermes-eslint"})," plugin version 0.26+, see our ",(0,o.jsx)(n.a,{href:"../../tools/eslint",children:"ESLint guide"})," for more details."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},86543(e,n,s){s.d(n,{V:()=>o,v:()=>i});s(96540);var t=s(74848);function o(e){let{version:n}=e;return(0,t.jsxs)("span",{class:"version added",title:`Added in ${n}`,children:["\u2265",n]})}function i(e){let{version:n}=e;return(0,t.jsxs)("span",{class:"version removed",title:`Removed after ${n}`,children:["\u2264",n]})}},28453(e,n,s){s.d(n,{R:()=>r,x:()=>c});var t=s(96540);const o={},i=t.createContext(o);function r(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);