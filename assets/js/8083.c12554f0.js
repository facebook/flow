"use strict";(globalThis.webpackChunknew_website=globalThis.webpackChunknew_website||[]).push([[8083],{78083(e,n,i){i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"config/untyped","title":".flowconfig [untyped]","description":"The [untyped] section in a .flowconfig file tells Flow to not typecheck files","source":"@site/docs/config/untyped.md","sourceDirName":"config","slug":"/config/untyped","permalink":"/en/docs/config/untyped","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/config/untyped.md","tags":[],"version":"current","frontMatter":{"title":".flowconfig [untyped]","slug":"/config/untyped"},"sidebar":"docsSidebar","previous":{"title":".flowconfig [ignore]","permalink":"/en/docs/config/ignore"},"next":{"title":".flowconfig [declarations]","permalink":"/en/docs/config/declarations"}}');var r=i(74848),s=i(28453);const o={title:".flowconfig [untyped]",slug:"/config/untyped"},c=void 0,d={},l=[];function a(e){const n={a:"a",code:"code",li:"li",ol:"ol",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"[untyped]"})," section in a ",(0,r.jsx)(n.code,{children:".flowconfig"})," file tells Flow to not typecheck files\nmatching the specified regular expressions and instead throw away types and treat modules as ",(0,r.jsx)(n.a,{href:"../../types/any",children:(0,r.jsx)(n.code,{children:"any"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["This is different from the ",(0,r.jsx)(n.a,{href:"../ignore",children:(0,r.jsx)(n.code,{children:"[ignore]"})})," config section that causes matching files to be ignored by the module resolver,\nwhich inherently makes them un-typechecked, and also unresolvable by ",(0,r.jsx)(n.code,{children:"import"})," or ",(0,r.jsx)(n.code,{children:"require"}),".\nWhen ignored, ",(0,r.jsx)(n.a,{href:"../libs",children:(0,r.jsx)(n.code,{children:"[libs]"})})," must then be specified for each ",(0,r.jsx)(n.code,{children:"import"})," using ",(0,r.jsx)(n.code,{children:"flow-typed"}),", which may not always be desired."]}),"\n",(0,r.jsxs)(n.p,{children:["It is also different from the ",(0,r.jsx)(n.a,{href:"../declarations",children:(0,r.jsx)(n.code,{children:"[declarations]"})})," section.\nThis also does not typecheck the file contents, but ",(0,r.jsx)(n.code,{children:"[declarations]"})," does extract and use the signatures of functions, classes, etc, when checking other code."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"[untyped]"})," instead causes a file to be ignored by the typechecker as if it had ",(0,r.jsx)(n.code,{children:"@noflow"})," in it,\nresolve modules as ",(0,r.jsx)(n.code,{children:"any"})," type, but allow them to NOT be ignored by the module resolver.\nAny matching file is skipped by Flow (not even parsed, like other ",(0,r.jsx)(n.code,{children:"@noflow"})," files!), but can still be ",(0,r.jsx)(n.code,{children:"require()"}),"'d."]}),"\n",(0,r.jsx)(n.p,{children:"Things to keep in mind:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["These are ",(0,r.jsx)(n.a,{href:"http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp",children:"OCaml regular expressions"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["These regular expressions match against absolute paths. They probably should\nstart with ",(0,r.jsx)(n.code,{children:".*"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["An example ",(0,r.jsx)(n.code,{children:"[untyped]"})," section might look like:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"[untyped]\n.*/third_party/.*\n.*/src/\\(foo\\|bar\\)/.*\n.*\\.untyped\\.js\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This ",(0,r.jsx)(n.code,{children:"[untyped]"})," section will parse:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Any file or directory under a directory named ",(0,r.jsx)(n.code,{children:"third_party"})]}),"\n",(0,r.jsxs)(n.li,{children:["Any file or directory under ",(0,r.jsx)(n.code,{children:".*/src/foo"})," or under ",(0,r.jsx)(n.code,{children:".*/src/bar"})]}),"\n",(0,r.jsxs)(n.li,{children:["Any file that ends with the extension ",(0,r.jsx)(n.code,{children:".untyped.js"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["You may use the ",(0,r.jsx)(n.code,{children:"<PROJECT_ROOT>"})," placeholder in your regular expressions.\nAt runtime, Flow will treat the placeholder as if it were the absolute path\nto the project's root directory. This is useful for writing regular\nexpressions that are relative rather than absolute."]}),"\n",(0,r.jsx)(n.p,{children:"For example, you can write:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"[untyped]\n<PROJECT_ROOT>/third_party/.*\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Which would parse in declaration mode any file or directory under the directory\nnamed ",(0,r.jsx)(n.code,{children:"third_party/"})," within the project root. However, unlike the previous\nexample's ",(0,r.jsx)(n.code,{children:".*/third_party/.*"}),", it would NOT parse files or directories under\ndirectories named ",(0,r.jsx)(n.code,{children:"third_party/"}),", like ",(0,r.jsx)(n.code,{children:"src/third_party/"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},28453(e,n,i){i.d(n,{R:()=>o,x:()=>c});var t=i(96540);const r={},s=t.createContext(r);function o(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);