"use strict";(globalThis.webpackChunknew_website=globalThis.webpackChunknew_website||[]).push([[1895],{91895(e){e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/2024/04/03/New-Flow-Language-Features-for-React","metadata":{"permalink":"/blog/2024/04/03/New-Flow-Language-Features-for-React","source":"@site/blog/2024-04-03-New-Flow-Language-Features-for-React.md","title":"New Flow Language Features for React","description":"Flow is excited to announce Component Syntax, adding first-class support for React primitives such as components and hooks to the Flow language. These features bring improved ergonomics, expressiveness, and static enforcement for many of the Rules of React.","date":"2024-04-03T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Alex Taylor & Jordan Brown","key":null,"page":null}],"frontMatter":{"title":"New Flow Language Features for React","short-title":"New Flow Language Features for React","author":"Alex Taylor & Jordan Brown","medium-link":"https://medium.com/flow-type/announcing-component-syntax-b6c5285660d0"},"unlisted":false,"nextItem":{"title":"Announcing Conditional Types","permalink":"/blog/2024/03/05/Announcing-Conditional-Types"}},"content":"Flow is excited to announce Component Syntax, adding first-class support for React primitives such as components and hooks to the Flow language. These features bring improved ergonomics, expressiveness, and static enforcement for many of the Rules of React."},{"id":"/2024/03/05/Announcing-Conditional-Types","metadata":{"permalink":"/blog/2024/03/05/Announcing-Conditional-Types","source":"@site/blog/2024-03-05-Announcing-Conditional-Types.md","title":"Announcing Conditional Types","description":"Conditional types allow you to choose between two different output types by inspecting an input type.","date":"2024-03-05T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Sam Zhou","key":null,"page":null}],"frontMatter":{"title":"Announcing Conditional Types","short-title":"Announcing Conditional Types","author":"Sam Zhou","medium-link":"https://medium.com/flow-type/announcing-conditional-types-765b421f3a87"},"unlisted":false,"prevItem":{"title":"New Flow Language Features for React","permalink":"/blog/2024/04/03/New-Flow-Language-Features-for-React"},"nextItem":{"title":"Announcing User Defined Type Guards in Flow","permalink":"/blog/2024/03/05/Announcing-User-Defined-Type-Guards-in-Flow"}},"content":"Conditional types allow you to choose between two different output types by inspecting an input type."},{"id":"/2024/03/05/Announcing-User-Defined-Type-Guards-in-Flow","metadata":{"permalink":"/blog/2024/03/05/Announcing-User-Defined-Type-Guards-in-Flow","source":"@site/blog/2024-03-05-Announcing-User-Defined-Type-Guards-in-Flow.md","title":"Announcing User Defined Type Guards in Flow","description":"Flow now lets you define a function that encodes a type predicate over its parameter.","date":"2024-03-05T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Panagiotis Vekris","key":null,"page":null}],"frontMatter":{"title":"Announcing User Defined Type Guards in Flow","short-title":"Announcing User Defined Type Guards in Flow","author":"Panagiotis Vekris","medium-link":"https://medium.com/flow-type/announcing-user-defined-type-guards-in-flow-b979bb2e78cf"},"unlisted":false,"prevItem":{"title":"Announcing Conditional Types","permalink":"/blog/2024/03/05/Announcing-Conditional-Types"},"nextItem":{"title":"New type casting syntax for Flow: \'as\'","permalink":"/blog/2024/02/06/New-type-casting-syntax-for-Flow-as"}},"content":"Flow now lets you define a function that encodes a type predicate over its parameter."},{"id":"/2024/02/06/New-type-casting-syntax-for-Flow-as","metadata":{"permalink":"/blog/2024/02/06/New-type-casting-syntax-for-Flow-as","source":"@site/blog/2024-02-06-New-type-casting-syntax-for-Flow-as.md","title":"New type casting syntax for Flow: \'as\'","description":"To make it easier for new users to get started with Flow, we\u2019re updating our type casting syntax to use \'as\'.","date":"2024-02-06T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"George Zahariev","key":null,"page":null}],"frontMatter":{"title":"New type casting syntax for Flow: \'as\'","short-title":"New type casting syntax for Flow","author":"George Zahariev","medium-link":"https://medium.com/flow-type/new-type-casting-syntax-for-flow-as-3ef41567ff3e"},"unlisted":false,"prevItem":{"title":"Announcing User Defined Type Guards in Flow","permalink":"/blog/2024/03/05/Announcing-User-Defined-Type-Guards-in-Flow"},"nextItem":{"title":"Improved Flow Docs and Try Flow","permalink":"/blog/2023/09/19/Improved-Flow-Docs-and-Try-Flow"}},"content":"To make it easier for new users to get started with Flow, we\u2019re updating our type casting syntax to use \'as\'."},{"id":"/2023/09/19/Improved-Flow-Docs-and-Try-Flow","metadata":{"permalink":"/blog/2023/09/19/Improved-Flow-Docs-and-Try-Flow","source":"@site/blog/2023-09-19-Improved-Flow-Docs-and-Try-Flow.md","title":"Improved Flow Docs and Try Flow","description":"We\u2019ve refreshed our documentation, and added the ability to configure options and lints in Try Flow!","date":"2023-09-19T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"George Zahariev","key":null,"page":null}],"frontMatter":{"title":"Improved Flow Docs and Try Flow","short-title":"Improved Flow Docs and Try Flow","author":"George Zahariev","medium-link":"https://medium.com/flow-type/improved-flow-docs-and-try-flow-5da5e4831b5e"},"unlisted":false,"prevItem":{"title":"New type casting syntax for Flow: \'as\'","permalink":"/blog/2024/02/06/New-type-casting-syntax-for-Flow-as"},"nextItem":{"title":"Announcing 5 new Flow tuple type features","permalink":"/blog/2023/08/17/Announcing-5-new-Flow-tuple-type-features"}},"content":"We\u2019ve refreshed our documentation, and added the ability to configure options and lints in Try Flow!"},{"id":"/2023/08/17/Announcing-5-new-Flow-tuple-type-features","metadata":{"permalink":"/blog/2023/08/17/Announcing-5-new-Flow-tuple-type-features","source":"@site/blog/2023-08-17-Announcing-5-new-Flow-tuple-type-features.md","title":"Announcing 5 new Flow tuple type features","description":"Labeled tuple elements, read-only tuples, optional tuple elements, tuple spread, and more.","date":"2023-08-17T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"George Zahariev","key":null,"page":null}],"frontMatter":{"title":"Announcing 5 new Flow tuple type features","short-title":"Announcing 5 new Flow tuple type features","author":"George Zahariev","medium-link":"https://medium.com/flow-type/announcing-5-new-flow-tuple-type-features-ff4d7f11c50a"},"unlisted":false,"prevItem":{"title":"Improved Flow Docs and Try Flow","permalink":"/blog/2023/09/19/Improved-Flow-Docs-and-Try-Flow"},"nextItem":{"title":"Flow can now detect unused Promises","permalink":"/blog/2023/04/10/Unused-Promise"}},"content":"Labeled tuple elements, read-only tuples, optional tuple elements, tuple spread, and more."},{"id":"/2023/04/10/Unused-Promise","metadata":{"permalink":"/blog/2023/04/10/Unused-Promise","source":"@site/blog/2023-04-10-Unused-Promise.md","title":"Flow can now detect unused Promises","description":"As of v0.201.0, Flow can now lint against unused/floating Promises. Unused promises can be dangerous,","date":"2023-04-10T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"David Richey","key":null,"page":null}],"frontMatter":{"title":"Flow can now detect unused Promises","short-title":"Flow can now detect unused Promises","author":"David Richey","medium-link":"https://medium.com/flow-type/flow-can-now-detect-unused-promises-b49341256640"},"unlisted":false,"prevItem":{"title":"Announcing 5 new Flow tuple type features","permalink":"/blog/2023/08/17/Announcing-5-new-Flow-tuple-type-features"},"nextItem":{"title":"Announcing Partial & Required Flow utility types + catch annotations","permalink":"/blog/2023/03/15/Announcing-Partial-and-Required-Flow-utility-types-and-catch-annotations"}},"content":"As of v0.201.0, Flow can now lint against unused/floating Promises. Unused promises can be dangerous,\\nbecause errors are potentially unhandled, and the code may not execute in the intended order. They are\\nusually mistakes that Flow is perfectly positioned to warn you about."},{"id":"/2023/03/15/Announcing-Partial-and-Required-Flow-utility-types-and-catch-annotations","metadata":{"permalink":"/blog/2023/03/15/Announcing-Partial-and-Required-Flow-utility-types-and-catch-annotations","source":"@site/blog/2023-03-15-Announcing-Partial-and-Required-Flow-utility-types-and-catch-annotations.md","title":"Announcing Partial & Required Flow utility types + catch annotations","description":"Starting in Flow version 0.201, make an object type\u2019s fields all optional using Partial (use instead of the unsafe $Shape),","date":"2023-03-15T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"George Zahariev","key":null,"page":null}],"frontMatter":{"title":"Announcing Partial & Required Flow utility types + catch annotations","short-title":"Announcing Partial & Required Flow utility types","author":"George Zahariev","medium-link":"https://medium.com/flow-type/announcing-partial-required-flow-utility-types-catch-annotations-3a32f0bf2a20"},"unlisted":false,"prevItem":{"title":"Flow can now detect unused Promises","permalink":"/blog/2023/04/10/Unused-Promise"},"nextItem":{"title":"Exact object types by default, by default","permalink":"/blog/2023/02/16/Exact-object-types-by-default-by-default"}},"content":"Starting in Flow version 0.201, make an object type\u2019s fields all optional using `Partial<ObjType>` (use instead of the unsafe `$Shape`),\\nand make an object type\u2019s optional fields required with `Required<ObjType>`."},{"id":"/2023/02/16/Exact-object-types-by-default-by-default","metadata":{"permalink":"/blog/2023/02/16/Exact-object-types-by-default-by-default","source":"@site/blog/2023-02-16-Exact-object-types-by-default-by-default.md","title":"Exact object types by default, by default","description":"We announced 5 years ago a plan to eventually make exact object types the default. We are now proceeding with this plan.","date":"2023-02-16T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"George Zahariev","key":null,"page":null}],"frontMatter":{"title":"Exact object types by default, by default","short-title":"Exact object types by default, by default","author":"George Zahariev","medium-link":"https://medium.com/flow-type/exact-object-types-by-default-by-default-cc559af6f69"},"unlisted":false,"prevItem":{"title":"Announcing Partial & Required Flow utility types + catch annotations","permalink":"/blog/2023/03/15/Announcing-Partial-and-Required-Flow-utility-types-and-catch-annotations"},"nextItem":{"title":"Local Type Inference for Flow","permalink":"/blog/2023/01/17/Local-Type-Inference"}},"content":"We announced 5 years ago a plan to eventually make exact object types the default. We are now proceeding with this plan."},{"id":"/2023/01/17/Local-Type-Inference","metadata":{"permalink":"/blog/2023/01/17/Local-Type-Inference","source":"@site/blog/2023-01-17-Local-Type-Inference.md","title":"Local Type Inference for Flow","description":"Local Type Inference makes Flow\u2019s inference behavior more reliable and predictable, by modestly increasing Flow\u2019s annotation requirement, bringing it closer to industry standard and capitalizing on increasingly strongly and explicitly typed codebases.","date":"2023-01-17T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Sam Zhou","key":null,"page":null}],"frontMatter":{"title":"Local Type Inference for Flow","short-title":"Local Type Inference","author":"Sam Zhou","medium-link":"https://medium.com/flow-type/local-type-inference-for-flow-aaa65d071347"},"unlisted":false,"prevItem":{"title":"Exact object types by default, by default","permalink":"/blog/2023/02/16/Exact-object-types-by-default-by-default"},"nextItem":{"title":"Improved handling of the empty object in Flow","permalink":"/blog/2022/10/20/Improved-handling-of-the-empty-object-in-Flow"}},"content":"Local Type Inference makes Flow\u2019s inference behavior more reliable and predictable, by modestly increasing Flow\u2019s annotation requirement, bringing it closer to industry standard and capitalizing on increasingly strongly and explicitly typed codebases."},{"id":"/2022/10/20/Improved-handling-of-the-empty-object-in-Flow","metadata":{"permalink":"/blog/2022/10/20/Improved-handling-of-the-empty-object-in-Flow","source":"@site/blog/2022-10-20-Improved-handling-of-the-empty-object-in-Flow.md","title":"Improved handling of the empty object in Flow","description":"Flow handled the empty object literal {} in a permissive but unsafe way. The fix described in this post increases safety and predictability, but requires using different patterns and behavior.","date":"2022-10-20T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"George Zahariev","key":null,"page":null}],"frontMatter":{"title":"Improved handling of the empty object in Flow","short-title":"Improvements to empty object","author":"George Zahariev","medium-link":"https://medium.com/flow-type/improved-handling-of-the-empty-object-in-flow-ead91887e40c"},"unlisted":false,"prevItem":{"title":"Local Type Inference for Flow","permalink":"/blog/2023/01/17/Local-Type-Inference"},"nextItem":{"title":"Requiring More Annotations to Functions and Classes in Flow","permalink":"/blog/2022/09/30/Requiring-More-Annotations-on-Functions-and-Classes"}},"content":"Flow handled the empty object literal {} in a permissive but unsafe way. The fix described in this post increases safety and predictability, but requires using different patterns and behavior."},{"id":"/2022/09/30/Requiring-More-Annotations-on-Functions-and-Classes","metadata":{"permalink":"/blog/2022/09/30/Requiring-More-Annotations-on-Functions-and-Classes","source":"@site/blog/2022-09-30-Requiring-More-Annotations-on-Functions-and-Classes.md","title":"Requiring More Annotations to Functions and Classes in Flow","description":"Flow will now require more annotations to functions and classes.","date":"2022-09-30T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Sam Zhou","key":null,"page":null}],"frontMatter":{"title":"Requiring More Annotations to Functions and Classes in Flow","short-title":"Functions and Classes Annotation Requirements","author":"Sam Zhou","medium-link":"https://medium.com/flow-type/requiring-more-annotations-to-functions-and-classes-in-flow-e8aa9b1d76bd"},"unlisted":false,"prevItem":{"title":"Improved handling of the empty object in Flow","permalink":"/blog/2022/10/20/Improved-handling-of-the-empty-object-in-Flow"},"nextItem":{"title":"New Flow Language Rule: Constrained Writes","permalink":"/blog/2022/08/05/New-Flow-Language-Rule-Constrained-Writes"}},"content":"Flow will now require more annotations to functions and classes."},{"id":"/2022/08/05/New-Flow-Language-Rule-Constrained-Writes","metadata":{"permalink":"/blog/2022/08/05/New-Flow-Language-Rule-Constrained-Writes","source":"@site/blog/2022-08-05-New-Flow-Language-Rule-Constrained-Writes.md","title":"New Flow Language Rule: Constrained Writes","description":"Flow is releasing a new language rule that determines the type of an unannotated variable at its initialization. Along with these new rules come several fixes to soundness bugs that were causing refinements to not be invalidated.","date":"2022-08-05T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Jordan Brown","key":null,"page":null}],"frontMatter":{"title":"New Flow Language Rule: Constrained Writes","short-title":"Introducing Constrained Writes","author":"Jordan Brown","medium-link":"https://medium.com/flow-type/new-flow-language-rule-constrained-writes-4c70e375d190"},"unlisted":false,"prevItem":{"title":"Requiring More Annotations to Functions and Classes in Flow","permalink":"/blog/2022/09/30/Requiring-More-Annotations-on-Functions-and-Classes"},"nextItem":{"title":"Introducing: Local Type Inference for Flow","permalink":"/blog/2021/09/27/Introducing-Local-Type-Inference-for-Flow"}},"content":"Flow is releasing a new language rule that determines the type of an unannotated variable at its initialization. Along with these new rules come several fixes to soundness bugs that were causing refinements to not be invalidated."},{"id":"/2021/09/27/Introducing-Local-Type-Inference-for-Flow","metadata":{"permalink":"/blog/2021/09/27/Introducing-Local-Type-Inference-for-Flow","source":"@site/blog/2021-09-27-Introducing-Local-Type-Inference-for-Flow.md","title":"Introducing: Local Type Inference for Flow","description":"We\'re replacing Flow\u2019s current inference engine with a system that behaves more predictably and can be reasoned about more locally.","date":"2021-09-27T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Michael Vitousek","key":null,"page":null}],"frontMatter":{"title":"Introducing: Local Type Inference for Flow","short-title":"Introducing Local Type Inference","author":"Michael Vitousek","medium-link":"https://medium.com/flow-type/introducing-local-type-inference-for-flow-6af65b7830aa"},"unlisted":false,"prevItem":{"title":"New Flow Language Rule: Constrained Writes","permalink":"/blog/2022/08/05/New-Flow-Language-Rule-Constrained-Writes"},"nextItem":{"title":"Introducing Flow Enums","permalink":"/blog/2021/09/13/Introducing-Flow-Enums"}},"content":"We\'re replacing Flow\u2019s current inference engine with a system that behaves more predictably and can be reasoned about more locally."},{"id":"/2021/09/13/Introducing-Flow-Enums","metadata":{"permalink":"/blog/2021/09/13/Introducing-Flow-Enums","source":"@site/blog/2021-09-13-Introducing-Flow-Enums.md","title":"Introducing Flow Enums","description":"Flow Enums are an opt-in feature which allow you to define a fixed set of constants which create their own type.","date":"2021-09-13T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"George Zahariev","key":null,"page":null}],"frontMatter":{"title":"Introducing Flow Enums","short-title":"Introducing Flow Enums","author":"George Zahariev","medium-link":"https://medium.com/flow-type/introducing-flow-enums-16d4239b3180"},"unlisted":false,"prevItem":{"title":"Introducing: Local Type Inference for Flow","permalink":"/blog/2021/09/27/Introducing-Local-Type-Inference-for-Flow"},"nextItem":{"title":"TypeScript Enums vs. Flow Enums","permalink":"/blog/2021/09/13/TypeScript-Enums-vs-Flow-Enums"}},"content":"Flow Enums are an opt-in feature which allow you to define a fixed set of constants which create their own type."},{"id":"/2021/09/13/TypeScript-Enums-vs-Flow-Enums","metadata":{"permalink":"/blog/2021/09/13/TypeScript-Enums-vs-Flow-Enums","source":"@site/blog/2021-09-13-TypeScript-Enums-vs-Flow-Enums.md","title":"TypeScript Enums vs. Flow Enums","description":"A comparison of the enums features of TypeScript and Flow.","date":"2021-09-13T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"George Zahariev","key":null,"page":null}],"frontMatter":{"title":"TypeScript Enums vs. Flow Enums","short-title":"TypeScript Enums vs. Flow Enums","author":"George Zahariev","medium-link":"https://medium.com/flow-type/typescript-enums-vs-flow-enums-83da2ca4a9b4"},"unlisted":false,"prevItem":{"title":"Introducing Flow Enums","permalink":"/blog/2021/09/13/Introducing-Flow-Enums"},"nextItem":{"title":"Introducing Flow Indexed Access Types","permalink":"/blog/2021/07/21/Introducing-Flow-Indexed-Access-Types"}},"content":"A comparison of the enums features of TypeScript and Flow."},{"id":"/2021/07/21/Introducing-Flow-Indexed-Access-Types","metadata":{"permalink":"/blog/2021/07/21/Introducing-Flow-Indexed-Access-Types","source":"@site/blog/2021-07-21-Introducing-Flow-Indexed-Access-Types.md","title":"Introducing Flow Indexed Access Types","description":"Flow\u2019s Indexed Access Types are a new type annotation syntax that allows you to get the type of a property from an object, array, or tuple type.","date":"2021-07-21T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"George Zahariev","key":null,"page":null}],"frontMatter":{"title":"Introducing Flow Indexed Access Types","short-title":"Flow Indexed Access Types","author":"George Zahariev","medium-link":"https://medium.com/flow-type/introducing-flow-indexed-access-types-b27175251fd0"},"unlisted":false,"prevItem":{"title":"TypeScript Enums vs. Flow Enums","permalink":"/blog/2021/09/13/TypeScript-Enums-vs-Flow-Enums"},"nextItem":{"title":"Sound Typing for \'this\' in Flow","permalink":"/blog/2021/06/02/Sound-Typing-for-this-in-Flow"}},"content":"Flow\u2019s Indexed Access Types are a new type annotation syntax that allows you to get the type of a property from an object, array, or tuple type."},{"id":"/2021/06/02/Sound-Typing-for-this-in-Flow","metadata":{"permalink":"/blog/2021/06/02/Sound-Typing-for-this-in-Flow","source":"@site/blog/2021-06-02-Sound-Typing-for-this-in-Flow.md","title":"Sound Typing for \'this\' in Flow","description":"Improvements in soundness for this-typing in Flow, including the ability to annotate this on functions and methods.","date":"2021-06-02T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Daniel Sainati","key":null,"page":null}],"frontMatter":{"title":"Sound Typing for \'this\' in Flow","short-title":"Sound Typing for \'this\'","author":"Daniel Sainati","medium-link":"https://medium.com/flow-type/sound-typing-for-this-in-flow-d62db2af969e"},"unlisted":false,"prevItem":{"title":"Introducing Flow Indexed Access Types","permalink":"/blog/2021/07/21/Introducing-Flow-Indexed-Access-Types"},"nextItem":{"title":"Clarity on Flow\'s Direction and Open Source Engagement","permalink":"/blog/2021/05/25/Clarity-on-Flows-Direction-and-Open-Source-Engagement"}},"content":"Improvements in soundness for `this`-typing in Flow, including the ability to annotate `this` on functions and methods."},{"id":"/2021/05/25/Clarity-on-Flows-Direction-and-Open-Source-Engagement","metadata":{"permalink":"/blog/2021/05/25/Clarity-on-Flows-Direction-and-Open-Source-Engagement","source":"@site/blog/2021-05-25-Clarity-on-Flows-Direction-and-Open-Source-Engagement.md","title":"Clarity on Flow\'s Direction and Open Source Engagement","description":"An update on Flow\'s direction and open source engagement.","date":"2021-05-25T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Vladan Djeric","key":null,"page":null}],"frontMatter":{"title":"Clarity on Flow\'s Direction and Open Source Engagement","short-title":"Flow Direction Update","author":"Vladan Djeric","medium-link":"https://medium.com/flow-type/clarity-on-flows-direction-and-open-source-engagement-e721a4eb4d8b"},"unlisted":false,"prevItem":{"title":"Sound Typing for \'this\' in Flow","permalink":"/blog/2021/06/02/Sound-Typing-for-this-in-Flow"},"nextItem":{"title":"Types-First the only supported mode in Flow (Jan 2021)","permalink":"/blog/2020/12/01/Types-first-the-only-supported-mode-in-flow"}},"content":"An update on Flow\'s direction and open source engagement."},{"id":"/2020/12/01/Types-first-the-only-supported-mode-in-flow","metadata":{"permalink":"/blog/2020/12/01/Types-first-the-only-supported-mode-in-flow","source":"@site/blog/2020-12-01-Types-first-the-only-supported-mode-in-flow.md","title":"Types-First the only supported mode in Flow (Jan 2021)","description":"Types-First will become the only mode in Flow in v0.143 (mid Jan 2021).","date":"2020-12-01T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Panagiotis Vekris","key":null,"page":null}],"frontMatter":{"title":"Types-First the only supported mode in Flow (Jan 2021)","short-title":"Types-First only supported mode","author":"Panagiotis Vekris","medium-link":"https://medium.com/flow-type/types-first-the-only-supported-mode-in-flow-jan-2021-3c4cb14d7b6c"},"unlisted":false,"prevItem":{"title":"Clarity on Flow\'s Direction and Open Source Engagement","permalink":"/blog/2021/05/25/Clarity-on-Flows-Direction-and-Open-Source-Engagement"},"nextItem":{"title":"Flow\'s Improved Handling of Generic Types","permalink":"/blog/2020/11/16/Flows-Improved-Handling-of-Generic-Types"}},"content":"Types-First will become the only mode in Flow in v0.143 (mid Jan 2021)."},{"id":"/2020/11/16/Flows-Improved-Handling-of-Generic-Types","metadata":{"permalink":"/blog/2020/11/16/Flows-Improved-Handling-of-Generic-Types","source":"@site/blog/2020-11-16-Flows-Improved-Handling-of-Generic-Types.md","title":"Flow\'s Improved Handling of Generic Types","description":"Flow has improved its handling of generic types by banning unsafe behaviors previously allowed and clarifying error messages.","date":"2020-11-16T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Michael Vitousek","key":null,"page":null}],"frontMatter":{"title":"Flow\'s Improved Handling of Generic Types","short-title":"Generic Types Improvements","author":"Michael Vitousek","medium-link":"https://medium.com/flow-type/flows-improved-handling-of-generic-types-b5909cc5e3c5"},"unlisted":false,"prevItem":{"title":"Types-First the only supported mode in Flow (Jan 2021)","permalink":"/blog/2020/12/01/Types-first-the-only-supported-mode-in-flow"},"nextItem":{"title":"Types-First: A Scalable New Architecture for Flow","permalink":"/blog/2020/05/18/Types-First-A-Scalable-New-Architecture-for-Flow"}},"content":"Flow has improved its handling of generic types by banning unsafe behaviors previously allowed and clarifying error messages."},{"id":"/2020/05/18/Types-First-A-Scalable-New-Architecture-for-Flow","metadata":{"permalink":"/blog/2020/05/18/Types-First-A-Scalable-New-Architecture-for-Flow","source":"@site/blog/2020-05-18-Types-First-A-Scalable-New-Architecture-for-Flow.md","title":"Types-First: A Scalable New Architecture for Flow","description":"Flow Types-First mode is out! It unlocks Flow\u2019s potential at scale by leveraging fully typed module boundaries. Read more in our latest blog post.","date":"2020-05-18T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Panagiotis Vekris","key":null,"page":null}],"frontMatter":{"title":"Types-First: A Scalable New Architecture for Flow","short-title":"Types-First: A Scalable New","author":"Panagiotis Vekris","medium-link":"https://medium.com/flow-type/types-first-a-scalable-new-architecture-for-flow-3d8c7ba1d4eb"},"unlisted":false,"prevItem":{"title":"Flow\'s Improved Handling of Generic Types","permalink":"/blog/2020/11/16/Flows-Improved-Handling-of-Generic-Types"},"nextItem":{"title":"Making Flow error suppressions more specific","permalink":"/blog/2020/03/16/Making-Flow-error-suppressions-more-specific"}},"content":"Flow Types-First mode is out! It unlocks Flow\u2019s potential at scale by leveraging fully typed module boundaries. Read more in our latest blog post."},{"id":"/2020/03/16/Making-Flow-error-suppressions-more-specific","metadata":{"permalink":"/blog/2020/03/16/Making-Flow-error-suppressions-more-specific","source":"@site/blog/2020-03-16-Making-Flow-error-suppressions-more-specific.md","title":"Making Flow error suppressions more specific","description":"We\u2019re improving Flow error suppressions so that they don\u2019t accidentally hide errors.","date":"2020-03-16T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Daniel Sainati","key":null,"page":null}],"frontMatter":{"title":"Making Flow error suppressions more specific","short-title":"Making Flow error suppressions","author":"Daniel Sainati","medium-link":"https://medium.com/flow-type/making-flow-error-suppressions-more-specific-280aa4e3c95c"},"unlisted":false,"prevItem":{"title":"Types-First: A Scalable New Architecture for Flow","permalink":"/blog/2020/05/18/Types-First-A-Scalable-New-Architecture-for-Flow"},"nextItem":{"title":"What we\u2019re building in 2020","permalink":"/blog/2020/03/09/What-were-building-in-2020"}},"content":"We\u2019re improving Flow error suppressions so that they don\u2019t accidentally hide errors."},{"id":"/2020/03/09/What-were-building-in-2020","metadata":{"permalink":"/blog/2020/03/09/What-were-building-in-2020","source":"@site/blog/2020-03-09-What-were-building-in-2020.md","title":"What we\u2019re building in 2020","description":"Learn about how Flow will improve in 2020.","date":"2020-03-09T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Andrew Pardoe","key":null,"page":null}],"frontMatter":{"title":"What we\u2019re building in 2020","short-title":"What we\u2019re building in 2020","author":"Andrew Pardoe","medium-link":"https://medium.com/flow-type/what-were-building-in-2020-bcb92f620c75"},"unlisted":false,"prevItem":{"title":"Making Flow error suppressions more specific","permalink":"/blog/2020/03/16/Making-Flow-error-suppressions-more-specific"},"nextItem":{"title":"Improvements to Flow in 2019","permalink":"/blog/2020/02/19/Improvements-to-Flow-in-2019"}},"content":"Learn about how Flow will improve in 2020."},{"id":"/2020/02/19/Improvements-to-Flow-in-2019","metadata":{"permalink":"/blog/2020/02/19/Improvements-to-Flow-in-2019","source":"@site/blog/2020-02-19-Improvements-to-Flow-in-2019.md","title":"Improvements to Flow in 2019","description":"Take a look back at improvements we made to Flow in 2019.","date":"2020-02-19T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Andrew Pardoe","key":null,"page":null}],"frontMatter":{"title":"Improvements to Flow in 2019","short-title":"Improvements to Flow in 2019","author":"Andrew Pardoe","medium-link":"https://medium.com/flow-type/improvements-to-flow-in-2019-c8378e7aa007"},"unlisted":false,"prevItem":{"title":"What we\u2019re building in 2020","permalink":"/blog/2020/03/09/What-were-building-in-2020"},"nextItem":{"title":"How to upgrade to exact-by-default object type syntax","permalink":"/blog/2020/01/29/How-to-Upgrade-to-exact-by-default-object-type-syntax"}},"content":"Take a look back at improvements we made to Flow in 2019."},{"id":"/2020/01/29/How-to-Upgrade-to-exact-by-default-object-type-syntax","metadata":{"permalink":"/blog/2020/01/29/How-to-Upgrade-to-exact-by-default-object-type-syntax","source":"@site/blog/2020-01-29-How-to-Upgrade-to-exact-by-default-object-type-syntax.md","title":"How to upgrade to exact-by-default object type syntax","description":"Object types will become exact-by-default. Read this post to learn how to get your code ready!","date":"2020-01-29T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Jordan Brown","key":null,"page":null}],"frontMatter":{"title":"How to upgrade to exact-by-default object type syntax","short-title":"Upgrade to exact-by-default","author":"Jordan Brown","medium-link":"https://medium.com/flow-type/how-to-upgrade-to-exact-by-default-object-type-syntax-7aa44b4d08ab"},"unlisted":false,"prevItem":{"title":"Improvements to Flow in 2019","permalink":"/blog/2020/02/19/Improvements-to-Flow-in-2019"},"nextItem":{"title":"Spreads: Common Errors & Fixes","permalink":"/blog/2019/10/30/Spreads-Common-Errors-and-Fixes"}},"content":"Object types will become exact-by-default. Read this post to learn how to get your code ready!"},{"id":"/2019/10/30/Spreads-Common-Errors-and-Fixes","metadata":{"permalink":"/blog/2019/10/30/Spreads-Common-Errors-and-Fixes","source":"@site/blog/2019-10-30-Spreads-Common-Errors-and-Fixes.md","title":"Spreads: Common Errors & Fixes","description":"Fixes to object spreads will expose errors in your codebase. Read more about common errors and how to fix them.","date":"2019-10-30T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Jordan Brown","key":null,"page":null}],"frontMatter":{"title":"Spreads: Common Errors & Fixes","short-title":"Spreads: Common Errors & Fixes","author":"Jordan Brown","medium-link":"https://medium.com/flow-type/spreads-common-errors-fixes-9701012e9d58"},"unlisted":false,"prevItem":{"title":"How to upgrade to exact-by-default object type syntax","permalink":"/blog/2020/01/29/How-to-Upgrade-to-exact-by-default-object-type-syntax"},"nextItem":{"title":"Live Flow errors in your IDE","permalink":"/blog/2019/10/25/Live-Flow-Errors-in-your-IDE"}},"content":"Fixes to object spreads will expose errors in your codebase. Read more about common errors and how to fix them."},{"id":"/2019/10/25/Live-Flow-Errors-in-your-IDE","metadata":{"permalink":"/blog/2019/10/25/Live-Flow-Errors-in-your-IDE","source":"@site/blog/2019-10-25-Live-Flow-Errors-in-your-IDE.md","title":"Live Flow errors in your IDE","description":"Live errors while you type makes Flow feel faster in your IDE!","date":"2019-10-25T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Gabe Levi","key":null,"page":null}],"frontMatter":{"title":"Live Flow errors in your IDE","short-title":"Live Flow errors in your IDE","author":"Gabe Levi","medium-link":"https://medium.com/flow-type/live-flow-errors-in-your-ide-bcbeda0b316"},"unlisted":false,"prevItem":{"title":"Spreads: Common Errors & Fixes","permalink":"/blog/2019/10/30/Spreads-Common-Errors-and-Fixes"},"nextItem":{"title":"Coming Soon: Changes to Object Spreads","permalink":"/blog/2019/08/20/Changes-to-Object-Spreads"}},"content":"Live errors while you type makes Flow feel faster in your IDE!"},{"id":"/2019/08/20/Changes-to-Object-Spreads","metadata":{"permalink":"/blog/2019/08/20/Changes-to-Object-Spreads","source":"@site/blog/2019-08-20-Changes-to-Object-Spreads.md","title":"Coming Soon: Changes to Object Spreads","description":"Changes are coming to how Flow models object spreads! Learn more in this post.","date":"2019-08-20T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Jordan Brown","key":null,"page":null}],"frontMatter":{"title":"Coming Soon: Changes to Object Spreads","short-title":"Changes to Object Spreads","author":"Jordan Brown","medium-link":"https://medium.com/flow-type/coming-soon-changes-to-object-spreads-73204aef84e1"},"unlisted":false,"prevItem":{"title":"Live Flow errors in your IDE","permalink":"/blog/2019/10/25/Live-Flow-Errors-in-your-IDE"},"nextItem":{"title":"Upgrading Flow Codebases","permalink":"/blog/2019/4/9/Upgrading-Flow-Codebases"}},"content":"Changes are coming to how Flow models object spreads! Learn more in this post."},{"id":"/2019/4/9/Upgrading-Flow-Codebases","metadata":{"permalink":"/blog/2019/4/9/Upgrading-Flow-Codebases","source":"@site/blog/2019-4-9-Upgrading-Flow-Codebases.md","title":"Upgrading Flow Codebases","description":"Having trouble upgrading from 0.84.0? Read about how the Flow team upgrades Flow at Facebook!","date":"2019-04-09T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Jordan Brown","key":null,"page":null}],"frontMatter":{"title":"Upgrading Flow Codebases","short-title":"Upgrading Flow Codebases","author":"Jordan Brown","medium-link":"https://medium.com/flow-type/upgrading-flow-codebases-40ef8dd3ccd8"},"unlisted":false,"prevItem":{"title":"Coming Soon: Changes to Object Spreads","permalink":"/blog/2019/08/20/Changes-to-Object-Spreads"},"nextItem":{"title":"A More Responsive Flow","permalink":"/blog/2019/2/8/A-More-Responsive-Flow"}},"content":"Having trouble upgrading from 0.84.0? Read about how the Flow team upgrades Flow at Facebook!"},{"id":"/2019/2/8/A-More-Responsive-Flow","metadata":{"permalink":"/blog/2019/2/8/A-More-Responsive-Flow","source":"@site/blog/2019-2-8-A-More-Responsive-Flow.md","title":"A More Responsive Flow","description":"Flow 0.92 improves on the Flow developer experience.","date":"2019-02-08T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Gabe Levi","key":null,"page":null}],"frontMatter":{"title":"A More Responsive Flow","short-title":"A More Responsive Flow","author":"Gabe Levi","medium-link":"https://medium.com/flow-type/a-more-responsive-flow-1a8cb01aec11"},"unlisted":false,"prevItem":{"title":"Upgrading Flow Codebases","permalink":"/blog/2019/4/9/Upgrading-Flow-Codebases"},"nextItem":{"title":"What the Flow Team Has Been Up To","permalink":"/blog/2019/1/28/What-the-flow-team-has-been-up-to"}},"content":"Flow 0.92 improves on the Flow developer experience."},{"id":"/2019/1/28/What-the-flow-team-has-been-up-to","metadata":{"permalink":"/blog/2019/1/28/What-the-flow-team-has-been-up-to","source":"@site/blog/2019-1-28-What-the-flow-team-has-been-up-to.md","title":"What the Flow Team Has Been Up To","description":"Take a look at what the Flow was up to in 2018.","date":"2019-01-28T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Avik Chaudhuri","key":null,"page":null}],"frontMatter":{"title":"What the Flow Team Has Been Up To","short-title":"What the Flow Team Has Been Up To","author":"Avik Chaudhuri","medium-link":"https://medium.com/flow-type/what-the-flow-team-has-been-up-to-54239c62004f"},"unlisted":false,"prevItem":{"title":"A More Responsive Flow","permalink":"/blog/2019/2/8/A-More-Responsive-Flow"},"nextItem":{"title":"Supporting React.forwardRef and Beyond","permalink":"/blog/2018/12/13/React-Abstract-Component"}},"content":"Take a look at what the Flow was up to in 2018."},{"id":"/2018/12/13/React-Abstract-Component","metadata":{"permalink":"/blog/2018/12/13/React-Abstract-Component","source":"@site/blog/2018-12-13-React-Abstract-Component.md","title":"Supporting React.forwardRef and Beyond","description":"We made some major changes to our React model to better model new React components. Let\'s","date":"2018-12-13T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Jordan Brown","key":null,"page":null}],"frontMatter":{"title":"Supporting React.forwardRef and Beyond","short-title":"Supporting React.forwardRef","author":"Jordan Brown","medium-link":"https://medium.com/flow-type/supporting-react-forwardref-and-beyond-f8dd88f35544"},"unlisted":false,"prevItem":{"title":"What the Flow Team Has Been Up To","permalink":"/blog/2019/1/28/What-the-flow-team-has-been-up-to"},"nextItem":{"title":"Asking for Required Annotations","permalink":"/blog/2018/10/29/Asking-for-Required-Annotations"}},"content":"We made some major changes to our React model to better model new React components. Let\'s\\ntalk about React.AbstractComponent!"},{"id":"/2018/10/29/Asking-for-Required-Annotations","metadata":{"permalink":"/blog/2018/10/29/Asking-for-Required-Annotations","source":"@site/blog/2018-10-29-Asking-for-Required-Annotations.md","title":"Asking for Required Annotations","description":"Flow will be asking for more annotations starting in 0.85.0. Learn how","date":"2018-10-29T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Sam Goldman","key":null,"page":null}],"frontMatter":{"title":"Asking for Required Annotations","short-title":"Asking for Required Annotations","author":"Sam Goldman","medium-link":"https://medium.com/flow-type/asking-for-required-annotations-64d4f9c1edf8"},"unlisted":false,"prevItem":{"title":"Supporting React.forwardRef and Beyond","permalink":"/blog/2018/12/13/React-Abstract-Component"},"nextItem":{"title":"On the Roadmap: Exact Objects by Default","permalink":"/blog/2018/10/18/Exact-Objects-By-Default"}},"content":"Flow will be asking for more annotations starting in 0.85.0. Learn how\\nto deal with these errors in our latest blog post."},{"id":"/2018/10/18/Exact-Objects-By-Default","metadata":{"permalink":"/blog/2018/10/18/Exact-Objects-By-Default","source":"@site/blog/2018-10-18-Exact-Objects-By-Default.md","title":"On the Roadmap: Exact Objects by Default","description":"We are changing object types to be exact by default. We\'ll be releasing codemods to help you upgrade.","date":"2018-10-18T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Jordan Brown","key":null,"page":null}],"frontMatter":{"title":"On the Roadmap: Exact Objects by Default","short-title":"Exact Objects by Default","author":"Jordan Brown","medium-link":"https://medium.com/flow-type/on-the-roadmap-exact-objects-by-default-16b72933c5cf"},"unlisted":false,"prevItem":{"title":"Asking for Required Annotations","permalink":"/blog/2018/10/29/Asking-for-Required-Annotations"},"nextItem":{"title":"New Flow Errors on Unknown Property Access in Conditionals","permalink":"/blog/2018/03/16/New-Flow-Errors-on-Unknown-Property-Access-in-Conditionals"}},"content":"We are changing object types to be exact by default. We\'ll be releasing codemods to help you upgrade."},{"id":"/2018/03/16/New-Flow-Errors-on-Unknown-Property-Access-in-Conditionals","metadata":{"permalink":"/blog/2018/03/16/New-Flow-Errors-on-Unknown-Property-Access-in-Conditionals","source":"@site/blog/2018-03-16-New-Flow-Errors-on-Unknown-Property-Access-in-Conditionals.md","title":"New Flow Errors on Unknown Property Access in Conditionals","description":"TL;DR: Starting in 0.68.0, Flow will now error when you access unknown","date":"2018-03-16T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Gabe Levi","key":null,"page":null}],"frontMatter":{"title":"New Flow Errors on Unknown Property Access in Conditionals","short-title":"Unknown Props in Conditionals","author":"Gabe Levi","medium-link":"https://medium.com/flow-type/new-flow-errors-on-unknown-property-access-in-conditionals-461da66ea10"},"unlisted":false,"prevItem":{"title":"On the Roadmap: Exact Objects by Default","permalink":"/blog/2018/10/18/Exact-Objects-By-Default"},"nextItem":{"title":"Better Flow Error Messages for the JavaScript Ecosystem","permalink":"/blog/2018/02/20/Better-Flow-Error-Messages-for-the-Javascript-Ecosystem"}},"content":"TL;DR: Starting in 0.68.0, Flow will now error when you access unknown\\nproperties in conditionals."},{"id":"/2018/02/20/Better-Flow-Error-Messages-for-the-Javascript-Ecosystem","metadata":{"permalink":"/blog/2018/02/20/Better-Flow-Error-Messages-for-the-Javascript-Ecosystem","source":"@site/blog/2018-02-20-Better-Flow-Error-Messages-for-the-Javascript-Ecosystem.md","title":"Better Flow Error Messages for the JavaScript Ecosystem","description":"Over the last year, the Flow team has been slowly auditing and improving all the","date":"2018-02-20T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Caleb Meredith","key":null,"page":null}],"frontMatter":{"title":"Better Flow Error Messages for the JavaScript Ecosystem","short-title":"Better Error Messages","author":"Caleb Meredith","medium-link":"https://medium.com/flow-type/better-flow-error-messages-for-the-javascript-ecosystem-73b6da948ae2"},"unlisted":false,"prevItem":{"title":"New Flow Errors on Unknown Property Access in Conditionals","permalink":"/blog/2018/03/16/New-Flow-Errors-on-Unknown-Property-Access-in-Conditionals"},"nextItem":{"title":"Typing Higher-Order Components in Recompose With Flow","permalink":"/blog/2017/09/03/Flow-Support-in-Recompose"}},"content":"Over the last year, the Flow team has been slowly auditing and improving all the\\npossible error messages generated by the type checker. In Flow 0.66 we\u2019re\\nexcited to announce a new error message format designed to decrease the time it\\ntakes you to read and fix each bug Flow finds."},{"id":"/2017/09/03/Flow-Support-in-Recompose","metadata":{"permalink":"/blog/2017/09/03/Flow-Support-in-Recompose","source":"@site/blog/2017-09-03-Flow-Support-in-Recompose.md","title":"Typing Higher-Order Components in Recompose With Flow","description":"One month ago Recompose landed an","date":"2017-09-03T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Ivan Starkov","key":null,"page":null}],"frontMatter":{"title":"Typing Higher-Order Components in Recompose With Flow","short-title":"Flow Support in Recompose","author":"Ivan Starkov","medium-link":"https://medium.com/flow-type/flow-support-in-recompose-1b76f58f4cfc"},"unlisted":false,"prevItem":{"title":"Better Flow Error Messages for the JavaScript Ecosystem","permalink":"/blog/2018/02/20/Better-Flow-Error-Messages-for-the-Javascript-Ecosystem"},"nextItem":{"title":"Private Object Properties Using Flow\u2019s Opaque Type Aliases","permalink":"/blog/2017/08/25/Private-Object-Properties-Using-Flows-Opaque-Type-Aliases"}},"content":"One month ago [Recompose](https://github.com/acdlite/recompose) landed an\\nofficial Flow library definition. The definitions were a long time coming,\\nconsidering the original PR was created by\\n[@GiulioCanti](https://twitter.com/GiulioCanti) a year ago."},{"id":"/2017/08/25/Private-Object-Properties-Using-Flows-Opaque-Type-Aliases","metadata":{"permalink":"/blog/2017/08/25/Private-Object-Properties-Using-Flows-Opaque-Type-Aliases","source":"@site/blog/2017-08-25-Private-Object-Properties-Using-Flows-Opaque-Type-Aliases.md","title":"Private Object Properties Using Flow\u2019s Opaque Type Aliases","description":"In the last few weeks, a proposal for private class fields in Javascript reached","date":"2017-08-25T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Jordan Brown","key":null,"page":null}],"frontMatter":{"title":"Private Object Properties Using Flow\u2019s Opaque Type Aliases","short-title":"Private Props w/ Opaque Types","author":"Jordan Brown","medium-link":"https://medium.com/flow-type/private-object-properties-using-flows-opaque-type-aliases-e0100e9b0282"},"unlisted":false,"prevItem":{"title":"Typing Higher-Order Components in Recompose With Flow","permalink":"/blog/2017/09/03/Flow-Support-in-Recompose"},"nextItem":{"title":"Even Better Support for React in Flow","permalink":"/blog/2017/08/16/Even-Better-Support-for-React-in-Flow"}},"content":"In the last few weeks, a proposal for [private class fields in Javascript](https://github.com/tc39/proposal-class-fields) reached\\nstage 3. This is going to be a great way to hide implementation details away\\nfrom users of your classes. However, locking yourself in to an OOP style of\\nprogramming is not always ideal if you prefer a more functional style. Let\u2019s\\ntalk about how you can use Flow\u2019s [opaque type aliases](https://flow.org/en/docs/types/opaque-types/) to get private properties\\n on any object type."},{"id":"/2017/08/16/Even-Better-Support-for-React-in-Flow","metadata":{"permalink":"/blog/2017/08/16/Even-Better-Support-for-React-in-Flow","source":"@site/blog/2017-08-16-Even-Better-Support-for-React-in-Flow.md","title":"Even Better Support for React in Flow","description":"The first version of Flow support for React was a magical implementation of","date":"2017-08-16T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Caleb Meredith","key":null,"page":null}],"frontMatter":{"title":"Even Better Support for React in Flow","short-title":"Even Better React Support","author":"Caleb Meredith","medium-link":"https://medium.com/flow-type/even-better-support-for-react-in-flow-25b0a3485627"},"unlisted":false,"prevItem":{"title":"Private Object Properties Using Flow\u2019s Opaque Type Aliases","permalink":"/blog/2017/08/25/Private-Object-Properties-Using-Flows-Opaque-Type-Aliases"},"nextItem":{"title":"Linting in Flow","permalink":"/blog/2017/08/04/Linting-in-Flow"}},"content":"The first version of Flow support for React was a magical implementation of\\n`React.createClass()`. Since then, React has evolved significantly. It is time\\nto rethink how Flow models React."},{"id":"/2017/08/04/Linting-in-Flow","metadata":{"permalink":"/blog/2017/08/04/Linting-in-Flow","source":"@site/blog/2017-08-04-Linting-in-Flow.md","title":"Linting in Flow","description":"Flow\u2019s type information is useful for so much more than just proving your programs are correct. Introducing Flow linter.","date":"2017-08-04T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Roger Ballard","key":null,"page":null}],"frontMatter":{"title":"Linting in Flow","short-title":"Linting in Flow","author":"Roger Ballard","medium-link":"https://medium.com/flow-type/linting-in-flow-7709d7a7e969"},"unlisted":false,"prevItem":{"title":"Even Better Support for React in Flow","permalink":"/blog/2017/08/16/Even-Better-Support-for-React-in-Flow"},"nextItem":{"title":"Opaque Type Aliases","permalink":"/blog/2017/07/27/Opaque-Types"}},"content":"Flow\u2019s type information is useful for so much more than just proving your programs are correct. Introducing Flow linter."},{"id":"/2017/07/27/Opaque-Types","metadata":{"permalink":"/blog/2017/07/27/Opaque-Types","source":"@site/blog/2017-07-27-Opaque-Types.md","title":"Opaque Type Aliases","description":"Do you ever wish that you could hide your implementation details away","date":"2017-07-27T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Jordan Brown","key":null,"page":null}],"frontMatter":{"title":"Opaque Type Aliases","short-title":"Opaque Type Aliases","author":"Jordan Brown","medium-link":"https://medium.com/flow-type/hiding-implementation-details-with-flows-new-opaque-type-aliases-feature-40e188c2a3f9"},"unlisted":false,"prevItem":{"title":"Linting in Flow","permalink":"/blog/2017/08/04/Linting-in-Flow"},"nextItem":{"title":"Strict Checking of Function Call Arity","permalink":"/blog/2017/05/07/Strict-Function-Call-Arity"}},"content":"Do you ever wish that you could hide your implementation details away\\nfrom your users? Find out how opaque type aliases can get the job done!"},{"id":"/2017/05/07/Strict-Function-Call-Arity","metadata":{"permalink":"/blog/2017/05/07/Strict-Function-Call-Arity","source":"@site/blog/2017-05-07-Strict-Function-Call-Arity.md","title":"Strict Checking of Function Call Arity","description":"One of Flow\'s original goals was to be able to understand idiomatic JavaScript.","date":"2017-05-07T00:00:00.000Z","tags":[],"hasTruncateMarker":true,"authors":[{"name":"Gabe Levi","key":null,"page":null}],"frontMatter":{"title":"Strict Checking of Function Call Arity","short-title":"Strict Function Call Arity","author":"Gabe Levi","hide_table_of_contents":true},"unlisted":false,"prevItem":{"title":"Opaque Type Aliases","permalink":"/blog/2017/07/27/Opaque-Types"},"nextItem":{"title":"Introducing Flow-Typed","permalink":"/blog/2016/10/13/Flow-Typed"}},"content":"One of Flow\'s original goals was to be able to understand idiomatic JavaScript.\\nIn JavaScript, you can call a function with more arguments than the function\\nexpects. Therefore, Flow never complained about calling a function with\\nextraneous arguments.\\n\\nWe are changing this behavior.\\n\\n\x3c!--truncate--\x3e\\n\\n### What is arity?\\n\\nA function\'s *arity* is the number of arguments it expects. Since some functions\\nhave optional parameters and some use rest parameters, we can define the\\n*minimum arity* as the smallest number of arguments it expects and the *maximum\\narity* as the largest number of arguments it expects.\\n\\n```js\\nfunction no_args() {} // arity of 0\\nfunction two_args(a, b) {} // arity of 2\\nfunction optional_args(a, b?) {} // min arity of 1, max arity of 2\\nfunction many_args(a, ...rest) {} // min arity of 1, no max arity\\n```\\n\\n### Motivation\\n\\nConsider the following code:\\n\\n```js\\nfunction add(a, b) { return a + b; }\\nconst sum = add(1, 1, 1, 1);\\n```\\n\\nThe author apparently thought the `add()` function adds up all its\\narguments, and that `sum` will have the value `4`. However, only the first two\\narguments are summed, and `sum` actually will have the value `2`. This is\\nobviously a bug, so why doesn\'t JavaScript or Flow complain?\\n\\nAnd while the error in the above example is easy to see, in real code it\'s often\\na lot harder to notice. For example, what is the value of `total` here:\\n\\n```js\\nconst total = parseInt(\\"10\\", 2) + parseFloat(\\"10.1\\", 2);\\n```\\n\\n`\\"10\\"` in base 2 is `2` in decimal and `\\"10.1\\"` in base 2 is `2.5` in decimal.\\nSo the author probably thought that `total` would be `4.5`. However, the correct\\nanswer is `12.1`. `parseInt(\\"10\\", 2)` does evaluates to `2`, as expected.\\nHowever, `parseFloat(\\"10.1\\", 2)` evaluates to `10.1`. `parseFloat()` only takes\\na single argument. The second argument is ignored!\\n\\n### Why JavaScript allows extraneous arguments\\n\\nAt this point, you might feel like this is just an example of JavaScript making\\nterrible life decisions. However, this behavior is very convenient in a bunch of\\nsituations!\\n\\n#### Callbacks\\n\\nIf you couldn\'t call a function with more arguments than it handles, then\\nmapping over an array would look like\\n\\n```js\\nconst doubled_arr = [1, 2, 3].map((element, index, arr) => element * 2);\\n```\\n\\nWhen you call `Array.prototype.map`, you pass in a callback. For each element in\\nthe array, that callback is invoked and passed 3 arguments:\\n\\n1. The element\\n2. The index of the element\\n3. The array over which you\'re mapping\\n\\nHowever, your callback often only needs to reference the first argument: the\\nelement. It\'s really nice that you can write\\n\\n```js\\nconst doubled_arr = [1, 2, 3].map(element => element * 2);\\n```\\n\\n#### Stubbing\\n\\nSometimes I come across code like this\\n\\n```js\\nlet log = () => {};\\nif (DEBUG) {\\n  log = (message) => console.log(message);\\n}\\nlog(\\"Hello world\\");\\n```\\n\\nThe idea is that in a development environment, calling `log()` will output a\\nmessage, but in production it does nothing. Since you can call a\\nfunction with more arguments than it expects, it is easy to stub out `log()` in\\nproduction.\\n\\n#### Variadic functions using `arguments`\\n\\nA variadic function is a function that can take an indefinite number of\\narguments. The old-school way to write variadic functions in JavaScript is by\\nusing `arguments`. For example\\n\\n```js\\nfunction sum_all() {\\n  let ret = 0;\\n  for (let i = 0; i < arguments.length; i++) { ret += arguments[i]; }\\n  return ret;\\n}\\nconst total = sum_all(1, 2, 3); // returns 6\\n```\\n\\nFor all intents and purposes, `sum_all` appears like it takes no arguments. So\\neven though it appears to have an arity of 0, it is convenient that we can call\\nit with more arguments.\\n\\n### Changes to Flow\\n\\nWe think we have found a compromise which catches the motivating bugs without\\nbreaking the convenience of JavaScript.\\n\\n#### Calling a function\\n\\nIf a function has a maximum arity of N, then Flow will start complaining if you\\ncall it with more than N arguments.\\n\\n```js\\ntest:1\\n  1: const num = parseFloat(\\"10.5\\", 2);\\n                                    ^ unused function argument\\n   19: declare function parseFloat(string: mixed): number;\\n                                  ^^^^^^^^^^^^^^^^^^^^^^^ function type expects no more than 1 argument. See lib: <BUILTINS>/core.js:19\\n```\\n\\n#### Function subtyping\\n\\nFlow will not change its function subtyping behavior. A function\\nwith a smaller maximum arity is still a subtype of a function with a larger\\nmaximum arity. This allows callbacks to still work as before.\\n\\n```js\\nclass Array<T> {\\n  ...\\n  map<U>(callbackfn: (value: T, index: number, array: Array<T>) => U, thisArg?: any): Array<U>;\\n  ...\\n}\\nconst arr = [1,2,3].map(() => 4); // No error, evaluates to [4,4,4]\\n```\\n\\nIn this example, `() => number` is a subtype of `(number, number, Array<number>) => number`.\\n\\n#### Stubbing and variadic functions\\n\\nThis will, unfortunately, cause Flow to complain about stubs and variadic\\nfunctions which are written using `arguments`. However, you can fix these by\\nusing rest parameters\\n\\n```js\\nlet log (...rest) => {};\\n\\nfunction sum_all(...rest) {\\n  let ret = 0;\\n  for (let i = 0; i < rest.length; i++) { ret += rest[i]; }\\n  return ret;\\n}\\n```\\n\\n### Rollout plan\\n\\nFlow v0.46.0 will ship with strict function call arity turned off by default. It\\ncan be enabled via your `.flowconfig` with the flag\\n\\n```ini\\nexperimental.strict_call_arity=true\\n```\\n\\nFlow v0.47.0 will ship with strict function call arity turned on and the\\n`experimental.strict_call_arity` flag will be removed.\\n\\n\\n#### Why turn this on over two releases?\\n\\nThis decouples the switch to strict checking of function call arity from the\\nrelease.\\n\\n#### Why not keep the `experimental.strict_call_arity` flag?\\n\\nThis is a pretty core change. If we kept both behaviors, we\'d have to test that\\neverything works with and without this change. As we add more flags, the number\\nof combinations grows exponentially, and Flow\'s behavior gets harder to reason\\nabout. For this reason, we\'re choosing only one behavior: strict checking of\\nfunction call arity.\\n\\n### What do you think?\\n\\nThis change was motivated by feedback from Flow users. We really appreciate\\nall the members of our community who take the time to share their feedback with\\nus. This feedback is invaluable and helps us make Flow better, so please keep\\nit coming!"},{"id":"/2016/10/13/Flow-Typed","metadata":{"permalink":"/blog/2016/10/13/Flow-Typed","source":"@site/blog/2016-10-13-Flow-Typed.md","title":"Introducing Flow-Typed","description":"Having high-quality and community-driven library definitions (\u201clibdefs\u201d) are","date":"2016-10-13T00:00:00.000Z","tags":[],"hasTruncateMarker":true,"authors":[{"name":"Jeff Morrison","key":null,"page":null}],"frontMatter":{"title":"Introducing Flow-Typed","short-title":"Introducing Flow-Typed","author":"Jeff Morrison","hide_table_of_contents":true},"unlisted":false,"prevItem":{"title":"Strict Checking of Function Call Arity","permalink":"/blog/2017/05/07/Strict-Function-Call-Arity"},"nextItem":{"title":"Property Variance and Other Upcoming Changes","permalink":"/blog/2016/10/04/Property-Variance"}},"content":"Having high-quality and community-driven library definitions (\u201clibdefs\u201d) are\\nimportant for having a great experience with Flow. Today, we are introducing\\n**flow-typed**: A [repository](https://github.com/flowtype/flow-typed/) and\\n[CLI tool](http://npmjs.org/packages/flow-typed) that represent the first parts\\nof a new workflow for building, sharing, and distributing Flow libdefs.\\n\\nThe goal of this project is to grow an ecosystem of libdefs that\\n[allows Flow\'s type inference to shine](https://medium.com/@thejameskyle/flow-mapping-an-object-373d64c44592)\\nand that aligns with Flow\'s mission: To extract precise and *accurate* types\\nfrom real-world JavaScript. We\'ve learned a lot from similar efforts like\\nDefinitelyTyped for TypeScript and we want to bring some of the lessons we\'ve\\nlearned to the Flow ecosystem.\\n\\nHere are some of the objectives of this project:\\n\\n\x3c!--truncate--\x3e\\n\\n- Libdefs should be **versioned** \u2014 both against the libraries they describe\\n  *and* against the version(s) of Flow they are compatible with.\\n- Libdefs should meet a **high quality bar**, including **libdef tests** to\\n  ensure that their quality persists over time.\\n- There must be a straightforward way to **contribute libdef improvements over\\n  time** and for developers to **benefit from those improvements** over time.\\n- The process of managing libdefs for a Flow project should be **automated,\\n  simple, and easy to get right**.\\n\\n### Versioned & Tested Libdefs\\n\\nAnyone can contribute a libdef (or improve on an existing one), but when doing\\nso it\'s important that we maintain a high quality bar so that all developers\\nfeel confident in the libdefs they are using. To address this, flow-typed\\nrequires that all libdef contributions are explicitly versioned against both\\nthe version of the library they are describing and the version(s) of Flow the\\nlibdef is compatible with.\\n\\nAdditionally, all libdefs must be accompanied by tests that exercise the\\nimportant parts of the API and assert that they yield the correct types. By\\nincluding both version information and tests with each libdef, we can\\nautomatically verify in Travis that the tests work as expected for all versions\\nof Flow a libdef is compatible with. Tests also help to ensure that future\\nchanges to the libdef don\'t regress its features over time.\\n\\n### Automating Libdef Installation\\n\\nWe\'ve built a simple CLI tool called `flow-typed` that helps to automate the\\nprocess of finding, installing, and upgrading libdefs in your Flow projects. It\\nuses the explicit version info associated with each libdef to find all\\nnecessary libdefs based on your project\'s package.json dependencies. This\\nminimizes the work you need to do in order to pull in and update libdefs in\\nyour projects.\\n\\nYou can get the flow-typed CLI using either yarn (`yarn global add flow-typed`)\\nor npm (`npm install -g flow-typed`).\\n\\n### Installing Libdefs\\n\\nInstalling libdefs from the flow-typed repository is a matter of running a\\nsingle command on your project after installing your dependencies:\\n\\n```\\n> yarn install # Or `npm install` if you\'re old-school :)\\n> flow-typed install\\n```\\n\\nThe `flow-typed install` command reads your project\'s package.json file,\\nqueries the flow-typed repository for libdefs matching your dependencies, and\\ninstalls the correctly-versioned libdefs into the `flow-typed/` directory for\\nyou. By default, Flow knows to look in the `flow-typed/` directory for libdefs\\n\u2014 so there is no additional configuration necessary.\\n\\nNote that it\'s necessary to run this command *after* running `yarn` or\\n`npm install`. This is because this command will also generate stub libdefs for\\nyou if one of your dependencies doesn\'t have types.\\n\\nOnce libdefs have been installed, **we recommend that you check them in to your\\nproject\'s repo**. Libdefs in the flow-typed repository may be improved over\\ntime (fixing a bug, more precise types, etc). If this happens for a libdef that\\nyou depend on, you\'ll want to have control over when that update is applied to\\nyour project. Periodically you can run `flow-typed update` to download any\\nlibdef updates, verify that your project still typechecks, and the commit the\\nupdates.\\n\\n### Why Not Just Use Npm To Distribute Libdefs?\\n\\nOver time libdefs in the flow-typed repo may be updated to fix bugs, improve\\naccuracy, or make use of new Flow features that better describe the types of\\nthe library. As a result, there are really 3 versions that apply to each\\nlibdef: The version of the library being described, the current version of the\\nlibdef in the flow-typed repo, and the version(s) of Flow the libdef is\\ncompatible with.\\n\\nIf an update is made to some libdef that you use in your project after you\'ve\\nalready installed it, there\'s a good chance that update may find new type\\nerrors in your project that were previously unknown. While it is certainly a\\ngood thing to find errors that were previously missed, you\'ll want to have\\ncontrol over when those changes get pulled in to your project.\\n\\nThis is the reason we advise that you commit your installed libdefs to version\\ncontrol rather than rely on a system like npm+semver to download and install a\\nnon-deterministic semver-ranged version from npm. Checking in your libdefs\\nensures that all collaborators on your project have consistent output from Flow\\nat any given commit in version history.\\n\\n### Building a Community\\n\\nThis is first and foremost a community project. It was started by a community\\nmember (hey [@splodingsocks](https://github.com/splodingsocks)!) and has\\nalready benefitted from hours of work by many others. Moreover, this will\\ncontinue to be a community effort: Anyone can create and/or help maintain a\\nlibdef for any npm library. Authors may create libdefs for their packages when\\npublishing, and/or consumers can create them when someone else hasn\'t already\\ndone so. Either way, everyone benefits!\\n\\nWe\'d like to send a big shout-out to [@marudor](https://github.com/marudor) for\\ncontributing so many of his own libdefs and spending time helping others to\\nwrite and contribute libdefs. Additionally we\'d like to thank\\n[@ryyppy](https://github.com/ryyppy) for helping to design and iterate on the\\nCLI and installation workflow as well as manage libdef reviews.\\n\\nThe Flow core team intends to stay invested in developing and improving this\\nproject, but in order for it to truly succeed we need your help! If you\'ve\\nalready written some libdefs for Flow projects that you work on, we encourage\\nyou to [contribute](https://github.com/flowtype/flow-typed/#how-do-i-contribute-library-definitions)\\nthem for others to benefit from them as well. By managing libdefs in a\\ncommunity-driven repository, the community as a whole can work together to\\nextend Flow\'s capabilities beyond just explicitly-typed JS.\\n\\nIt\'s still early days and there\'s still a lot to do, so we\'re excited to hear\\nyour ideas/feedback and read your pull requests! :)\\n\\nHappy typing!"},{"id":"/2016/10/04/Property-Variance","metadata":{"permalink":"/blog/2016/10/04/Property-Variance","source":"@site/blog/2016-10-04-Property-Variance.md","title":"Property Variance and Other Upcoming Changes","description":"The next release of Flow, 0.34, will include a few important changes to object","date":"2016-10-04T00:00:00.000Z","tags":[],"hasTruncateMarker":true,"authors":[{"name":"Sam Goldman","key":null,"page":null}],"frontMatter":{"title":"Property Variance and Other Upcoming Changes","short-title":"Property Variance","author":"Sam Goldman","hide_table_of_contents":true},"unlisted":false,"prevItem":{"title":"Introducing Flow-Typed","permalink":"/blog/2016/10/13/Flow-Typed"},"nextItem":{"title":"Windows Support is Here!","permalink":"/blog/2016/08/01/Windows-Support"}},"content":"The next release of Flow, 0.34, will include a few important changes to object\\ntypes:\\n\\n* property variance,\\n* invariant-by-default dictionary types,\\n* covariant-by-default method types,\\n* and more flexible getters and setters.\\n\\n\x3c!--truncate--\x3e\\n\\n### What is Variance?\\n\\nDefining the subtype relationship between types is a core responsibility of Flow\\nas a type system. These relationships are determined either directly for\\nsimple types or, for complex types, defined in terms of their parts.\\n\\nVariance describes the subtyping relationship for complex types as it relates\\nto the subtyping relationships of their parts.\\n\\nFor example, Flow directly encodes the knowledge that `string` is a subtype of\\n`?string`. Intuitively, a `string` type contains string values while a `?string`\\ntype contains `null`, `undefined`, and also string values, so membership in the\\nformer naturally implies membership in the later.\\n\\nThe subtype relationships between two function types is not as direct. Rather,\\nit is derived from the subtype relationships between the functions\' parameter\\nand return types.\\n\\nLet\'s see how this works for two simple function types:\\n\\n```js\\ntype F1 = (x: P1) => R1;\\ntype F2 = (x: P2) => R2;\\n```\\n\\nWhether `F2` is a subtype of `F1` depends on the relationships between `P1` and\\n`P2` and `R1` and `R2`. Let\'s use the notation `B <: A` to mean `B` is a\\nsubtype of `A`.\\n\\nIt turns out that `F2 <: F1` if `P1 <: P2` and `R2 <: R1`. Notice that the\\nrelationship for parameters is reversed? In technical terms, we can say that\\nfunction types are \\"contravariant\\" with respect to their parameter types and\\n\\"covariant\\" with respect to their return types.\\n\\nLet\'s look at an example:\\n\\n```js\\nfunction f(callback: (x: string) => ?number): number {\\n  return callback(\\"hi\\") || 0;\\n}\\n```\\n\\nWhat kinds of functions can we pass to `f`? Based on the subtyping rule above,\\nthen we can pass a function whose parameter type is a supertype of `string` and\\nwhose return type is a subtype of `?number`.\\n\\n```js\\nfunction g(x: ?string): number {\\n  return x ? x.length : 0;\\n}\\nf(g);\\n```\\n\\nThe body of `f` will only ever pass `string` values into `g`, which is safe\\nbecause `g` takes at least `string` by taking `?string`. Conversely, `g` will\\nonly ever return `number` values to `f`, which is safe because `f` handles at\\nleast `number` by handling `?number`.\\n\\n#### Input and Output\\n\\nOne convenient way to remember when something is covariant vs. contravariant is\\nto think about \\"input\\" and \\"output.\\"\\n\\nParameters are in an *input* position, often called a \\"negative\\" position.\\nComplex types are contravariant in their input positions.\\n\\nReturn is an *output* position, often called a \\"positive\\" position. Complex\\ntypes are covariant in their output positions.\\n\\n## Property Invariance\\n\\nJust as function types are composed of parameter and return types, so too are\\nobject types composed of property types. Thus, the subtyping relationship\\nbetween objects is derived from the subtyping relationships of their\\nproperties.\\n\\nHowever, unlike functions which have input parameters and an output return,\\nobject properties can be read and written. That is, properties are *both* input\\nand output.\\n\\nLet\'s see how this works for two simple object types:\\n\\n```js\\ntype O1 = {p: T1};\\ntype O2 = {p: T2};\\n```\\n\\nAs with function types, whether `O2` is a subtype of `O1` depends on the\\nrelationship between its parts, `T1` and `T2`.\\n\\nHere it turns out that `O2 <: O1` if `T2 <: T1` *and* `T1 <: T2`. In technical\\nterms, object types are \\"invariant\\" with respect to their property types.\\n\\nLet\'s look at an example:\\n\\n```js\\nfunction f(o: {p: ?string}): void {\\n  // We can read p from o\\n  let len: number;\\n  if (o.p) {\\n    len = o.p.length;\\n  } else {\\n    len = 0;\\n  }\\n\\n  // We can also write into p\\n  o.p = null;\\n}\\n```\\n\\nWhat kinds of objects can we pass into `f`, then? If we try to pass in an\\nobject with a subtype property, we get an error:\\n\\n```js\\nvar o1: {p: string} = {p: \\"\\"};\\nf(o1);\\n```\\n\\n```\\nfunction f(o: {p: ?string}) {}\\n                   ^ null. This type is incompatible with\\nvar o1: {p: string} = {p: \\"\\"};\\n            ^ string\\nfunction f(o: {p: ?string}) {}\\n                   ^ undefined. This type is incompatible with\\nvar o1: {p: string} = {p: \\"\\"};\\n            ^ string\\n```\\n\\nFlow has correctly identified an error here. If the body of `f` writes `null`\\ninto `o.p`, then `o1.p` would no longer have type `string`.\\n\\nIf we try to pass an object with a supertype property, we again get an error:\\n\\n```js\\nvar o2: {p: ?(string|number)} = {p: 0};\\nf(o2);\\n```\\n\\n```\\nvar o1: {p: ?(string|number)} = {p: \\"\\"};\\n                     ^ number. This type is incompatible with\\nfunction f(o: {p: ?string}) {}\\n                   ^ string\\n```\\n\\nAgain, Flow correctly identifies an error, because if `f` tried to read `p`\\nfrom `o`, it would find a number.\\n\\n### Property Variance\\n\\nSo objects have to be invariant with respect to their property types because\\nproperties can be read from and written to. But just because you *can* read and\\nwrite, doesn\'t mean you always do.\\n\\nConsider a function that gets the length of an nullable string property:\\n\\n```js\\nfunction f(o: {p: ?string}): number {\\n  return o.p ? o.p.length : 0;\\n}\\n```\\n\\nWe never write into `o.p`, so we should be able to pass in an object where the\\ntype of property `p` is a subtype of `?string`. Until now, this wasn\'t possible\\nin Flow.\\n\\nWith property variance, you can explicitly annotate object properties as being\\ncovariant and contravariant. For example, we can rewrite the above function:\\n\\n```js\\nfunction f(o: {+p: ?string}): number {\\n  return o.p ? o.p.length : 0;\\n}\\n\\nvar o: {p: string} = {p: \\"\\"};\\nf(o); // no type error!\\n```\\n\\nIt\'s crucial that covariant properties only ever appear in output positions. It\\nis an error to write to a covariant property:\\n\\n```js\\nfunction f(o: {+p: ?string}) {\\n  o.p = null;\\n}\\n```\\n\\n```\\no.p = null;\\n^ object type. Covariant property `p` incompatible with contravariant use in\\no.p = null;\\n^ assignment of property `p`\\n```\\n\\nConversely, if a function only ever writes to a property, we can annotate the\\nproperty as contravariant. This might come up in a function that initializes an\\nobject with default values, for example.\\n\\n```js\\nfunction g(o: {-p: string}): void {\\n  o.p = \\"default\\";\\n}\\nvar o: {p: ?string} = {p: null};\\ng(o);\\n```\\n\\nContravariant properties can only ever appear in input positions. It is an\\nerror to read from a contravariant property:\\n\\n```js\\nfunction f(o: {-p: string}) {\\n  o.p.length;\\n}\\n```\\n\\n```\\no.p.length;\\n^ object type. Contravariant property `p` incompatible with covariant use in\\no.p.length;\\n^ property `p`\\n```\\n\\n### Invariant-by-default Dictionary Types\\n\\nThe object type `{[key: string]: ?number}` describes an object that can be used\\nas a map. We can read any property and Flow will infer the result type as\\n`?number`. We can also write `null` or `undefined` or `number` into any\\nproperty.\\n\\nIn Flow 0.33 and earlier, these dictionary types were treated covariantly by\\nthe type system. For example, Flow accepted the following code:\\n\\n```js\\nfunction f(o: {[key: string]: ?number}) {\\n  o.p = null;\\n}\\ndeclare var o: {p: number};\\nf(o);\\n```\\n\\nThis is unsound because `f` can overwrite property `p` with `null`. In Flow\\n0.34, dictionaries are invariant, like named properties. The same code now\\nresults in the following type error:\\n\\n```\\nfunction f(o: {[key: string]: ?number}) {}\\n                               ^ null. This type is incompatible with\\ndeclare var o: {p: number};\\n                   ^ number\\nfunction f(o: {[key: string]: ?number}) {}\\n                               ^ undefined. This type is incompatible with\\ndeclare var o: {p: number};\\n                   ^ number\\n```\\n\\nCovariant and contravariant dictionaries can be incredibly useful, though. To\\nsupport this, the same syntax used to support variance for named properties can\\nbe used for dictionaries as well.\\n\\n```\\nfunction f(o: {+[key: string]: ?number}) {}\\ndeclare var o: {p: number};\\nf(o); // no type error!\\n```\\n\\n### Covariant-by-default Method Types\\n\\nES6 gave us a shorthand way to write object properties which are functions.\\n\\n```js\\nvar o = {\\n  m(x) {\\n    return x * 2\\n  }\\n}\\n```\\n\\nFlow now interprets properties which use this shorthand method syntax as\\ncovariant by default. This means it is an error to write to the property `m`.\\n\\nIf you don\'t want covariance, you can use the long form syntax:\\n\\n```js\\nvar o = {\\n  m: function(x) {\\n    return x * 2;\\n  }\\n}\\n```\\n\\n### More Flexible Getters and Setters\\n\\nIn Flow 0.33 and earlier, getters and setters had to agree exactly on their\\nreturn type and parameter type, respectively. Flow 0.34 lifts that restriction.\\n\\nThis means you can write code like the following:\\n\\n```js\\n// @flow\\ndeclare var x: string;\\n\\nvar o = {\\n  get x(): string {\\n    return x;\\n  },\\n  set x(value: ?string) {\\n    x = value || \\"default\\";\\n  }\\n}\\n```"},{"id":"/2016/08/01/Windows-Support","metadata":{"permalink":"/blog/2016/08/01/Windows-Support","source":"@site/blog/2016-08-01-Windows-Support.md","title":"Windows Support is Here!","description":"We are excited to announce that Flow is now officially available on 64-bit","date":"2016-08-01T00:00:00.000Z","tags":[],"hasTruncateMarker":true,"authors":[{"name":"Gabe Levi","key":null,"page":null}],"frontMatter":{"title":"Windows Support is Here!","short-title":"Windows Support","author":"Gabe Levi","hide_table_of_contents":true},"unlisted":false,"prevItem":{"title":"Property Variance and Other Upcoming Changes","permalink":"/blog/2016/10/04/Property-Variance"},"nextItem":{"title":"New Implementation of Unions and Intersections","permalink":"/blog/2016/07/01/New-Unions-Intersections"}},"content":"We are excited to announce that Flow is now officially available on 64-bit\\nWindows! Starting with\\n[Flow v0.30.0](https://github.com/facebook/flow/releases/tag/v0.30.0), we will\\npublish a Windows binary with each release. You can download the Windows binary\\nin a .zip file directly from the\\n[GitHub releases page](https://github.com/facebook/flow/releases) or install it\\nusing the [flow-bin npm package](https://www.npmjs.com/package/flow-bin). Try\\nit out and [report any issues](https://github.com/facebook/flow/issues) you\\ncome across!\\n\\nGetting Flow working on Windows was not easy, and it was made possible by the\\nhard work of [Gr\xe9goire](https://github.com/OCamlPro-Henry),\\n[\xc7agdas](https://github.com/OCamlPro-Bozman) and\\n[Fabrice](https://github.com/lefessan) from\\n[OCamlPro](https://www.ocamlpro.com/).\\n\\n\x3c!--truncate--\x3e\\n\\n### Getting Started with Windows\\n\\n#### Getting Started with flow-bin on Windows\\n\\nDoes your JavaScript project use npm to manage dependencies? Well, then the\\neasiest way for you to install Flow is with npm! Just run\\n\\n```bash\\n> npm install --save-dev flow-bin\\n```\\n\\n(Note: on Windows, it is recommended to use npm v3, to avoid the long\\n`node_modules` paths that npm v2 creates)\\n\\nThis will install the\\n[flow-bin npm package](https://www.npmjs.com/package/flow-bin) and\\nautomatically add it to your package.json. Once installed, there are a few ways\\nto use the Flow binary. One is to use `./node_modules/.bin/flow` directly. For\\nexample, every Flow project needs a `.flowconfig` file in the root directory.\\nIf you don\'t already have a `.flowconfig`, you could create it with Powershell,\\nlike\\n\\n```bash\\n> New-Item .flowconfig\\n```\\n\\nor you could run the `flow init` command, using `./node_modules/.bin/flow`\\n\\n```bash\\n> ./node_modules/.bin/flow init\\n```\\n\\nAnother way to run Flow is via an npm script. In your package.json file, there\\nis a `\\"scripts\\"` section. Maybe it looks like this:\\n\\n```js\\n\\"scripts\\": {\\n  \\"test\\": \\"make test\\"\\n}\\n```\\n\\nYou can run the Flow binary directly from a script by referencing `flow` in a\\nscript, like so:\\n\\n```js\\n\\"scripts\\": {\\n  \\"test\\": \\"make test\\",\\n  \\"flow_check\\": \\"flow check || exit 0\\"\\n}\\n```\\n\\nand then running that script via `npm run`\\n\\n```bash\\n> npm run flow_check\\n```\\n\\n(Note: the `|| exit 0` part of the script is optional, but `npm run` will show\\nan error message if the script finishes with a non-zero exit code)\\n\\nYou can also install `flow-bin` globally with\\n\\n```bash\\n> npm install --global flow-bin\\n```\\n\\n#### Getting Started with flow.exe\\n\\nEach [GitHub release of Flow](https://github.com/facebook/flow/releases)\\nstarting with v0.30.0 will have a zipped Windows binary. For example, the\\n[v0.30.0 release](https://github.com/facebook/flow/releases/tag/v0.30.0)\\nincludes [flow-win64-v0.30.0.zip](https://github.com/facebook/flow/releases/download/v0.30.0/flow-win64-v0.30.0.zip).\\nIf you download and unzip that, you will find a `flow/` directory, which\\ncontains `flow.exe`. `flow.exe` is the Flow binary, so if you put that\\nsomewhere in your path, and you should be good to go.\\n\\n```bash\\n> mkdir demo\\n> cd demo\\n> flow.exe init\\n> \\"/* @flow */ var x: number = true;\\" | Out-File -Encoding ascii test.js\\n> flow.exe check\\ntest.js:1\\n  1: /* @flow */ var x: number = true;\\n                                 ^^^^ boolean. This type is incompatible with\\n\\n  1: /* @flow */ var x: number = true;\\n                        ^^^^^^ number\\n```"},{"id":"/2016/07/01/New-Unions-Intersections","metadata":{"permalink":"/blog/2016/07/01/New-Unions-Intersections","source":"@site/blog/2016-07-01-New-Unions-Intersections.md","title":"New Implementation of Unions and Intersections","description":"Summary","date":"2016-07-01T00:00:00.000Z","tags":[],"hasTruncateMarker":true,"authors":[{"name":"Sam Goldman","key":null,"page":null}],"frontMatter":{"title":"New Implementation of Unions and Intersections","short-title":"New Unions and Intersections","author":"Sam Goldman","hide_table_of_contents":true},"unlisted":false,"prevItem":{"title":"Windows Support is Here!","permalink":"/blog/2016/08/01/Windows-Support"},"nextItem":{"title":"Version 0.21.0","permalink":"/blog/2016/02/02/Version-0.21.0"}},"content":"### Summary\\n\\nBefore Flow 0.28, the implementation of union/intersection types had serious\\nbugs and was [the][gh1759] [root][gh1664] [cause][gh1663] [of][gh1462]\\n[a][gh1455] [lot][gh1371] [of][gh1349] [weird][gh842] [behaviors][gh815] you\\nmay have run into with Flow in the past. These bugs have now been addressed in\\n[a diff landing in 0.28][fotu].\\n\\n\x3c!--truncate--\x3e\\n\\nAs you might expect after a major rewrite of a tricky part of the type system\\nimplementation, there will be a short period of adjustment: you may run into\\nkinks that we will try to iron out promptly, and you may run into some\\nunfamiliar error messages.\\n\\n### New Error Messages\\n\\n```\\n<error location> Could not decide which case to select\\n<location of union/intersection type>\\n\\n  Case 1 may work:\\n  <location of 1st case of union/intersection type>\\n\\n  But if it doesn\'t, case 2 looks promising too:\\n  <location of 2nd case of union/intersection type>\\n\\n  Please provide additional annotation(s) to determine whether case 1 works\\n  (or consider merging it with case 2):\\n  <location to annotate>\\n  <location to annotate>\\n  ...\\n```\\n\\nWhat this means is that at `<error location>`, Flow needs to make a choice: one\\nof the members of the union/intersection type at\\n`<location of union/intersection type>` must be applied, but Flow can\'t choose\\nsafely based on available information. In particular, it cannot decide between\\ncase `1` and `2`, so Flow lists a bunch of annotations that can help it\\ndisambiguate the two cases.\\n\\n### Actions Needed\\n\\nYou can fix the errors in two ways:\\n\\n- Actually go and annotate the listed locations. This should be by far the most\\n  common fix.\\n- Discover that there is real, unintentional ambiguity between case 1 and 2,\\n  and rewrite the two cases in the union type to remove the ambiguity. When\\n  this happens, typically it will fix a large number of errors.\\n\\nThere are two more possibilities, however:\\n\\n- There\'s no real ambiguity and Flow is being too conservative / dumb. In this\\n  case, go ahead and do the annotations anyway and file an issue on GitHub. We\\n  plan to do a lot of short-term follow-up work to disambiguate more cases\\n  automatically, so over time you should see less of (3).\\n- You have no idea what\'s going on. The cases being pointed to don\'t make sense.\\n  They don\'t correspond to what you have at `<error location>`. Hopefully you\\n  won\'t run into (4) too often, but if you do **please file an issue**, since\\n  this means there are still latent bugs in the implementation.\\n\\nIf you file an issue on GitHub, please include code to reproduce the issue. You\\ncan use [Try Flow](https://flowtype.org/try/) to share your repro case easily.\\n\\nIf you\'re curious about the whys and hows of these new error messages, here\'s\\nan excerpt from the commit message of the \\"fate of the union\\" diff:\\n\\n### Problem\\n\\nFlow\'s inference engine is designed to find more errors over time as\\nconstraints are added...but it is not designed to backtrack. Unfortunately,\\nchecking the type of an expression against a union type does need backtracking:\\nif some branch of the union doesn\'t work out, the next branch must be tried,\\nand so on. (The same is true for checks that involve intersection types.)\\n\\nThe situation is further complicated by the fact that the type of the\\nexpression may not be completely known at the point of checking, so that a\\nbranch that looks promising now might turn out to be incorrect later.\\n\\n### Solution\\n\\nThe basic idea is to delay trying a branch until a point where we can decide\\nwhether the branch will definitely fail or succeed, without further\\ninformation. If trying a branch results in failure, we can move on to the next\\nbranch without needing to backtrack. If a branch succeeds, we are done. The\\nfinal case is where the branch looks promising, but we cannot be sure without\\nadding constraints: in this case we try other branches, and *bail* when we run\\ninto ambiguities...requesting additional annotations to decide which branch to\\nselect. Overall, this means that (1) we never commit to a branch that might\\nturn out to be incorrect and (2) can always select a correct branch (if such\\nexists) given enough annotations.\\n\\n[gh1759]: https://github.com/facebook/flow/issues/1759\\n[gh1664]: https://github.com/facebook/flow/issues/1664\\n[gh1663]: https://github.com/facebook/flow/issues/1663\\n[gh1462]: https://github.com/facebook/flow/issues/1462\\n[gh1455]: https://github.com/facebook/flow/issues/1455\\n[gh1371]: https://github.com/facebook/flow/issues/1371\\n[gh1349]: https://github.com/facebook/flow/issues/1349\\n[gh842]: https://github.com/facebook/flow/issues/824\\n[gh815]: https://github.com/facebook/flow/issues/815\\n[fotu]: https://github.com/facebook/flow/commit/2df7671e7bda770b95e6b1eaede96d7a8ab1f2ac"},{"id":"/2016/02/02/Version-0.21.0","metadata":{"permalink":"/blog/2016/02/02/Version-0.21.0","source":"@site/blog/2016-02-02-Version-0.21.0.md","title":"Version 0.21.0","description":"Yesterday we deployed Flow v0.21.0! As always, we\'ve listed out the most","date":"2016-02-02T00:00:00.000Z","tags":[],"hasTruncateMarker":true,"authors":[{"name":"Gabe Levi","key":null,"page":null}],"frontMatter":{"title":"Version 0.21.0","short-title":"Version 0.21.0","author":"Gabe Levi","hide_table_of_contents":true},"unlisted":false,"prevItem":{"title":"New Implementation of Unions and Intersections","permalink":"/blog/2016/07/01/New-Unions-Intersections"},"nextItem":{"title":"Version-0.19.0","permalink":"/blog/2015/12/01/Version-0.19.0"}},"content":"Yesterday we deployed Flow v0.21.0! As always, we\'ve listed out the most\\ninteresting changes in the\\n[Changelog](https://github.com/facebook/flow/blob/master/Changelog.md#v0210).\\nHowever, since I\'m on a plane and can\'t sleep, I thought it might be fun to\\ndive into a couple of the changes! Hope this blog post turns out interesting\\nand legible!\\n\\n### JSX Intrinsics\\n\\nIf you\'re writing JSX, it\'s probably a mix of your own React Components and\\nsome intrinsics. For example, you might write\\n\\n```js\\nrender() {\\n  return <div><FluffyBunny name=\\"Fifi\\" /></div>;\\n}\\n```\\n\\nIn this example, `FluffyBunny` is a React Component you wrote and `div` is a\\nJSX intrinsic. Lower-cased JSX elements are assumed to be intrinsics by React\\nand by Flow. Up until Flow v0.21.0, Flow ignored intrinsics and gave them the\\ntype `any`. This meant Flow let you set any property on JSX intrinsics. Flow\\nv0.21.0 will, by default, do the same thing as v0.20.0, However now you can\\nalso configure Flow to properly type your JSX intrinsics!\\n\\n\x3c!--truncate--\x3e\\n\\n#### Example of how to use JSX intrinsics\\n\\n.flowconfig\\n\\n```js\\n[libs]\\nmyLib.js\\n```\\n\\nmyLib.js\\n\\n```js\\n// JSXHelper is a type alias to make this example more concise.\\n// There\'s nothing special or magic here.\\n// JSXHelper<{name: string}> is a React component\\n// with the single string property \\"name\\", which has a default\\ntype JSXHelper<T> = Class<ReactComponent<T,T,mixed>>;\\n\\n// $JSXIntrinsics is special and magic.\\n// This declares the types for `div` and `span`\\ntype $JSXIntrinsics = {\\n  div: JSXHelper<{id: string}>,\\n  span: JSXHelper<{id: string, class: string}>,\\n};\\n```\\n\\nmyCode.js\\n\\n```js\\n<div id=\\"asdf\\" />; // No error\\n<div id={42} />; // Error: `id` prop is a string, not a number!\\n```\\n\\n#### What is going on here?\\n\\nThe new bit of magic is this `$JSXIntrinsics` type alias. When Flow sees\\n`<foo />` it will look to see if `$JSXIntrinsics` exists and if so will grab\\nthe type of `$JSXIntrinsics[\'foo\']`. It will use this type to figure out which\\nproperties are available and need to be set.\\n\\nWe haven\'t hardcoded the intrinsics into Flow since the available intrinsics\\nwill depend on your environment. For example, React native would have different\\nintrinsics than React for the web would.\\n\\n### Smarter string refinements\\n\\nOne of the main ways that we make Flow smarter is by teaching it to recognize\\nmore ways that JavaScript programmers refine types. Here\'s an example of a\\ncommon way to refine nullable values:\\n\\n```js\\nclass Person {\\n  name: ?string;\\n  ...\\n  getName(): string {\\n    // Before the if, this.name could be null, undefined, or a string\\n    if (this.name != null) {\\n      // But now the programmer has refined this.name to definitely be a string\\n      return this.name;\\n    }\\n    // And now we know that this.name is null or undefined.\\n    return \'You know who\';\\n  }\\n}\\n```\\n\\n#### New string refinements\\n\\nIn v0.21.0, one of the refinements we added is the ability to refine types by\\ncomparing them to strings.\\n\\nThis is useful for refining unions of string literals into string literals\\n\\n```js\\nfunction test(x: \'foo\' | \'bar\'): \'foo\' {\\n  if (x === \'foo\') {\\n    // Now Flow understands that x has the type \'foo\'\\n    return x;\\n  } else {\\n    return \'foo\';\\n  }\\n}\\n```\\n\\nAnd can also narrow the value of strings:\\n\\n```js\\nfunction test(x: string): \'foo\' {\\n  if (x === \'foo\') {\\n    // Now Flow knows x has the type \'foo\'\\n    return x;\\n  } else {\\n    return \'foo\';\\n  }\\n}\\n```\\n\\nThis is one of the many refinements that Flow currently can recognize and\\nfollow, and we\'ll keep adding more! Stay tuned!"},{"id":"/2015/12/01/Version-0.19.0","metadata":{"permalink":"/blog/2015/12/01/Version-0.19.0","source":"@site/blog/2015-12-01-Version-0.19.0.md","title":"Version-0.19.0","description":"Flow v0.19.0 was deployed today! It has a ton of changes, which the","date":"2015-12-01T00:00:00.000Z","tags":[],"hasTruncateMarker":true,"authors":[{"name":"Gabe Levi","key":null,"page":null}],"frontMatter":{"author":"Gabe Levi","hide_table_of_contents":true},"unlisted":false,"prevItem":{"title":"Version 0.21.0","permalink":"/blog/2016/02/02/Version-0.21.0"},"nextItem":{"title":"Typing Generators with Flow","permalink":"/blog/2015/11/09/Generators"}},"content":"Flow v0.19.0 was deployed today! It has a ton of changes, which the\\n[Changelog](https://github.com/facebook/flow/blob/master/Changelog.md#v0190)\\nsummarizes. The Changelog can be a little concise, though, so here are some\\nlonger explanations for some of the changes. Hope this helps!\\n\\n### `@noflow`\\n\\nFlow is opt-in by default (you add `@flow` to a file). However we noticed that\\nsometimes people would add Flow annotations to files that were missing `@flow`.\\nOften, these people didn\'t notice that the file was being ignored by Flow. So\\nwe decided to stop allowing Flow syntax in non-Flow files. This is easily fixed\\nby adding either `@flow` or `@noflow` to your file. The former will make the\\nfile a Flow file. The latter will tell Flow to completely ignore the file.\\n\\n### Declaration files\\n\\nFiles that end with `.flow` are now treated specially. They are the preferred\\nprovider of modules. That is if both `foo.js` and `foo.js.flow` exist, then\\nwhen you write `import Foo from \'./foo\'`, Flow will use the type exported from\\n`foo.js.flow` rather than `foo.js`.\\n\\nWe imagine two main ways people will use `.flow` files.\\n\\n\x3c!--truncate--\x3e\\n\\n1. As interface files. Maybe you have some library `coolLibrary.js` that is\\n  really hard to type with inline Flow types. You could put\\n  `coolLibrary.js.flow` next to it and declare the types that `coolLibrary.js`\\n  exports.\\n\\n  ```js\\n// coolLibrary.js.flow\\ndeclare export var coolVar: number;\\ndeclare export function coolFunction(): void;\\ndeclare export class coolClass {}\\n  ```\\n\\n2. As the original source. Maybe you want to ship the minified, transformed\\n  version of `awesomeLibrary.js`, but people who use `awesomeLibrary.js` also\\n  use Flow. Well you could do something like\\n\\n  ```bash\\ncp awesomeLibraryOriginalCode.js awesomeLibrary.js.flow\\nbabel awesomeLibraryOriginalCode --out-file awesomeLibrary.js\\n  ```\\n\\n### Order of precedence for lib files\\n\\nNow your local lib files will override the builtin lib files. Is one of the\\nbuiltin flow libs wrong? Send a pull request! But then while you\'re waiting for\\nthe next release, you can use your own definition! The order of precedence is\\nas follows:\\n\\n1. Any paths supplied on the command line via --lib\\n2. The files found in the paths specified in the .flowconfig `[libs]` (in\\n  listing order)\\n3. The Flow core library files\\n\\nFor example, if I want to override the builtin definition of Array and instead\\nuse my own version, I could update my `.flowconfig` to contain\\n\\n```\\n// .flowconfig\\n[libs]\\nmyArray.js\\n```\\n\\n```js\\n// myArray.js\\ndeclare class Array<T> {\\n  // Put whatever you like in here!\\n}\\n```\\n\\n### Deferred initialization\\n\\nPreviously the following code was an error, because the initialization of\\n`myString` happens later. Now Flow is fine with it.\\n\\n```js\\nfunction foo(someFlag: boolean): string {\\n  var myString:string;\\n  if (someFlag) {\\n    myString = \\"yup\\";\\n  } else {\\n    myString = \\"nope\\";\\n  }\\n  return myString;\\n}\\n```"},{"id":"/2015/11/09/Generators","metadata":{"permalink":"/blog/2015/11/09/Generators","source":"@site/blog/2015-11-09-Generators.md","title":"Typing Generators with Flow","description":"Flow 0.14.0 included support for generator functions. Generator functions provide a unique ability to JavaScript programs: the ability to suspend and resume execution. This kind of control paves the way for async/await, an upcoming feature already supported by Flow.","date":"2015-11-09T00:00:00.000Z","tags":[],"hasTruncateMarker":true,"authors":[{"name":"Sam Goldman","key":null,"page":null}],"frontMatter":{"title":"Typing Generators with Flow","short-title":"Generators","author":"Sam Goldman","hide_table_of_contents":true},"unlisted":false,"prevItem":{"title":"Version-0.19.0","permalink":"/blog/2015/12/01/Version-0.19.0"},"nextItem":{"title":"Version-0.17.0","permalink":"/blog/2015/10/07/Version-0.17.0"}},"content":"Flow 0.14.0 included support for generator functions. Generator functions provide a unique ability to JavaScript programs: the ability to suspend and resume execution. This kind of control paves the way for async/await, an [upcoming feature](https://github.com/tc39/ecmascript-asyncawait) already supported by Flow.\\n\\n\x3c!--truncate--\x3e\\n\\nSo much wonderful material has already been produced describing generators. I am going to focus on the interaction of static typing with generators. Please refer to the following materials for information about generators:\\n\\n* Jafar Husain gave an [incredibly lucid and well-illustrated talk](https://www.youtube.com/watch?v=DqMFX91ToLw#t=970) that covers generators. I have linked to the point where he gets into generators, but I highly recommend the entire talk.\\n* Exploring ES6, a comprehensive book by Axel Rauschmayer, who has generously made the contents available for free online, has a [chapter on generators](http://exploringjs.com/es6/ch_generators.html).\\n* The venerable MDN has a [useful page](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators) describing the `Iterator` interface and generators.\\n\\nIn Flow, the `Generator` interface has three type parameters: `Yield`, `Return`, and `Next`. `Yield` is the type of values which are yielded from the generator function. `Return` is the type of the value which is returned from the generator function. `Next` is the type of values which are passed into the generator via the `next` method on the `Generator` itself. For example, a generator value of type `Generator<string,number,boolean>` will yield `string`s, return a `number`, and will receive `boolean`s from its caller.\\n\\nFor any type `T`, a `Generator<T,void,void>` is both an `Iterable<T>` and an `Iterator<T>`.\\n\\nThe unique nature of generators allows us to represent infinite sequences naturally. Consider the infinite sequence of natural numbers:\\n\\n```javascript\\nfunction *nats() {\\n  let i = 0;\\n  while (true) {\\n    yield i++;\\n  }\\n}\\n```\\n\\nBecause generators are also iterators, we can manually iterate the generator:\\n\\n```javascript\\nconst gen = nats();\\nconsole.log(gen.next()); // { done: false, value: 0 }\\nconsole.log(gen.next()); // { done: false, value: 1 }\\nconsole.log(gen.next()); // { done: false, value: 2 }\\n```\\n\\nWhen `done` is false, `value` will have the generator\'s `Yield` type. When `done` is true, `value` will have the generator\'s `Return` type or `void` if the consumer iterates past the completion value.\\n\\n```javascript\\nfunction *test() {\\n  yield 1;\\n  return \\"complete\\";\\n}\\nconst gen = test();\\nconsole.log(gen.next()); // { done: false, value: 1 }\\nconsole.log(gen.next()); // { done: true, value: \\"complete\\" }\\nconsole.log(gen.next()); // { done: true, value: undefined }\\n```\\n\\nBecause of this behavior, manually iterating poses typing difficulties. Let\'s try to take the first 10 values from the `nats` generator through manual iteration:\\n\\n```javascript\\nconst gen = nats();\\nconst take10: number[] = [];\\nfor (let i = 0; i < 10; i++) {\\n  const { done, value } = gen.next();\\n  if (done) {\\n    break;\\n  } else {\\n    take10.push(value); // error!\\n  }\\n}\\n```\\n\\n```\\ntest.js:13\\n 13:   const { done, value } = gen.next();\\n                               ^^^^^^^^^^ call of method `next`\\n 17:     take10.push(value); // error!\\n                     ^^^^^ undefined. This type is incompatible with\\n 11: const take10: number[] = [];\\n                   ^^^^^^ number\\n```\\n\\nFlow is complaining that `value` might be `undefined`. This is because the type of `value` is `Yield | Return | void`, which simplifies in the instance of `nats` to `number | void`. We can introduce a dynamic type test to convince Flow of the invariant that `value` will always be `number` when `done` is false.\\n\\n```javascript\\nconst gen = nats();\\nconst take10: number[] = [];\\nfor (let i = 0; i < 10; i++) {\\n  const { done, value } = gen.next();\\n  if (done) {\\n    break;\\n  } else {\\n    if (typeof value === \\"undefined\\") {\\n      throw new Error(\\"`value` must be a number.\\");\\n    }\\n    take10.push(value); // no error\\n  }\\n}\\n```\\n\\nThere is an [open issue](https://github.com/facebook/flow/issues/577) which would make the dynamic type test above unnecessary, by using the `done` value as a sentinel to refine a tagged union. That is, when `done` is `true`, Flow would know that `value` is always of type `Yield` and otherwise of type `Return | void`.\\n\\nEven without the dynamic type test, this code is quite verbose and it\'s hard to see the intent. Because generators are also iterable, we can also use `for...of` loops:\\n\\n```javascript\\nconst take10: number[] = [];\\nlet i = 0;\\nfor (let nat of nats()) {\\n  if (i === 10) break;\\n  take10.push(nat);\\n  i++;\\n}\\n```\\n\\nThat\'s much better. The `for...of` looping construct ignores completion values, so Flow understands that `nat` will always be `number`. Let\'s generalize this pattern further using generator functions:\\n\\n```javascript\\nfunction *take<T>(n: number, xs: Iterable<T>): Iterable<T> {\\n  if (n <= 0) return;\\n  let i = 0;\\n  for (let x of xs) {\\n    yield x;\\n    if (++i === n) return;\\n  }\\n}\\n\\nfor (let n of take(10, nats())) {\\n  console.log(n); // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\\n}\\n```\\n\\nNote that we explicitly annotated the parameters and return type of the `take` generator. This is necessary to ensure Flow understands the fully generic type. This is because Flow does not currently infer a fully generic type, but instead accumulates lower bounds, resulting in a union type.\\n\\n```javascript\\nfunction identity(x) { return x }\\nvar a: string = identity(\\"\\"); // error\\nvar b: number = identity(0);  // error\\n```\\n\\nThe above code produces errors because Flow adds `string` and `number` as lower bounds to the type variable describing the type of the value bound by `x`. That is, Flow believes the type of `identity` is `(x: string | number) => string | number` because those are the types which actually passed through the function.\\n\\nAnother important feature of generators is the ability to pass values into the generator from the consumer. Let\'s consider a generator `scan`, which reduces values passed into the generator using a provided function. Our `scan` is similar to `Array.prototype.reduce`, but it returns each intermediate value and the values are provided imperatively via `next`.\\n\\nAs a first pass, we might write this:\\n\\n```javascript\\nfunction *scan<T,U>(init: U, f: (acc: U, x: T) => U): Generator<U,void,T> {\\n  let acc = init;\\n  while (true) {\\n    const next = yield acc;\\n    acc = f(acc, next);\\n  }\\n}\\n```\\n\\nWe can use this definition to implement an imperative sum procedure:\\n\\n```javascript\\nlet sum = scan(0, (a,b) => a + b);\\nconsole.log(sum.next());  // { done: false, value: 0 }\\nconsole.log(sum.next(1)); // { done: false, value: 1 }\\nconsole.log(sum.next(2)); // { done: false, value: 3 }\\nconsole.log(sum.next(3)); // { done: false, value: 6 }\\n```\\n\\nHowever, when we try to check the above definition of `scan`, Flow complains:\\n\\n```\\ntest.js:7\\n  7:     acc = f(acc, next);\\n               ^^^^^^^^^^^^ function call\\n  7:     acc = f(acc, next);\\n                      ^^^^ undefined. This type is incompatible with\\n  3: function *scan<T,U>(init: U, f: (acc: U, x: T) => U): Generator<U,void,T> {\\n     ^ some incompatible instantiation of T\\n```\\n\\nFlow is complaining that our value, `next`, may be `void` instead of the expected `T`, which is `number` in the `sum` example. This behavior is necessary to ensure type safety. In order to prime the generator, our consumer must first call `next` without an argument. To accommodate this, Flow understands the argument to `next` to be optional. This means Flow will allow the following code:\\n\\n```javascript\\nlet sum = scan(0, (a,b) => a + b);\\nconsole.log(sum.next());  // first call primes the generator\\nconsole.log(sum.next());  // we should pass a value, but don\'t need to\\n```\\n\\nIn general, Flow doesn\'t know which invocation is \\"first.\\" While it should be an error to pass a value to the first `next`, and an error to *not* pass a value to subsequent `next`s, Flow compromises and forces your generator to deal with a potentially `void` value. In short, given a generator of type `Generator<Y,R,N>` and a value `x` of type `Y`, the type of the expression `yield x` is `N | void`.\\n\\nWe can update our definition to use a dynamic type test that enforces the non-`void` invariant at runtime:\\n\\n```javascript\\nfunction *scan<T,U>(init: U, f: (acc: U, x: T) => U): Generator<U,void,T> {\\n  let acc = init;\\n  while (true) {\\n    const next = yield acc;\\n    if (typeof next === \\"undefined\\") {\\n      throw new Error(\\"Caller must provide an argument to `next`.\\");\\n    }\\n    acc = f(acc, next);\\n  }\\n}\\n```\\n\\nThere is one more important caveat when dealing with typed generators. Every value yielded from the generator must be described by a single type. Similarly, every value passed to the generator via `next` must be described by a single type.\\n\\nConsider the following generator:\\n\\n```javascript\\nfunction *foo() {\\n  yield 0;\\n  yield \\"\\";\\n}\\n\\nconst gen = foo();\\nconst a: number = gen.next().value; // error\\nconst b: string = gen.next().value; // error\\n```\\n\\nThis is perfectly legal JavaScript and the values `a` and `b` do have the correct types at runtime. However, Flow rejects this program. Our generator\'s `Yield` type parameter has a concrete type of `number | string`. The `value` property of the iterator result object has the type `number | string | void`.\\n\\nWe can observe similar behavior for values passed into the generator:\\n\\n```\\nfunction *bar() {\\n  var a = yield;\\n  var b = yield;\\n  return {a,b};\\n}\\n\\nconst gen = bar();\\ngen.next(); // prime the generator\\ngen.next(0);\\nconst ret: { a: number, b: string } = gen.next(\\"\\").value; // error\\n```\\n\\nThe value `ret` has the annotated type at runtime, but Flow also rejects this program. Our generator\'s `Next` type parameter has a concrete type of `number | string`. The `value` property of the iterator result object thus has the type `void | { a: void | number | string, b: void | number | string }`.\\n\\nWhile it may be possible to use dynamic type tests to resolve these issues, another practical option is to use `any` to take on the type safety responsibility yourself.\\n\\n```javascript\\nfunction *bar(): Generator {\\n  var a = yield;\\n  var b = yield;\\n  return {a,b};\\n}\\n\\nconst gen = bar();\\ngen.next(); // prime the generator\\ngen.next(0);\\nconst ret: void | { a: number, b: string } = gen.next(\\"\\").value; // OK\\n```\\n\\n(Note that the annotation `Generator` is equivalent to `Generator<any,any,any>`.)\\n\\nPhew! I hope that this will help you use generators in your own code. I also hope this gave you a little insight into the difficulties of applying static analysis to a highly dynamic language such as JavaScript.\\n\\nTo summarize, here are some of the lessons we\'ve learned for using generators in statically typed JS:\\n\\n* Use generators to implement custom iterables.\\n* Use dynamic type tests to unpack the optional return type of yield expressions.\\n* Avoid generators that yield or receive values of multiple types, or use `any`."},{"id":"/2015/10/07/Version-0.17.0","metadata":{"permalink":"/blog/2015/10/07/Version-0.17.0","source":"@site/blog/2015-10-07-Version-0.17.0.md","title":"Version-0.17.0","description":"Today we released Flow v0.17.0! The first thing you may notice is that we changed the way we display errors at the command line. The new errors look like this:","date":"2015-10-07T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Gabe Levi","key":null,"page":null}],"frontMatter":{"author":"Gabe Levi","hide_table_of_contents":true},"unlisted":false,"prevItem":{"title":"Typing Generators with Flow","permalink":"/blog/2015/11/09/Generators"},"nextItem":{"title":"Version-0.16.0","permalink":"/blog/2015/09/22/Version-0.16.0"}},"content":"Today we released Flow v0.17.0! The first thing you may notice is that we changed the way we display errors at the command line. The new errors look like this:\\n\\nThis should hopefully help our command line users understand many errors without having to refer to their source code. We\'ll keep iterating on this format, so tell us what you like and what you don\'t like! Thanks to [@frantic](https://github.com/frantic) for building this feature!\\n\\nThere are a whole bunch of other features and fixes in this release! Head on over to our [Release](https://github.com/facebook/flow/releases/tag/v0.17.0) for the full list!"},{"id":"/2015/09/22/Version-0.16.0","metadata":{"permalink":"/blog/2015/09/22/Version-0.16.0","source":"@site/blog/2015-09-22-Version-0.16.0.md","title":"Version-0.16.0","description":"On Friday we released Flow v0.16.0! We had some major perf improvements that we wanted to get into a release, plus let/const support was ready (thanks again @samwgoldman)!","date":"2015-09-22T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Jeff Morrison","key":null,"page":null}],"frontMatter":{"author":"Jeff Morrison","hide_table_of_contents":true},"unlisted":false,"prevItem":{"title":"Version-0.17.0","permalink":"/blog/2015/10/07/Version-0.17.0"},"nextItem":{"title":"Version-0.15.0","permalink":"/blog/2015/09/10/Version-0.15.0"}},"content":"On Friday we released Flow v0.16.0! We had some major perf improvements that we wanted to get into a release, plus let/const support was ready (thanks again [@samwgoldman](https://github.com/samwgoldman))!\\n\\nAs always, the [Changelog](https://github.com/facebook/flow/blob/master/Changelog.md#v0160) is best at summing up the big changes."},{"id":"/2015/09/10/Version-0.15.0","metadata":{"permalink":"/blog/2015/09/10/Version-0.15.0","source":"@site/blog/2015-09-10-Version-0.15.0.md","title":"Version-0.15.0","description":"Today we released Flow v0.15.0! A lot has changed in the last month and we\'re excited to get the hard work of all our contributors in front of people! Big thanks to everyone who contributed to this release!","date":"2015-09-10T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Gabe Levi","key":null,"page":null}],"frontMatter":{"author":"Gabe Levi","hide_table_of_contents":true},"unlisted":false,"prevItem":{"title":"Version-0.16.0","permalink":"/blog/2015/09/22/Version-0.16.0"},"nextItem":{"title":"Version-0.14.0","permalink":"/blog/2015/07/29/Version-0.14.0"}},"content":"Today we released Flow v0.15.0! A lot has changed in the last month and we\'re excited to get the hard work of all our contributors in front of people! Big thanks to everyone who contributed to this release!\\n\\nCheck out the [Changelog](https://github.com/facebook/flow/blob/master/Changelog.md#v0150) to see what\'s new."},{"id":"/2015/07/29/Version-0.14.0","metadata":{"permalink":"/blog/2015/07/29/Version-0.14.0","source":"@site/blog/2015-07-29-Version-0.14.0.md","title":"Version-0.14.0","description":"It has come to our attention that not everyone obsessively checks GitHub for Flow releases. This came as a surprise, but we would like to support these users too. Therefore, we will start announcing each Flow release on the blog, starting with this release.","date":"2015-07-29T00:00:00.000Z","tags":[],"hasTruncateMarker":false,"authors":[{"name":"Gabe Levi","key":null,"page":null}],"frontMatter":{"author":"Gabe Levi","hide_table_of_contents":true},"unlisted":false,"prevItem":{"title":"Version-0.15.0","permalink":"/blog/2015/09/10/Version-0.15.0"},"nextItem":{"title":"Announcing Disjoint Unions","permalink":"/blog/2015/07/03/Disjoint-Unions"}},"content":"It has come to our attention that not everyone obsessively checks GitHub for Flow releases. This came as a surprise, but we would like to support these users too. Therefore, we will start announcing each Flow release on the blog, starting with this release.\\n\\nSo here is Flow v0.14.0! Check out the [Changelog](https://github.com/facebook/flow/blob/master/Changelog.md#v0140) for the canonical list of what has changed."},{"id":"/2015/07/03/Disjoint-Unions","metadata":{"permalink":"/blog/2015/07/03/Disjoint-Unions","source":"@site/blog/2015-07-03-Disjoint-Unions.md","title":"Announcing Disjoint Unions","description":"Sometimes programs need to deal with different kinds of data all at once, where the shape of the data can be different based on what kind of data the code is looking at. This kind of programming is so common in functional programming languages that almost all such languages come with a way of:","date":"2015-07-03T00:00:00.000Z","tags":[],"hasTruncateMarker":true,"authors":[{"name":"Avik Chaudhuri","key":null,"page":null}],"frontMatter":{"title":"Announcing Disjoint Unions","short-title":"Disjoint Unions","author":"Avik Chaudhuri","hide_table_of_contents":true},"unlisted":false,"prevItem":{"title":"Version-0.14.0","permalink":"/blog/2015/07/29/Version-0.14.0"},"nextItem":{"title":"Announcing Bounded Polymorphism","permalink":"/blog/2015/03/12/Bounded-Polymorphism"}},"content":"Sometimes programs need to deal with different kinds of data all at once, where the shape of the data can be different based on what kind of data the code is looking at. This kind of programming is so common in functional programming languages that almost all such languages come with a way of:\\n\\n* Specifying such data by a set of disjoint cases, distinguished by \u201ctags\u201d, where each tag is associated with a different \u201crecord\u201d of properties. (These descriptions are called \u201cdisjoint union\u201d or \u201cvariant\u201d types.)\\n* Doing case analysis on such data, by checking tags and then directly accessing the associated record of properties. (The common way to do such case analysis is by pattern matching.)\\n\\nExamples of programs that analyze or transform such data range from compilers working with abstract syntax trees, to operations that may return exceptional values,  with much more in between!\\n\\nAs of Flow 0.13.1 it is now possible to program in this style in JavaScript in a type-safe manner. You can define a disjoint union of object types and do case analysis on objects of that type by switching on the value of some common property (called a \\"sentinel\\") in those object types.\\n\\nFlow\'s syntax for disjoint unions looks like:\\n\\n```javascript\\ntype BinaryTree =\\n  { kind: \\"leaf\\", value: number } |\\n  { kind: \\"branch\\", left: BinaryTree, right: BinaryTree }\\n\\nfunction sumLeaves(tree: BinaryTree): number {\\n  if (tree.kind === \\"leaf\\") {\\n    return tree.value;\\n  } else {\\n    return sumLeaves(tree.left) + sumLeaves(tree.right);\\n  }\\n}\\n```\\n\\n\x3c!--truncate--\x3e\\n\\n## The problem\\n\\nConsider the following function that returns different objects depending on the data passed into it:\\n\\n```javascript\\ntype Result = { status: string, errorCode?: number }\\n\\nfunction getResult(op): Result {\\n  var statusCode = op();\\n  if (statusCode === 0) {\\n    return { status: \'done\' };\\n  } else {\\n    return { status: \'error\', errorCode: statusCode };\\n  }\\n}\\n```\\n\\nThe result contains a `status` property that is either `\'done\'` or `\'error\'`,\\nand an optional `errorCode` property that holds a numeric status code when the\\n`status` is `\'error\'`.\\n\\nOne may now try to write another function that gets the error code from a result:\\n\\n```javascript\\nfunction getErrorCode(result: Result): number {\\n  switch (result.status) {\\n    case \'error\':\\n      return result.errorCode;\\n    default:\\n      return 0;\\n  }\\n}\\n```\\n\\nUnfortunately, this code does not typecheck. The `Result` type does not precisely\\ncapture the relationship between the `status` property and the `errorCode` property.\\nNamely it doesn\'t capture that when the `status` property is `\'error\'`, the `errorCode`\\nproperty will be present and defined on the object. As a result, Flow thinks that\\n`result.errorCode` in the above function may return `undefined` instead of `number`.\\n\\nPrior to version 0.13.1 there was no way to express this relationship, which meant\\nthat it was not possible to check the type safety of this simple, familiar idiom!\\n\\n## The solution\\n\\nAs of version 0.13.1 it is possible to write a more precise type for `Result`\\nthat better captures the intent and helps Flow narrow down the possible shapes\\nof an object based on the outcome of a dynamic `===` check. Now, we can write:\\n\\n```javaScript\\ntype Result = Done | Error\\ntype Done = { status: \'done\' }\\ntype Error = { status: \'error\', errorCode: number }\\n```\\n\\nIn other words, we can explicitly list out the possible shapes of results. These\\ncases are distinguished by the value of the `status` property. Note that here\\nwe use the string literal types `\'done\'` and `\'error\'`. These match exactly the strings\\n`\'done\'` and `\'error\'`, which means that `===` checks on those values are enough for\\nFlow to narrow down the corresponding type cases. With this additional reasoning, the\\nfunction `getErrorCode` now typechecks, without needing any changes to the code!\\n\\nIn addition to string literals, Flow also supports number literals as singleton types\\nso they can also be used in disjoint unions and case analyses.\\n\\n## Why we built this\\n\\nDisjoint unions are at the heart of several good programming practices pervasive in functional programming languages. Supporting them in Flow means that JavaScript can use these practices in a type-safe manner. For example, disjoint unions can be used to write type-safe [Flux dispatchers](https://facebook.github.io/flux/docs/dispatcher.html). They are also heavily used in a recently released [reference implementation of GraphQL](https://github.com/graphql/graphql-js)."},{"id":"/2015/03/12/Bounded-Polymorphism","metadata":{"permalink":"/blog/2015/03/12/Bounded-Polymorphism","source":"@site/blog/2015-03-12-Bounded-Polymorphism.md","title":"Announcing Bounded Polymorphism","description":"As of Flow 0.5.0, you can define polymorphic functions and classes with bounds on their type parameters. This is extremely useful for writing functions and classes that need some constraints on their type parameters. Flow\'s bounded polymorphism syntax looks like","date":"2015-03-12T00:00:00.000Z","tags":[],"hasTruncateMarker":true,"authors":[{"name":"Avik Chaudhuri","key":null,"page":null}],"frontMatter":{"title":"Announcing Bounded Polymorphism","short-title":"Bounded Polymorphism","author":"Avik Chaudhuri","hide_table_of_contents":true},"unlisted":false,"prevItem":{"title":"Announcing Disjoint Unions","permalink":"/blog/2015/07/03/Disjoint-Unions"},"nextItem":{"title":"Announcing Flow Comments","permalink":"/blog/2015/02/20/Flow-Comments"}},"content":"As of Flow 0.5.0, you can define polymorphic functions and classes with bounds on their type parameters. This is extremely useful for writing functions and classes that need some constraints on their type parameters. Flow\'s bounded polymorphism syntax looks like\\n\\n```JavaScript\\nclass BagOfBones<T: Bone> { ... }\\nfunction eat<T: Food>(meal: T): Indigestion<T> { ... }\\n```\\n\\n## The problem\\n\\nConsider the following code that defines a polymorphic function in Flow:\\n\\n```JavaScript\\nfunction fooBad<T>(obj: T): T {\\n  console.log(Math.abs(obj.x));\\n  return obj;\\n}\\n```\\n\\nThis code does not (and should not!) type check. Not all values `obj: T` have a property `x`, let alone a property `x` that is a `number`, given the additional requirement imposed by `Math.abs()`.\\n\\n\x3c!--truncate--\x3e\\n\\nBut what if you wanted `T` to not range over all types, but instead over only the types of objects with an `x` property that has the type `number`? Intuitively, given that condition, the body should type check. Unfortunately, the only way you could enforce this condition prior to Flow 0.5.0 was by giving up on polymorphism entirely! For example you could write:\\n\\n```JavaScript\\n// Old lame workaround\\nfunction fooStillBad(obj: { x: number }): {x: number } {\\n  console.log(Math.abs(obj.x));\\n  return obj;\\n}\\n```\\n\\nBut while this change would make the body type check, it would cause Flow to lose information across call sites. For example:\\n\\n```JavaScript\\n// The return type of fooStillBad() is {x: number}\\n// so Flow thinks result has the type {x: number}\\nvar result = fooStillBad({x: 42, y: \\"oops\\"});\\n\\n// This will be an error since result\'s type\\n// doesn\'t have a property \\"y\\"\\nvar test: {x: number; y: string} = result;\\n```\\n\\n## The solution\\n\\nAs of version 0.5.0, such typing problems can be solved elegantly using bounded polymorphism. Type parameters such as `T` can specify bounds that constrain the types that the type parameters range over. For example, we can write:\\n\\n```JavaScript\\nfunction fooGood<T: { x: number }>(obj: T): T {\\n  console.log(Math.abs(obj.x));\\n  return obj;\\n}\\n```\\n\\nNow the body type checks under the assumption that `T` is a subtype of `{ x: number }`. Furthermore, no information is lost across call sites. Using the example from above:\\n\\n```JavaScript\\n// With bounded polymorphism, Flow knows the return\\n// type is {x: number; y: string}\\nvar result = fooGood({x: 42, y: \\"yay\\"});\\n\\n// This works!\\nvar test: {x: number; y: string} = result;\\n```\\n\\nOf course, polymorphic classes may also specify bounds. For example, the following code type checks:\\n\\n```JavaScript\\nclass Store<T: { x: number }> {\\n  obj: T;\\n  constructor(obj: T) { this.obj = obj; }\\n  foo() { console.log(Math.abs(this.obj.x)); }\\n}\\n```\\n\\nInstantiations of the class are appropriately constrained. If you write\\n\\n```JavaScript\\nvar store = new Store({x: 42, y: \\"hi\\"});\\n```\\n\\nThen `store.obj` has type `{x: number; y: string}`.\\n\\nAny type may be used as a type parameter\'s bound. The type does not need to be an object type (as in the examples above). It may even be another type parameter that is in scope. For example, consider adding the following method to the above `Store` class:\\n\\n```JavaScript\\nclass Store<T: { x: number }> {\\n  ...\\n  bar<U: T>(obj: U): U {\\n    this.obj = obj;\\n    console.log(Math.abs(obj.x));\\n    return obj;\\n  }\\n}\\n```\\n\\nSince `U` is a subtype of `T`, the method body type checks (as you may expect, `U` must also satisfy `T`\'s bound, by transitivity of subtyping). Now the following code type checks:\\n\\n```JavaScript\\n  // store is a Store<{x: number; y: string}>\\n  var store = new Store({x: 42, y: \\"yay\\"});\\n\\n  var result = store.bar({x: 0, y: \\"hello\\", z: \\"world\\"});\\n\\n  // This works!\\n  var test: {x: number; y: string; z: string } = result;\\n```\\n\\nAlso, in a polymorphic definition with multiple type parameters, any type parameter may appear in the bound of any following type parameter. This is useful for type checking examples like the following:\\n\\n```JavaScript\\nfunction copyArray<T, S: T>(from: Array<S>, to: Array<T>) {\\n  from.forEach(elem => to.push(elem));\\n}\\n```\\n\\n## Why we built this\\n\\nThe addition of bounded polymorphism significantly increases the expressiveness of Flow\'s type system, by enabling signatures and definitions to specify relationships between their type parameters, without having to sacrifice the benefits of generics. We expect that the increased expressiveness will be particularly useful to library writers, and will also allow us to write better declarations for framework APIs such as those provided by React.\\n\\n## Transformations\\n\\nLike type annotations and other Flow features, polymorphic function and class definitions need to be transformed before the code can be run. The transforms are available in react-tools `0.13.0`, which was recently released"},{"id":"/2015/02/20/Flow-Comments","metadata":{"permalink":"/blog/2015/02/20/Flow-Comments","source":"@site/blog/2015-02-20-Flow-Comments.md","title":"Announcing Flow Comments","description":"As of Flow 0.4.0, you can put your Flow-specific syntax in special comments. If you use these special comments then you do not need to transform away Flow-specific syntax before running your code. While we strongly recommend that you write your code without the special comments, this feature will help people who can\'t fit a Flow-stripping transformation into their setup. This was one of our most requested features and hopefully it will enable even more people to use Flow!","date":"2015-02-20T00:00:00.000Z","tags":[],"hasTruncateMarker":true,"authors":[{"name":"Gabe Levi","key":null,"page":null}],"frontMatter":{"title":"Announcing Flow Comments","short-title":"Flow Comments","author":"Gabe Levi","hide_table_of_contents":true},"unlisted":false,"prevItem":{"title":"Announcing Bounded Polymorphism","permalink":"/blog/2015/03/12/Bounded-Polymorphism"},"nextItem":{"title":"Announcing Import Type","permalink":"/blog/2015/02/18/Import-Types"}},"content":"As of Flow 0.4.0, you can put your Flow-specific syntax in special comments. If you use these special comments then you do not need to transform away Flow-specific syntax before running your code. While we strongly recommend that you write your code without the special comments, this feature will help people who can\'t fit a Flow-stripping transformation into their setup. This was one of our [most requested features](https://github.com/facebook/flow/issues/3) and hopefully it will enable even more people to use Flow!\\n\\nThis feature introduces 3 special comments: `/*:`, `/*::`, and `/*flow-include`. Flow will read the code inside these special comments and treat the code as if the special comment tokens didn\'t exist. These special comments are valid JavaScript block comments, so your JavaScript engine will ignore the code inside the comments.\\n\\n\x3c!--truncate--\x3e\\n\\n## The Flow Comment Syntax\\n\\nThere are 3 special comments that Flow currently supports. You may recognize this syntax from [Jarno Rantanen](https://github.com/jareware)\'s excellent project, [flotate](https://github.com/jareware/flotate).\\n\\n### 1. `/*:`\\n\\n`/*: <your code> */` is interpreted by Flow as `: <your code>`\\n\\n```JavaScript\\nfunction foo(x/*: number*/)/* : string */ { ... }\\n```\\n\\nis interpreted by Flow as\\n\\n```JavaScript\\nfunction foo(x: number): string { ... }\\n```\\n\\nbut appears to the JavaScript engine (ignoring comments) as\\n\\n```JavaScript\\nfunction foo(x) { ... }\\n```\\n\\n### 2. `/*::`\\n\\n`/*:: <your code> */` is interpreted by Flow as `<your code>`\\n\\n```JavaScript\\n/*:: type foo = number; */\\n```\\n\\nis interpreted by Flow as\\n\\n```JavaScript\\ntype foo = number;\\n```\\n\\nbut appears to the runtime (ignoring comments) as\\n\\n```JavaScript\\n\\n```\\n\\n### 3. `/*flow-include`\\n\\n`/*flow-include <your code> */` is interpreted by Flow as `<your code>`. It behaves the same as `/*::`\\n\\n```JavaScript\\n/*flow-include type foo = number; */\\n```\\n\\nis interpreted by Flow as\\n\\n```JavaScript\\ntype foo = number;\\n```\\n\\nbut appears to the runtime (ignoring comments) as\\n\\n```JavaScript\\n\\n```\\n\\nNote: whitespace is ignored after the `/*` but before the `:`, `::`, or `flow-include`. So you can write things like\\n\\n```JavaScript\\n/* : number */\\n/* :: type foo = number */\\n/* flow-include type foo = number */\\n```\\n\\n## Future Work\\n\\nWe plan to update our Flow transformation to wrap Flow syntax with these special comments, rather than stripping it away completely. This will help people write Flow code but publish code that works with or without Flow.\\n\\n## Thanks\\n\\nSpecial thanks to [Jarno Rantanen](https://github.com/jareware) for building [flotate](https://github.com/jareware/flotate) and supporting us merging his syntax upstream into Flow."},{"id":"/2015/02/18/Import-Types","metadata":{"permalink":"/blog/2015/02/18/Import-Types","source":"@site/blog/2015-02-18-Import-Types.md","title":"Announcing Import Type","description":"As of Flow 0.3.0, it\'s now possible to import types from another module. So, for example, if you\'re only importing a class for purposes of referencing it in a type annotation, you can now use the new import type syntax to do this.","date":"2015-02-18T00:00:00.000Z","tags":[],"hasTruncateMarker":true,"authors":[{"name":"Jeff Morrison","key":null,"page":null}],"frontMatter":{"title":"Announcing Import Type","short-title":"Import Type","author":"Jeff Morrison","hide_table_of_contents":true},"unlisted":false,"prevItem":{"title":"Announcing Flow Comments","permalink":"/blog/2015/02/20/Flow-Comments"},"nextItem":{"title":"Announcing Typecasts","permalink":"/blog/2015/02/18/Typecasts"}},"content":"As of Flow 0.3.0, it\'s now possible to import types from another module. So, for example, if you\'re only importing a class for purposes of referencing it in a type annotation, you can now use the new `import type` syntax to do this.\\n\\n## Motivation\\n\\nHas this ever happened to you:\\n\\n```JavaScript\\n// @flow\\n\\n// Post-transformation lint error: Unused variable \'URI\'\\nimport URI from \\"URI\\";\\n\\n// But if you delete the require you get a Flow error:\\n// identifier URI - Unknown global name\\nmodule.exports = function(x: URI): URI {\\n  return x;\\n}\\n```\\n\\nNow you have an out! To solve this problem (and with an eye toward a near future with ES6 module syntax), we\'ve added the new `import type` syntax.  With `import type`, you can convey what you really mean here \u2014 that you want to import the *type* of the class and not really the class itself.\\n\\n\x3c!--truncate--\x3e\\n\\n## Enter Import Type\\n\\nSo instead of the above code, you can now write this:\\n\\n```JavaScript\\n// @flow\\n\\nimport type URI from \'URI\';\\nmodule.exports = function(x: URI): URI {\\n  return x;\\n};\\n```\\n\\nIf you have a module that exports multiple classes (like, say, a Crayon and a Marker class), you can import the type for each of them together or separately like this:\\n\\n```JavaScript\\n// @flow\\n\\nimport type {Crayon, Marker} from \'WritingUtensils\';\\nmodule.exports = function junkDrawer(x: Crayon, y: Marker): void {}\\n```\\n\\n## Transformations\\n\\nLike type annotations and other Flow features, `import type` need to be transformed away before the code can be run. The transforms will be available in react-tools `0.13.0` when it is published soon, but for now they\'re available in `0.13.0-beta.2`, which you can install with\\n\\n```bash\\nnpm install react-tools@0.13.0-beta.2\\n```\\n\\n## Anticipatory Q&A\\n\\n### Wait, but what happens at runtime after I\'ve added an `import type` declaration?\\n*Nothing! All `import type` declarations get stripped away just like other flow syntax.*\\n\\n### Can I use `import type` to pull in type aliases from another module, too?\\n<del>Not quite yet...but soon! There are a few other moving parts that we need to build first, but we\'re working on it.</del>\\n\\nEDIT: Yes! As of Flow 0.10 you can use the `export type MyType = ... ;` syntax to compliment the `import type` syntax. Here\'s a trivial example:\\n\\n```javascript\\n// @flow\\n\\n// MyTypes.js\\nexport type UserID = number;\\nexport type User = {\\n  id: UserID,\\n  firstName: string,\\n  lastName: string\\n};\\n```\\n\\n```javascript\\n// @flow\\n\\n// User.js\\nimport type {UserID, User} from \\"MyTypes\\";\\n\\nfunction getUserID(user: User): UserID {\\n  return user.id;\\n}\\n```\\n\\nNote that we only support the explicit named-export statements for now (i.e. `export type UserID = number;`). In a future version we can add support for latent named-export statements (i.e. `type UserID = number; export {UserID};`) and default type exports (i.e.  `export default type MyType = ... ;`)...but for now these forms aren\'t yet supported for type exports."},{"id":"/2015/02/18/Typecasts","metadata":{"permalink":"/blog/2015/02/18/Typecasts","source":"@site/blog/2015-02-18-Typecasts.md","title":"Announcing Typecasts","description":"As of version 0.3.0, Flow supports typecast expression.","date":"2015-02-18T00:00:00.000Z","tags":[],"hasTruncateMarker":true,"authors":[{"name":"Basil Hosmer","key":null,"page":null}],"frontMatter":{"title":"Announcing Typecasts","short-title":"Typecasts","author":"Basil Hosmer","hide_table_of_contents":true},"unlisted":false,"prevItem":{"title":"Announcing Import Type","permalink":"/blog/2015/02/18/Import-Types"}},"content":"As of version 0.3.0, Flow supports typecast expression.\\n\\nA typecast expression is a simple way to type-annotate any JavaScript expression. Here are some examples of typecasts:\\n\\n```JavaScript\\n(1 + 1 : number);\\nvar a = { name: (null: ?string) };\\n([1, \'a\', true]: Array<mixed>).map(fn);\\n```\\n\\nFor any JavaScript expression `<expr>` and any Flow type `<type>`, you can write\\n\\n```JavaScript\\n(<expr> : <type>)\\n```\\n\\n**Note:** the parentheses are necessary.\\n\\n\x3c!--truncate--\x3e\\n\\n## How Typecasts Work\\n\\nTo evaluate a typecast expression, Flow will first check that `<expr>` is a `<type>`.\\n\\n```JavaScript\\n(1+1: number); // this is fine\\n(1+1: string); // but this is is an error\\n```\\n\\nSecond, Flow will infer that the typecast expression `(<expr>: <type>)` has the type `<type>`.\\n\\n```JavaScript\\n[(0: ?number)]; // Flow will infer the type Array<?number>\\n[0];            // Without the typecast, Flow infers the type Array<number>\\n```\\n\\n## Safety\\n\\nTypecasts obey the same rules as other type annotations, so they provide the same safety guarantees. This means they are safe unless you explicitly use the `any` type to defeat Flow\'s typechecking. Here are examples of upcasting (which is allowed), downcasting (which is forbidden), and using `any`.\\n\\n```JavaScript\\nclass Base {}\\nclass Child extends Base {}\\nvar child: Child = new Child();\\n\\n// Upcast from Child to Base, a more general type: OK\\nvar base: Base = new Child();\\n\\n// Upcast from Child to Base, a more general type: OK\\n(child: Base);\\n\\n// Downcast from Base to Child: unsafe, ERROR\\n(base: Child);\\n\\n// Upcast base to any then downcast any to Child.\\n// Unsafe downcasting from any is allowed: OK\\n((base: any): Child);\\n```\\n\\n## More examples\\n\\nTypecasts are particularly useful to check assumptions and help Flow infer the types you intend. Here are some examples:\\n\\n```JavaScript\\n(x: number) // Make Flow check that x is a number\\n(0: ?number) // Tells Flow that this expression is actually nullable.\\n(null: ?number) // Tells Flow that this expression is a nullable number.\\n```\\n\\n## Transformations\\n\\nLike type annotations and other Flow features, typecasts need to be transformed away before the code can be run. The transforms will be available in react-tools `0.13.0` when it is published soon, but for now they\'re available in `0.13.0-beta.2`, which you can install with\\n\\n```bash\\nnpm install react-tools@0.13.0-beta.2\\n```"}]}}')}}]);