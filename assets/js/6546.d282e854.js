"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[6546],{16546:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>c});var t=o(66178),s=o(74848),i=o(28453);const r={title:"Announcing Bounded Polymorphism","short-title":"Bounded Polymorphism",author:"Avik Chaudhuri",hide_table_of_contents:!0},l=void 0,a={authorsImageUrls:[void 0]},c=[{value:"The problem",id:"the-problem",level:2}];function d(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"As of Flow 0.5.0, you can define polymorphic functions and classes with bounds on their type parameters. This is extremely useful for writing functions and classes that need some constraints on their type parameters. Flow's bounded polymorphism syntax looks like"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"class BagOfBones<T: Bone> { ... }\nfunction eat<T: Food>(meal: T): Indigestion<T> { ... }\n"})}),"\n",(0,s.jsx)(n.h2,{id:"the-problem",children:"The problem"}),"\n",(0,s.jsx)(n.p,{children:"Consider the following code that defines a polymorphic function in Flow:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"function fooBad<T>(obj: T): T {\n  console.log(Math.abs(obj.x));\n  return obj;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This code does not (and should not!) type check. Not all values ",(0,s.jsx)(n.code,{children:"obj: T"})," have a property ",(0,s.jsx)(n.code,{children:"x"}),", let alone a property ",(0,s.jsx)(n.code,{children:"x"})," that is a ",(0,s.jsx)(n.code,{children:"number"}),", given the additional requirement imposed by ",(0,s.jsx)(n.code,{children:"Math.abs()"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,o)=>{o.d(n,{R:()=>r,x:()=>l});var t=o(96540);const s={},i=t.createContext(s);function r(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(i.Provider,{value:n},e.children)}},66178:e=>{e.exports=JSON.parse('{"permalink":"/blog/2015/03/12/Bounded-Polymorphism","source":"@site/blog/2015-03-12-Bounded-Polymorphism.md","title":"Announcing Bounded Polymorphism","description":"As of Flow 0.5.0, you can define polymorphic functions and classes with bounds on their type parameters. This is extremely useful for writing functions and classes that need some constraints on their type parameters. Flow\'s bounded polymorphism syntax looks like","date":"2015-03-12T00:00:00.000Z","tags":[],"hasTruncateMarker":true,"authors":[{"name":"Avik Chaudhuri","key":null,"page":null}],"frontMatter":{"title":"Announcing Bounded Polymorphism","short-title":"Bounded Polymorphism","author":"Avik Chaudhuri","hide_table_of_contents":true},"unlisted":false,"prevItem":{"title":"Announcing Disjoint Unions","permalink":"/blog/2015/07/03/Disjoint-Unions"},"nextItem":{"title":"Announcing Flow Comments","permalink":"/blog/2015/02/20/Flow-Comments"}}')}}]);