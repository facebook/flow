"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[2642],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(96540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}},72642:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"lang/annotation-requirement","title":"Annotation Requirement","description":"Note: As of version 0.199 Flow uses Local Type Inference as its inference algorithm.","source":"@site/docs/lang/annotation-requirement.md","sourceDirName":"lang","slug":"/lang/annotation-requirement","permalink":"/en/docs/lang/annotation-requirement","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/lang/annotation-requirement.md","tags":[],"version":"current","frontMatter":{"title":"Annotation Requirement","slug":"/lang/annotation-requirement"},"sidebar":"docsSidebar","previous":{"title":"File Signatures (Types-First)","permalink":"/en/docs/lang/types-first"},"next":{"title":"Getting Started","permalink":"/en/docs/react"}}');var s=t(74848),r=t(28453);const o={title:"Annotation Requirement",slug:"/lang/annotation-requirement"},a=void 0,l={},c=[{value:"Variable declarations",id:"variable-declarations",level:2},{value:"Function Parameters",id:"function-parameters",level:2},{value:"Contextual Typing",id:"toc-contextual-typing",level:2},{value:"Function Return Types",id:"toc-function-return-types",level:2},{value:"Generic Calls",id:"toc-generic-calls",level:2},{value:"Computing a Solution",id:"computing-a-solution",level:3},{value:"Errors during Polymorphic Calls",id:"errors-during-polymorphic-calls",level:3},{value:"Under-constrained Type Parameters",id:"under-constrained-type-parameters",level:4},{value:"Incompatibility Errors",id:"incompatibility-errors",level:4},{value:"Empty Array Literals",id:"toc-empty-array-literals",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," As of version 0.199 Flow uses ",(0,s.jsx)(n.a,{href:"https://medium.com/flow-type/local-type-inference-for-flow-aaa65d071347",children:"Local Type Inference"})," as its inference algorithm.\nThe rules in this section reflect the main design features in this inference scheme."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Flow tries to avoid requiring type annotation for parts of programs where types can easily\nbe inferred from the immediate context of an expression, variable, parameter, etc."}),"\n",(0,s.jsx)(n.h2,{id:"variable-declarations",children:"Variable declarations"}),"\n",(0,s.jsx)(n.p,{children:"Take for example the following variable definition"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const len = "abc".length;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["All information necessary to infer the type of ",(0,s.jsx)(n.code,{children:"len"})," is included in the initializer\n",(0,s.jsx)(n.code,{children:'"abc".length'}),". Flow will first determine that ",(0,s.jsx)(n.code,{children:'"abc"'})," is a string, and then that the\n",(0,s.jsx)(n.code,{children:"length"})," property of a string is a number."]}),"\n",(0,s.jsxs)(n.p,{children:["The same logic can be applied for all ",(0,s.jsx)(n.code,{children:"const"}),"-like initializations. Where things\nget a little more complicated is when variable initialization spans across multiple statements,\nfor example in"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'declare const maybeString: ?string;\n\nlet len;\nif (typeof maybeString === "string") {\n  len = maybeString.length;\n} else {\n  len = 0;\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Flow can still determine that ",(0,s.jsx)(n.code,{children:"len"})," is a ",(0,s.jsx)(n.code,{children:"number"}),", but in order to do so it looks\nahead to multiple initializer statements. See section on ",(0,s.jsx)(n.a,{href:"../variables",children:"variable declarations"}),"\nfor details on how various initializer patterns determine the type of a variable,\nand when an annotation on a variable declaration is necessary."]}),"\n",(0,s.jsx)(n.h2,{id:"function-parameters",children:"Function Parameters"}),"\n",(0,s.jsx)(n.p,{children:'Unlike variable declarations, this kind of "lookahead" reasoning cannot be used to determine\nthe type of function parameters. Consider the function'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function getLength(x) {\n  return x.length;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["There are many kinds of ",(0,s.jsx)(n.code,{children:"x"})," on which we could access and return a ",(0,s.jsx)(n.code,{children:"length"})," property:\nan object with a ",(0,s.jsx)(n.code,{children:"length"})," property, or a string, just to name a few. If later on in\nthe program we had the following calls to ",(0,s.jsx)(n.code,{children:"getLength"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'getLength("abc");\ngetLength({length: 1});\n'})}),"\n",(0,s.jsxs)(n.p,{children:["one possible inference would be that ",(0,s.jsx)(n.code,{children:"x"})," is a ",(0,s.jsx)(n.code,{children:"string | { length: number }"}),". What this implies,\nhowever, is that the type of ",(0,s.jsx)(n.code,{children:"getLength"})," is determined by any part of the current\nprogram. This kind of global reasoning can lead to surprising action-at-a-distance\nbehavior, and so is avoided. Instead, Flow requires that function parameters are annotated. Failure to\nprovide such a type annotation manifests as a ",(0,s.jsx)(n.code,{children:"[missing-local-annot]"})," error on the parameter ",(0,s.jsx)(n.code,{children:"x"}),",\nand the body of the function is checked with ",(0,s.jsx)(n.code,{children:"x: any"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":1,"startColumn":20,"endLine":1,"endColumn":20,"description":"Missing an annotation on `x`. [missing-local-annot]"}]',children:"function getLength(x) {\n  return x.length;\n}\n\nconst n = getLength(1); // no error since getLength's parameter type is 'any'\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To fix this error, one can simply annotate ",(0,s.jsx)(n.code,{children:"x"})," as"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function getLength(x: string) {\n  return x.length;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The same requirement holds for class methods"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":25,"endLine":3,"endColumn":25,"description":"Missing an annotation on `x`. [missing-local-annot]"}]',children:"class WrappedString {\n  data: string;\n  setStringNoAnnotation(x) {\n    this.data = x;\n  }\n  setString(x: string) {\n    this.data = x;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"toc-contextual-typing",children:"Contextual Typing"}),"\n",(0,s.jsx)(n.p,{children:"Function parameters do not always need to be explicitly annotated. In the case of a\ncallback function to a function call, the parameter type can easily\nbe inferred from the immediate context. Consider for example the following code"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const arr = [0, 1, 2];\nconst arrPlusOne = arr.find(x => x % 2 === 1);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Flow infers that the type of ",(0,s.jsx)(n.code,{children:"arr"})," is ",(0,s.jsx)(n.code,{children:"Array<number>"}),". Combining this with the builtin\ninformation for ",(0,s.jsx)(n.code,{children:"Array.find"}),", Flow can determine that the type of ",(0,s.jsx)(n.code,{children:"x => x % 2 + 1"}),"\nneeds to be ",(0,s.jsx)(n.code,{children:"number => mixed"}),". This type acts as a ",(0,s.jsx)(n.em,{children:"hint"})," for Flow and provides enough\ninformation to determine the type of ",(0,s.jsx)(n.code,{children:"x"})," as ",(0,s.jsx)(n.code,{children:"number"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Any attendant annotation can potentially act as a hint to a function parameter, for example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"const fn1: (x: number) => number = x => x + 1;\n"})}),"\n",(0,s.jsx)(n.p,{children:"However, it is also possible that an annotation cannot be used as a function\nparameter hint:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":1,"startColumn":20,"endLine":1,"endColumn":20,"description":"An annotation on `x` is required because Flow cannot infer its type from local context. [missing-local-annot]"}]',children:"const fn2: mixed = x => x + 1;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this example the ",(0,s.jsx)(n.code,{children:"mixed"})," type simply does not include enough information to\nextract a candidate type for ",(0,s.jsx)(n.code,{children:"x"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Flow can infer the types for unannotated parameters even when they are nested within\nother expressions like objects. For example in\nin"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":1,"startColumn":48,"endLine":1,"endColumn":48,"description":"Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-type]"}]',children:"const fn3: {f: (number) => void} = {f: (x) => {x as string}};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Flow will infer ",(0,s.jsx)(n.code,{children:"number"})," as the type of ",(0,s.jsx)(n.code,{children:"x"}),", and so the cast fails."]}),"\n",(0,s.jsx)(n.h2,{id:"toc-function-return-types",children:"Function Return Types"}),"\n",(0,s.jsxs)(n.p,{children:["Unlike function parameters, a function's return type does not need to be annotated in general.\nSo the above definition of ",(0,s.jsx)(n.code,{children:"getLength"})," won't raise any Flow errors."]}),"\n",(0,s.jsxs)(n.p,{children:["There are, however, a couple of notable exceptions to this rule. The first one is\nclass methods. If we included to the ",(0,s.jsx)(n.code,{children:"WrappedString"})," class a ",(0,s.jsx)(n.code,{children:"getString"})," method\nthat returns the internal ",(0,s.jsx)(n.code,{children:"data"})," property:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":23,"endLine":3,"endColumn":22,"description":"Missing an annotation on return. [missing-local-annot]"}]',children:"class WrappedString {\n  data: string;\n  getString(x: string) {\n    return this.data;\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Flow would complain that ",(0,s.jsx)(n.code,{children:"getString"})," is missing an annotation on the return."]}),"\n",(0,s.jsx)(n.p,{children:"The second exception is recursive definitions. A trivial example of this would be"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":1,"startColumn":1,"endLine":1,"endColumn":14,"description":"The following definitions recursively depend on each other, and Flow cannot compute their types:\\n - function [1] depends on other definition [2]\\n - function [3] depends on other definition [4]\\nPlease add type annotations to these definitions [5] [6] [definition-cycle]"}]',children:"function foo() {\n  return bar();\n}\n\nfunction bar() {\n  return foo();\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The above code raises a ",(0,s.jsx)(n.code,{children:"[definition-cycle]"})," error, which points to the two locations\nthat form a dependency cycle, the two missing return annotations. Adding\na return annotation to either function would resolve the issue."]}),"\n",(0,s.jsxs)(n.p,{children:["Effectively, the requirement on an annotation for method returns is a special-case\nof the recursive definition restriction. The recursion is possible through access on\n",(0,s.jsx)(n.code,{children:"this"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"toc-generic-calls",children:"Generic Calls"}),"\n",(0,s.jsxs)(n.p,{children:["In calls to ",(0,s.jsx)(n.a,{href:"../../types/generics",children:"generic functions"})," the type of the result may\ndepend on the types of the values passed in as arguments.\nThis section discusses how this result is computed, when type arguments are not\nexplicitly provided."]}),"\n",(0,s.jsx)(n.p,{children:"Consider for example the definition"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"declare function map<T, U>(\n  f: (T) => U,\n  array: $ReadOnlyArray<T>,\n): Array<U>;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["and a potential call with arguments ",(0,s.jsx)(n.code,{children:"x => x + 1"})," and ",(0,s.jsx)(n.code,{children:"[1, 2, 3]"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"map(x => x + 1, [1, 2, 3]);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here Flow infers that the type of ",(0,s.jsx)(n.code,{children:"x"})," is ",(0,s.jsx)(n.code,{children:"number"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Some other common examples of generic calls are calling the constructor of the generic\n",(0,s.jsxs)(n.a,{href:"https://github.com/facebook/flow/blob/82f88520f2bfe0fa13748b5ead711432941f4cb9/lib/core.js#L1799-L1801",children:[(0,s.jsx)(n.code,{children:"Set"})," class"]}),"\nor calling ",(0,s.jsx)(n.code,{children:"useState"})," from the React library:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":4,"startColumn":23,"endLine":4,"endColumn":34,"description":"Cannot call hook [1] because React hooks can only be called within components or hooks. (https://react.dev/reference/rules/rules-of-hooks) [react-rule-hook]"}]',children:"const set = new Set([1, 2, 3]);\n\nimport {useState} from 'react';\nconst [num, setNum] = useState(42);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Flow here infers that the type of ",(0,s.jsx)(n.code,{children:"set"})," is ",(0,s.jsx)(n.code,{children:"Set<number>"}),", and that ",(0,s.jsx)(n.code,{children:"num"})," and ",(0,s.jsx)(n.code,{children:"setNum"}),"\nare ",(0,s.jsx)(n.code,{children:"number"})," and ",(0,s.jsx)(n.code,{children:"(number) => void"}),", respectively."]}),"\n",(0,s.jsx)(n.h3,{id:"computing-a-solution",children:"Computing a Solution"}),"\n",(0,s.jsx)(n.p,{children:"Computing the result of a generic call amounts to:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["coming up with a solution for ",(0,s.jsx)(n.code,{children:"T"})," and ",(0,s.jsx)(n.code,{children:"U"})," that does not contain generic parts,"]}),"\n",(0,s.jsxs)(n.li,{children:["replacing ",(0,s.jsx)(n.code,{children:"T"})," and ",(0,s.jsx)(n.code,{children:"U"})," with the solution in the signature of ",(0,s.jsx)(n.code,{children:"map"}),", and"]}),"\n",(0,s.jsxs)(n.li,{children:["performing a call to this new signature of ",(0,s.jsx)(n.code,{children:"map"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This process is designed with two goals in mind:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"Soundness"}),". The results need to lead to a correct call when we reach step (3)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"Completeness"}),". The types Flow produces need to be as precise and informative as possible,\nto ensure that other parts of the program will be successfully checked."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Let's see how these two goals come into play in the ",(0,s.jsx)(n.code,{children:"map"})," example from above."]}),"\n",(0,s.jsxs)(n.p,{children:["Flow detects that ",(0,s.jsx)(n.code,{children:"$ReadOnlyArray<T>"})," needs to be compatible with the type of ",(0,s.jsx)(n.code,{children:"[1, 2, 3]"}),".\nIt can therefore infer that ",(0,s.jsx)(n.code,{children:"T"})," is ",(0,s.jsx)(n.code,{children:"number"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["With the knowledge of ",(0,s.jsx)(n.code,{children:"T"})," it can now successfully check ",(0,s.jsx)(n.code,{children:"x => x + 1"}),". The parameter ",(0,s.jsx)(n.code,{children:"x"}),"\nis contextually typed as ",(0,s.jsx)(n.code,{children:"number"}),", and thus the result ",(0,s.jsx)(n.code,{children:"x + 1"})," is also a number.\nThis final constraint allows us to compute ",(0,s.jsx)(n.code,{children:"U"})," as a ",(0,s.jsx)(n.code,{children:"number"})," too."]}),"\n",(0,s.jsxs)(n.p,{children:["The new signature of ",(0,s.jsx)(n.code,{children:"map"})," after replacing the generic parts with the above solution\nis"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"(f: (number) => number, array: $ReadOnlyArray<number>) => Array<number>\n"})}),"\n",(0,s.jsx)(n.p,{children:"It is easy to see that the call would be successfully checked."}),"\n",(0,s.jsx)(n.h3,{id:"errors-during-polymorphic-calls",children:"Errors during Polymorphic Calls"}),"\n",(0,s.jsx)(n.p,{children:"If the above process goes on smoothly, you should not be seeing any errors associated with the call.\nWhat happens though when this process fails?"}),"\n",(0,s.jsx)(n.p,{children:"There are two reasons why this process could fail:"}),"\n",(0,s.jsx)(n.h4,{id:"under-constrained-type-parameters",children:"Under-constrained Type Parameters"}),"\n",(0,s.jsxs)(n.p,{children:["There are cases where Flow might not have enough information to decide the type of a type parameter.\nLet's examine again a call to the builtin generic\n",(0,s.jsxs)(n.a,{href:"https://github.com/facebook/flow/blob/82f88520f2bfe0fa13748b5ead711432941f4cb9/lib/core.js#L1799-L1801",children:[(0,s.jsx)(n.code,{children:"Set"})," class"]}),"\nconstructor, this time without passing any arguments:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":1,"startColumn":17,"endLine":1,"endColumn":19,"description":"Cannot call `Set` because `T` [1] is underconstrained by new `Set` [2]. Either add explicit type arguments or cast the expression to your expected type. [underconstrained-implicit-instantiation]"}]',children:'const set = new Set();\nset.add("abc");\n'})}),"\n",(0,s.jsxs)(n.p,{children:["During the call to ",(0,s.jsx)(n.code,{children:"new Set"}),", we are not providing enough information for Flow to\ndetermine the type for ",(0,s.jsx)(n.code,{children:"T"}),", even though the subsequent call to ",(0,s.jsx)(n.code,{children:"set.add"})," clearly\nimplies that ",(0,s.jsx)(n.code,{children:"T"})," will be a string. Remember that inference of type arguments is\nlocal to the call, so Flow will not attempt to look ahead in later statements\nto determine this."]}),"\n",(0,s.jsxs)(n.p,{children:["In the absence of information, Flow would be at liberty to infer ",(0,s.jsx)(n.em,{children:"any"})," type\nas ",(0,s.jsx)(n.code,{children:"T"}),": ",(0,s.jsx)(n.code,{children:"any"}),", ",(0,s.jsx)(n.code,{children:"mixed"}),", ",(0,s.jsx)(n.code,{children:"empty"}),", etc.\nThis kind of decision is undesirable, as it can lead to surprising results.\nFor example, if we silently decided on ",(0,s.jsx)(n.code,{children:"Set<empty>"})," then the call to ",(0,s.jsx)(n.code,{children:'set.add("abc")'})," would\nfail with an incompatibility between ",(0,s.jsx)(n.code,{children:"string"})," and ",(0,s.jsx)(n.code,{children:"empty"}),", without a clear indication\nof where the ",(0,s.jsx)(n.code,{children:"empty"})," came from."]}),"\n",(0,s.jsxs)(n.p,{children:["So instead, in situations like this, you'll get an ",(0,s.jsx)(n.code,{children:"[underconstrained-implicit-instantiation]"})," error.\nThe way to fix this error is by adding a type annotation. There a few potential ways to do this:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Add an annotation at the call-site in one of two ways:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["an explicit type argument","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const set = new Set<string>();\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["an annotation on the initialization variable:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const set: Set<string> = new Set();\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Add a default type on the type parameter ",(0,s.jsx)(n.code,{children:"T"})," at the definition of the class:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"declare class SetWithDefault<T = string> extends $ReadOnlySet<T> {\n  constructor(iterable?: ?Iterable<T>): void;\n  // more methods ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In the absence of any type information at the call-site, Flow will use the default\ntype of ",(0,s.jsx)(n.code,{children:"T"})," as the inferred type argument:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const defaultSet = new SetWithDefault(); // defaultSet is SetWithDefault<string>\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"incompatibility-errors",children:"Incompatibility Errors"}),"\n",(0,s.jsx)(n.p,{children:"Even when Flow manages to infer non-generic types for the type parameters in a generic\ncall, these types might still lead to incompatibilities either in the current call or in\ncode later on."}),"\n",(0,s.jsxs)(n.p,{children:["For example, if we had the following call to ",(0,s.jsx)(n.code,{children:"map"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":2,"startColumn":10,"endLine":2,"endColumn":14,"description":"Cannot use operator `+` with operands object literal [1] and number [2] [unsafe-addition]"}]',children:"declare function map<T, U>(f: (T) => U, array: $ReadOnlyArray<T>): Array<U>;\nmap(x => x + 1, [{}]);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Flow will infer ",(0,s.jsx)(n.code,{children:"T"})," as ",(0,s.jsx)(n.code,{children:"{}"}),", and therefore type ",(0,s.jsx)(n.code,{children:"x"})," as ",(0,s.jsx)(n.code,{children:"{}"}),". This will cause an error when checking the arrow function\nsince the ",(0,s.jsx)(n.code,{children:"+"})," operation is not allowed on objects."]}),"\n",(0,s.jsx)(n.p,{children:"Finally, a common source of errors is the case where the inferred type in a generic\ncall is correct for the call itself, but not indicative of the expected use later in the code.\nFor example, consider"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":2,"startColumn":23,"endLine":2,"endColumn":34,"description":"Cannot call hook [1] because React hooks can only be called within components or hooks. (https://react.dev/reference/rules/rules-of-hooks) [react-rule-hook]"},{"startLine":5,"startColumn":8,"endLine":5,"endColumn":18,"description":"Cannot call `setStr` with `maybeString` bound to the first parameter because: [incompatible-type] Either null or undefined [1] is incompatible with function type [2]. Or null or undefined [1] is incompatible with string [3]."}]',children:"import {useState} from 'react';\nconst [str, setStr] = useState(\"\");\n\ndeclare const maybeString: ?string;\nsetStr(maybeString);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Passing the string ",(0,s.jsx)(n.code,{children:'""'})," to the call to ",(0,s.jsx)(n.code,{children:"useState"})," makes Flow infer ",(0,s.jsx)(n.code,{children:"string"})," as the type\nof the state. So ",(0,s.jsx)(n.code,{children:"setStr"})," will also expect a ",(0,s.jsx)(n.code,{children:"string"})," as input when called later on,\nand therefore passing a ",(0,s.jsx)(n.code,{children:"?string"})," will be an error."]}),"\n",(0,s.jsxs)(n.p,{children:['Again, to fix this error it suffices to annotate the expected "wider" type of state\nwhen calling ',(0,s.jsx)(n.code,{children:"useState"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const [str, setStr] = useState<?string>("");\n'})}),"\n",(0,s.jsx)(n.h2,{id:"toc-empty-array-literals",children:"Empty Array Literals"}),"\n",(0,s.jsxs)(n.p,{children:["Empty array literals (",(0,s.jsx)(n.code,{children:"[]"}),") are handled specially in Flow. You can read about their ",(0,s.jsx)(n.a,{href:"../../types/arrays/#toc-empty-array-literals",children:"behavior and requirements"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);