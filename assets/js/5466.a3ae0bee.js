"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[5466],{28453:(e,n,o)=>{o.d(n,{R:()=>i,x:()=>t});var s=o(96540);const r={},c=s.createContext(r);function i(e){const n=s.useContext(c);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(c.Provider,{value:n},e.children)}},55466:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>a,contentTitle:()=>t,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"cli/coverage","title":"Flow Coverage","description":"The coverage command provides a metric of the amount of checking that Flow has","source":"@site/docs/cli/coverage.md","sourceDirName":"cli","slug":"/cli/coverage","permalink":"/en/docs/cli/coverage","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/cli/coverage.md","tags":[],"version":"current","frontMatter":{"title":"Flow Coverage","slug":"/cli/coverage"},"sidebar":"docsSidebar","previous":{"title":"Flow CLI","permalink":"/en/docs/cli"},"next":{"title":"Flow Annotate-Exports","permalink":"/en/docs/cli/annotate-exports"}}');var r=o(74848),c=o(28453);const i={title:"Flow Coverage",slug:"/cli/coverage"},t=void 0,a={},l=[{value:"Design Space",id:"toc-design-space",level:2},{value:"Command Line Use",id:"toc-command-line-use",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"The coverage command provides a metric of the amount of checking that Flow has\nperformed on each part of your code. A program with high Flow coverage should\nincrease your confidence that Flow has detected any potential runtime errors."}),"\n",(0,r.jsxs)(n.p,{children:["The determining factor for this is the presence of ",(0,r.jsx)(n.a,{href:"../../types/any/",children:(0,r.jsx)(n.code,{children:"any"})})," in the\ninferred type of each expression. An expression whose inferred type is ",(0,r.jsx)(n.code,{children:"any"})," is\nconsidered ",(0,r.jsx)(n.em,{children:"uncovered"}),", otherwise it is considered ",(0,r.jsx)(n.em,{children:"covered"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"To see why this metric was chosen for determining Flow's effectiveness, consider\nthe example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"const one: any = 1;\none();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This code leads to a runtime type error, since we are attempting to perform a call\non a number. Flow, however, does not flag an error here, because we have annotated\nvariable ",(0,r.jsx)(n.code,{children:"one"})," as ",(0,r.jsx)(n.code,{children:"any"}),". Flow's checking is effectively turned off whenever ",(0,r.jsx)(n.code,{children:"any"}),"\nis involved, so it will silently allow the call. The use of this ",(0,r.jsx)(n.em,{children:"unsafe"})," type has\nrendered the type checker ineffective, and the coverage metric is here to surface\nthis, by reporting all instances of ",(0,r.jsx)(n.code,{children:"one"})," as uncovered."]}),"\n",(0,r.jsx)(n.h2,{id:"toc-design-space",children:"Design Space"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:'Which types should be "covered"?'})}),"\n",(0,r.jsxs)(n.p,{children:["What was described above is a rather coarse grained way to determine coverage. One\ncould imagine a criterion that flags expressions as uncovered if ",(0,r.jsx)(n.em,{children:"any"})," part of their\ntype includes ",(0,r.jsx)(n.code,{children:"any"}),", for example ",(0,r.jsx)(n.code,{children:"Array<any>"}),'. While there is value in a metric like\nthis, the "uncovered" part of the type will typically be uncovered through various\noperations on values of this type. For example, in the code']}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"declare const arr: Array<any>;\narr.forEach(x => {});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["the parameter ",(0,r.jsx)(n.code,{children:"x"})," will be flagged as uncovered. Also, in practice, a strict criterion\nlike this would be too noisy and rather expensive to compute on the fly."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Union types"})}),"\n",(0,r.jsxs)(n.p,{children:["An exception to this principle are union types: the type ",(0,r.jsx)(n.code,{children:"number | any"})," is considered\n",(0,r.jsx)(n.em,{children:"uncovered"}),", even though technically ",(0,r.jsx)(n.code,{children:"any"})," is not the top-level constructor.\nUnions merely encode an option among ",(0,r.jsx)(n.em,{children:"a set of"})," other types. In that sense we are\nconservatively viewing an expression as uncovered, when at least one possible type\nof that expression causes limited checking. For example, in the code"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'let x: number | any = 1;\nx = "a";\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Flow will let you assign anything to ",(0,r.jsx)(n.code,{children:"x"}),", which reduces confidence in the use\nof ",(0,r.jsx)(n.code,{children:"x"})," as a number. Thus ",(0,r.jsx)(n.code,{children:"x"})," is considered uncovered."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"The empty type"})}),"\n",(0,r.jsxs)(n.p,{children:["An interesting type from a coverage perspective is the ",(0,r.jsx)(n.a,{href:"../../types/empty",children:(0,r.jsx)(n.code,{children:"empty"})})," type.\nThis type roughly corresponds to ",(0,r.jsx)(n.em,{children:"dead code"}),". As such checking around expressions with\ntype ",(0,r.jsx)(n.code,{children:"empty"})," is more relaxed, but for a good reason: this code will not be executed at\nruntime. Since it is a common practice to clean up such code, Flow coverage will\nalso report code whose type is inferred to be ",(0,r.jsx)(n.code,{children:"empty"}),", but distinguishes it from\nthe case of ",(0,r.jsx)(n.code,{children:"any"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"toc-command-line-use",children:"Command Line Use"}),"\n",(0,r.jsx)(n.p,{children:"To find out the coverage of a file foo.js with the following contents"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function add(one: any, two: any): number {\n  return one + two;\n}\n\nadd(1, 2);\n"})}),"\n",(0,r.jsx)(n.p,{children:"you can issue the following command"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"$ flow coverage file.js\nCovered: 50.00% (5 of 10 expressions)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This output means that 5 out of the 10 nodes of this program were inferred to have type\n",(0,r.jsx)(n.code,{children:"any"}),". To see exactly which parts are uncovered you can also pass one of the following\nflags:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"--color"}),": This will print foo.js on the terminal with the uncovered locations in\nred color. E.g. ",(0,r.jsx)(n.code,{children:"flow coverage --color file.js"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"--json"}),": This will list out all location spans that are uncovered under\nthe tag ",(0,r.jsx)(n.code,{children:'"uncovered_locs"'}),". E.g. ",(0,r.jsx)(n.code,{children:"flow coverage --json file.js"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Finally, as an example of dead code, consider the code:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function f(x: 'a' | 'b') {\n  if (x === 'a') {\n    // ...\n  } else if (x === 'b') {\n    // ...\n  } else {\n    x;\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The final ",(0,r.jsx)(n.code,{children:"else"})," clause should never be reached, as we've already checked for both members of the union.\nBecause of this, ",(0,r.jsx)(n.code,{children:"x"})," is inferred to have the type ",(0,r.jsx)(n.code,{children:"empty"})," in that branch."]}),"\n",(0,r.jsxs)(n.p,{children:["In the colored version of this command, these parts appear in blue color,\nand in the JSON version they are under the field ",(0,r.jsx)(n.code,{children:'"empty_locs"'}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use on multiple files"})}),"\n",(0,r.jsxs)(n.p,{children:["If you want to check coverage of multiple files at once, Flow offers the\n",(0,r.jsx)(n.code,{children:"batch-coverage"})," command:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"$ flow batch-coverage dir/\n"})}),"\n",(0,r.jsxs)(n.p,{children:["will report coverage statistics for each file under ",(0,r.jsx)(n.code,{children:"dir/"}),", as well as aggregate\nresults."]}),"\n",(0,r.jsxs)(n.p,{children:["Note that ",(0,r.jsx)(n.code,{children:"batch-coverage"})," requires a non-lazy Flow server."]})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);