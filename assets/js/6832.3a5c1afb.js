"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[6832],{28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>c});var s=t(96540);const i={},r=s.createContext(i);function l(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(r.Provider,{value:n},e.children)}},46832:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"types/primitives","title":"Primitive Types","description":"JavaScript has a number of different primitive types","source":"@site/docs/types/primitives.md","sourceDirName":"types","slug":"/types/primitives","permalink":"/en/docs/types/primitives","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/types/primitives.md","tags":[],"version":"current","frontMatter":{"title":"Primitive Types","slug":"/types/primitives"},"sidebar":"docsSidebar","previous":{"title":"Type Annotations","permalink":"/en/docs/types"},"next":{"title":"Literal Types","permalink":"/en/docs/types/literals"}}');var i=t(74848),r=t(28453);const l={title:"Primitive Types",slug:"/types/primitives"},c=void 0,o={},a=[{value:"Booleans",id:"toc-booleans",level:2},{value:"Numbers",id:"toc-numbers",level:2},{value:"Strings",id:"toc-strings",level:2},{value:"<code>null</code> and <code>undefined</code>",id:"toc-null-and-void",level:2},{value:"Maybe types",id:"toc-maybe-types",level:3},{value:"Optional object properties",id:"toc-optional-object-properties",level:3},{value:"Optional function parameters",id:"toc-optional-function-parameters",level:3},{value:"Function parameters with defaults",id:"toc-function-parameters-with-defaults",level:3},{value:"Symbols",id:"toc-symbols",level:2},{value:"BigInts",id:"toc-bigints",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["JavaScript has a number of different primitive types\n(",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#primitive_values",children:"MDN"}),"):"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{}),(0,i.jsx)(n.th,{children:"Example"}),(0,i.jsx)(n.th,{children:"Flow type"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Booleans"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"true"})," or ",(0,i.jsx)(n.code,{children:"false"})]}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"boolean"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Strings"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"'foo'"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"string"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Numbers"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"123"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"number"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Null"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"null"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"null"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Undefined"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"undefined"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"void"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:"Symbols"})," ",(0,i.jsx)("small",{children:(0,i.jsx)(n.em,{children:"(new in ES2015)"})})]}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Symbol('foo')"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"symbol"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.strong,{children:"BigInts"})," ",(0,i.jsx)("small",{children:(0,i.jsx)(n.em,{children:"(new in ES2020)"})})]}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"123n"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"bigint"})})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Some primitive types appear in the language as literal values:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'true;\n"hello";\n3.14;\nnull;\nundefined;\n3n;\n'})}),"\n",(0,i.jsxs)(n.p,{children:["BigInts and Symbols can be created with calls to ",(0,i.jsx)(n.code,{children:"BigInt"})," and ",(0,i.jsx)(n.code,{children:"Symbol"}),", respectively:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'BigInt("2364023476023");\nSymbol("hello");\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The Flow types of literal values are lowercase (mirroring the output of JavaScript's\n",(0,i.jsxs)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof",children:[(0,i.jsx)(n.code,{children:"typeof"})," expression"]}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'function func(a: number, b: string, c: boolean, d: bigint) { /* ... */ }\n\nfunc(3.14, "hello", true, 3n);\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Some literals can also be used as ",(0,i.jsx)(n.a,{href:"../literals",children:"literal types"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":4,"startColumn":11,"endLine":4,"endColumn":11,"description":"Cannot call `acceptTwo` with `1` bound to `x` because number literal `1` [1] is incompatible with number literal `2` [2]. [incompatible-type]"}]',children:"function acceptTwo(x: 2) { /* ... */ }\n\nacceptTwo(2); // Works!\nacceptTwo(1); // Error!\n"})}),"\n",(0,i.jsx)(n.p,{children:"Some primitives can also be wrapped as objects:"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"NOTE: You probably never want to use the wrapper object variants."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'new Boolean(false);\nnew String("world");\nnew Number(42);\n'})}),"\n",(0,i.jsx)(n.p,{children:"Types for the wrapper objects are capitalized (the same as their constructor):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'function func(x: Number, y: String, z: Boolean) {\n  // ...\n}\n\nfunc(new Number(42), new String("world"), new Boolean(false));\n'})}),"\n",(0,i.jsx)(n.p,{children:"These wrapper objects are rarely used."}),"\n",(0,i.jsx)(n.h2,{id:"toc-booleans",children:"Booleans"}),"\n",(0,i.jsxs)(n.p,{children:["Booleans are ",(0,i.jsx)(n.code,{children:"true"})," and ",(0,i.jsx)(n.code,{children:"false"})," values in JavaScript. The ",(0,i.jsx)(n.code,{children:"boolean"})," type in\nFlow accepts these values."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":6,"startColumn":16,"endLine":6,"endColumn":20,"description":"Cannot call `acceptsBoolean` with `\\"foo\\"` bound to `value` because string [1] is incompatible with boolean [2]. [incompatible-type]"}]',children:'function acceptsBoolean(value: boolean) { /* ... */ }\n\nacceptsBoolean(true);  // Works!\nacceptsBoolean(false); // Works!\n\nacceptsBoolean("foo"); // Error!\n'})}),"\n",(0,i.jsx)(n.p,{children:"JavaScript can also implicitly convert other types of values into booleans."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'if (42) {} // 42 => true\nif ("") {} // "" => false\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Flow understands these coercions and will allow them as part of an\n",(0,i.jsx)(n.code,{children:"if"})," statement's test or other conditional contexts."]}),"\n",(0,i.jsxs)(n.p,{children:["To explicitly convert non-booleans to a ",(0,i.jsx)(n.code,{children:"boolean"}),", you can use ",(0,i.jsx)(n.code,{children:"Boolean(x)"})," or ",(0,i.jsx)(n.code,{children:"!!x"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":16,"endLine":3,"endColumn":16,"description":"Cannot call `acceptsBoolean` with `0` bound to `value` because number [1] is incompatible with boolean [2]. [incompatible-type]"}]',children:"function acceptsBoolean(value: boolean) { /* ... */ }\n\nacceptsBoolean(0);          // Error!\n\nacceptsBoolean(Boolean(0)); // Works!\nacceptsBoolean(!!0);        // Works!\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can ",(0,i.jsx)(n.a,{href:"../../lang/refinements/",children:"refine"})," a value to ",(0,i.jsx)(n.code,{children:"boolean"})," using a ",(0,i.jsx)(n.code,{children:"typeof"})," check:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function acceptsBoolean(value: boolean) { /* ... */ }\n\nfunction func(value: mixed) {\n  if (typeof value === 'boolean') {\n    acceptsBoolean(value); // Works: `value` is `boolean`\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Remember that ",(0,i.jsx)(n.code,{children:"boolean"})," and ",(0,i.jsx)(n.code,{children:"Boolean"})," are different types."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.code,{children:"boolean"})," is a literal value like ",(0,i.jsx)(n.code,{children:"true"})," or ",(0,i.jsx)(n.code,{children:"false"})," or the result of an\nexpression like ",(0,i.jsx)(n.code,{children:"a === b"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.code,{children:"Boolean"})," is a wrapper object created by the global ",(0,i.jsx)(n.code,{children:"new Boolean(x)"}),"\nconstructor. You probably don't want to use this!"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"toc-numbers",children:"Numbers"}),"\n",(0,i.jsxs)(n.p,{children:["Number literals in JavaScript are floating point numbers, for example ",(0,i.jsx)(n.code,{children:"42"})," or ",(0,i.jsx)(n.code,{children:"3.14"}),".\nJavaScript also considers ",(0,i.jsx)(n.code,{children:"Infinity"})," and ",(0,i.jsx)(n.code,{children:"NaN"})," to be numbers.\nThese are represented by the ",(0,i.jsx)(n.code,{children:"number"})," type. JavaScript also has a separate ",(0,i.jsx)(n.a,{href:"#toc-bigints",children:"BigInt type"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":8,"startColumn":15,"endLine":8,"endColumn":19,"description":"Cannot call `acceptsNumber` with `\\"foo\\"` bound to `value` because string [1] is incompatible with number [2]. [incompatible-type]"},{"startLine":9,"startColumn":15,"endLine":9,"endColumn":18,"description":"Cannot call `acceptsNumber` with `123n` bound to `value` because bigint literal `123n` [1] is incompatible with number [2]. [incompatible-type]"}]',children:'function acceptsNumber(value: number) { /* ... */ }\n\nacceptsNumber(42);       // Works!\nacceptsNumber(3.14);     // Works!\nacceptsNumber(NaN);      // Works!\nacceptsNumber(Infinity); // Works!\n\nacceptsNumber("foo");    // Error!\nacceptsNumber(123n);     // Error!\n'})}),"\n",(0,i.jsxs)(n.p,{children:["You can ",(0,i.jsx)(n.a,{href:"../../lang/refinements/",children:"refine"})," a value to ",(0,i.jsx)(n.code,{children:"number"})," using a ",(0,i.jsx)(n.code,{children:"typeof"})," check:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function acceptsNumber(value: number) { /* ... */ }\n\nfunction func(value: mixed) {\n  if (typeof value === 'number') {\n    acceptsNumber(value); // Works: `value` is `number`\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Remember that ",(0,i.jsx)(n.code,{children:"number"})," and ",(0,i.jsx)(n.code,{children:"Number"})," are different types."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.code,{children:"number"})," is a literal value like ",(0,i.jsx)(n.code,{children:"42"})," or ",(0,i.jsx)(n.code,{children:"3.14"})," or the result of an\nexpression like ",(0,i.jsx)(n.code,{children:"parseFloat(x)"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.code,{children:"Number"})," is a wrapper object created by the global ",(0,i.jsx)(n.code,{children:"new Number(x)"})," constructor. You probably don't want to use this!"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"toc-strings",children:"Strings"}),"\n",(0,i.jsxs)(n.p,{children:["Strings are ",(0,i.jsx)(n.code,{children:'"foo"'})," values in JavaScript. The ",(0,i.jsx)(n.code,{children:"string"})," type in Flow accepts these values."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":6,"startColumn":15,"endLine":6,"endColumn":19,"description":"Cannot call `acceptsString` with `false` bound to `value` because boolean [1] is incompatible with string [2]. [incompatible-type]"}]',children:'function acceptsString(value: string) { /* ... */ }\n\nacceptsString("foo"); // Works!\nacceptsString(`template literal`); // Works!\n\nacceptsString(false); // Error!\n'})}),"\n",(0,i.jsx)(n.p,{children:"JavaScript implicitly converts other types of values into strings by\nconcatenating them."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'"foo" + 42; // "foo42"\n"foo" + {}; // "foo[object Object]"\n'})}),"\n",(0,i.jsx)(n.p,{children:"Flow will only accept strings and numbers when concatenating them to strings."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":5,"startColumn":1,"endLine":5,"endColumn":10,"description":"Cannot use operator `+` with operands string [1] and object literal [2] [unsafe-addition]"},{"startLine":6,"startColumn":1,"endLine":6,"endColumn":10,"description":"Cannot use operator `+` with operands string [1] and empty array literal [2] [unsafe-addition]"},{"startLine":7,"startColumn":8,"endLine":7,"endColumn":9,"description":"Cannot coerce array literal to string because empty array literal [1] should not be coerced. [incompatible-type]"}]',children:'"foo" + "foo"; // Works!\n"foo" + 42;    // Works!\n`foo ${42}`;   // Works!\n\n"foo" + {};    // Error!\n"foo" + [];    // Error!\n`foo ${[]}`;   // Error!\n'})}),"\n",(0,i.jsx)(n.p,{children:"You must be explicit and convert other types into strings. You can do this by\nusing the String function or using another method for stringifying values."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'"foo" + String({});     // Works!\n"foo" + [].toString();  // Works!\n"" + JSON.stringify({}) // Works!\n'})}),"\n",(0,i.jsxs)(n.p,{children:["You can ",(0,i.jsx)(n.a,{href:"../../lang/refinements/",children:"refine"})," a value to ",(0,i.jsx)(n.code,{children:"string"})," using a ",(0,i.jsx)(n.code,{children:"typeof"})," check:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function acceptsString(value: string) { /* ... */ }\n\nfunction func(value: mixed) {\n  if (typeof value === 'string') {\n    acceptsString(value); // Works: `value` is `string`\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Remember that ",(0,i.jsx)(n.code,{children:"string"})," and ",(0,i.jsx)(n.code,{children:"String"})," are different types."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.code,{children:"string"})," is a literal value like ",(0,i.jsx)(n.code,{children:'"foo"'})," or the result of an expression\nlike ",(0,i.jsx)(n.code,{children:'"" + 42'}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.code,{children:"String"})," is a wrapper object created by the global ",(0,i.jsx)(n.code,{children:"new String(x)"})," constructor. You probably don't want to use this!"]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"toc-null-and-void",children:[(0,i.jsx)(n.code,{children:"null"})," and ",(0,i.jsx)(n.code,{children:"undefined"})]}),"\n",(0,i.jsxs)(n.p,{children:["JavaScript has both ",(0,i.jsx)(n.code,{children:"null"})," and ",(0,i.jsx)(n.code,{children:"undefined"}),". Flow treats these as separate\ntypes: ",(0,i.jsx)(n.code,{children:"null"})," and ",(0,i.jsx)(n.code,{children:"void"})," (for ",(0,i.jsx)(n.code,{children:"undefined"}),")."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":4,"startColumn":13,"endLine":4,"endColumn":21,"description":"Cannot call `acceptsNull` with `undefined` bound to `value` because undefined [1] is incompatible with null [2]. [incompatible-type]"},{"startLine":9,"startColumn":18,"endLine":9,"endColumn":21,"description":"Cannot call `acceptsUndefined` with `null` bound to `value` because null [1] is incompatible with undefined [2]. [incompatible-type]"}]',children:"function acceptsNull(value: null) { /* ... */ }\n\nacceptsNull(null);      // Works!\nacceptsNull(undefined); // Error!\n\nfunction acceptsUndefined(value: void) { /* ... */ }\n\nacceptsUndefined(undefined); // Works!\nacceptsUndefined(null);      // Error!\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can ",(0,i.jsx)(n.a,{href:"../../lang/refinements/",children:"refine"})," a value to ",(0,i.jsx)(n.code,{children:"null"})," or ",(0,i.jsx)(n.code,{children:"void"})," using equality checks:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function acceptsNull(value: null) { /* ... */ }\n\nfunction func(value: mixed) {\n  if (value === null) {\n    acceptsNull(value); // Works: `value` is `null`\n  }\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function acceptsUndefined(value: void) { /* ... */ }\n\nfunction func(value: mixed) {\n  if (value === undefined) {\n    acceptsUndefined(value); // Works: `value` is `void`\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"null"})," and ",(0,i.jsx)(n.code,{children:"void"})," also appear in other types:"]}),"\n",(0,i.jsx)(n.h3,{id:"toc-maybe-types",children:"Maybe types"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"../maybe",children:"Maybe types"})," are for places where a value is optional and you can create them by\nadding a question mark in front of the type such as ",(0,i.jsx)(n.code,{children:"?string"})," or ",(0,i.jsx)(n.code,{children:"?number"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"?T"})," is equivalent to ",(0,i.jsx)(n.code,{children:"T | null | void"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'function acceptsMaybeString(value: ?string) { /* ... */ }\n\nacceptsMaybeString("bar");     // Works!\nacceptsMaybeString(undefined); // Works!\nacceptsMaybeString(null);      // Works!\nacceptsMaybeString();          // Works!\n'})}),"\n",(0,i.jsxs)(n.p,{children:["To refine, ",(0,i.jsx)(n.code,{children:"value == null"})," checks exactly for both ",(0,i.jsx)(n.code,{children:"null"})," and ",(0,i.jsx)(n.code,{children:"undefined"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Read the ",(0,i.jsx)(n.a,{href:"../maybe",children:"maybe type docs"})," for more details."]}),"\n",(0,i.jsx)(n.h3,{id:"toc-optional-object-properties",children:"Optional object properties"}),"\n",(0,i.jsxs)(n.p,{children:["Object types can have optional properties where a question mark ",(0,i.jsx)(n.code,{children:"?"})," comes after\nthe property name."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"{propertyName?: string}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In addition to their set value type, these optional properties can either be\n",(0,i.jsx)(n.code,{children:"void"})," or omitted altogether. However, they cannot be ",(0,i.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":7,"startColumn":21,"endLine":7,"endColumn":24,"description":"Cannot call `acceptsObject` with object literal bound to `value` because null [1] is incompatible with string [2] in property `foo`. [incompatible-type]"}]',children:'function acceptsObject(value: {foo?: string}) { /* ... */ }\n\nacceptsObject({foo: "bar"});     // Works!\nacceptsObject({foo: undefined}); // Works!\nacceptsObject({});               // Works!\n\nacceptsObject({foo: null});      // Error!\n'})}),"\n",(0,i.jsx)(n.h3,{id:"toc-optional-function-parameters",children:"Optional function parameters"}),"\n",(0,i.jsxs)(n.p,{children:["Functions can have optional parameters where a question mark ",(0,i.jsx)(n.code,{children:"?"})," comes after\nthe parameter name."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function func(param?: string) { /* ... */ }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In addition to their set type, these optional parameters can either be ",(0,i.jsx)(n.code,{children:"void"}),"\nor omitted altogether. However, they cannot be ",(0,i.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":7,"startColumn":23,"endLine":7,"endColumn":26,"description":"Cannot call `acceptsOptionalString` with `null` bound to `value` because null [1] is incompatible with string [2]. [incompatible-type]"}]',children:'function acceptsOptionalString(value?: string) { /* ... */ }\n\nacceptsOptionalString("bar");     // Works!\nacceptsOptionalString(undefined); // Works!\nacceptsOptionalString();          // Works!\n\nacceptsOptionalString(null);      // Error!\n'})}),"\n",(0,i.jsx)(n.h3,{id:"toc-function-parameters-with-defaults",children:"Function parameters with defaults"}),"\n",(0,i.jsx)(n.p,{children:"Function parameters can also have defaults. This is a feature of ES2015."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'function func(value: string = "default") { /* ... */ }\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In addition to their set type, default parameters can also be ",(0,i.jsx)(n.code,{children:"void"})," or omitted\naltogether. However, they cannot be ",(0,i.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":7,"startColumn":23,"endLine":7,"endColumn":26,"description":"Cannot call `acceptsOptionalString` with `null` bound to `value` because null [1] is incompatible with string [2]. [incompatible-type]"}]',children:'function acceptsOptionalString(value: string = "foo") { /* ... */ }\n\nacceptsOptionalString("bar");     // Works!\nacceptsOptionalString(undefined); // Works!\nacceptsOptionalString();          // Works!\n\nacceptsOptionalString(null);      // Error!\n'})}),"\n",(0,i.jsx)(n.h2,{id:"toc-symbols",children:"Symbols"}),"\n",(0,i.jsxs)(n.p,{children:["Symbols are created with ",(0,i.jsx)(n.code,{children:"Symbol()"})," in JavaScript. Flow has basic support for symbols, using the ",(0,i.jsx)(n.code,{children:"symbol"})," type."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":6,"startColumn":15,"endLine":6,"endColumn":19,"description":"Cannot call `acceptsSymbol` with `false` bound to `value` because boolean [1] is incompatible with symbol [2]. [incompatible-type]"}]',children:"function acceptsSymbol(value: symbol) { /* ... */ }\n\nacceptsSymbol(Symbol()); // Works!\nacceptsSymbol(Symbol.isConcatSpreadable); // Works!\n\nacceptsSymbol(false); // Error!\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can ",(0,i.jsx)(n.a,{href:"../../lang/refinements/",children:"refine"})," a value to ",(0,i.jsx)(n.code,{children:"symbol"})," using a ",(0,i.jsx)(n.code,{children:"typeof"})," check:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function acceptsSymbol(value: symbol) { /* ... */ }\n\nfunction func(value: mixed) {\n  if (typeof value === 'symbol') {\n    acceptsSymbol(value); // Works: `value` is `symbol`\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"toc-bigints",children:"BigInts"}),"\n",(0,i.jsxs)(n.p,{children:["BigInts can be used to represent integers of arbitrary precision. In other words, they can store integers which are too large to store as a ",(0,i.jsx)(n.code,{children:"number"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"bigint"})," literal is just a ",(0,i.jsx)(n.code,{children:"number"})," literal along with an ",(0,i.jsx)(n.code,{children:"n"})," suffix."]}),"\n",(0,i.jsxs)(n.p,{children:["Note that ",(0,i.jsx)(n.code,{children:"bigint"})," and ",(0,i.jsx)(n.code,{children:"number"})," are incompatible types. That is, a ",(0,i.jsx)(n.code,{children:"bigint"})," cannot be used where a ",(0,i.jsx)(n.code,{children:"number"})," is expected, and vice versa."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":4,"startColumn":15,"endLine":4,"endColumn":16,"description":"Cannot call `acceptsBigInt` with `42` bound to `value` because number [1] is incompatible with bigint [2]. [incompatible-type]"}]',children:"function acceptsBigInt(value: bigint) { /* ... */ }\n\nacceptsBigInt(42n); // Works!\nacceptsBigInt(42); // Error!\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can ",(0,i.jsx)(n.a,{href:"../../lang/refinements/",children:"refine"})," a value to ",(0,i.jsx)(n.code,{children:"bigint"})," using a ",(0,i.jsx)(n.code,{children:"typeof"})," check:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function acceptsBigInt(value: bigint) { /* ... */ }\n\nfunction func(value: mixed) {\n  if (typeof value === 'bigint') {\n    acceptsBigInt(value); // Works: `value` is `bigint`\n  }\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);