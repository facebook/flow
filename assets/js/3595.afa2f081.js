"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[3595],{13595:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"types/generics","title":"Generics","description":"Generics (sometimes referred to as polymorphic types) are a way of abstracting","source":"@site/docs/types/generics.md","sourceDirName":"types","slug":"/types/generics","permalink":"/en/docs/types/generics","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/types/generics.md","tags":[],"version":"current","frontMatter":{"title":"Generics","slug":"/types/generics"},"sidebar":"docsSidebar","previous":{"title":"Interfaces","permalink":"/en/docs/types/interfaces"},"next":{"title":"Unions","permalink":"/en/docs/types/unions"}}');var r=t(74848),s=t(28453);const a={title:"Generics",slug:"/types/generics"},o=void 0,c={},l=[{value:"Syntax of generics",id:"toc-syntax-of-generics",level:3},{value:"Functions with generics",id:"toc-functions-with-generics",level:3},{value:"Function types with generics",id:"toc-function-types-with-generics",level:3},{value:"Classes with generics",id:"toc-classes-with-generics",level:3},{value:"Type aliases with generics",id:"toc-type-aliases-with-generics",level:3},{value:"Interfaces with generics",id:"toc-interfaces-with-generics",level:3},{value:"Supplying Type Arguments to Callables",id:"toc-supplying-type-arguments-to-callables",level:3},{value:"Behavior of generics",id:"toc-behavior-of-generics",level:2},{value:"Generics act like variables",id:"toc-generics-act-like-variables",level:3},{value:"Create as many generics as you need",id:"toc-create-as-many-generics-as-you-need",level:3},{value:"Generics track values around",id:"toc-generics-track-values-around",level:3},{value:"Adding types to generics",id:"toc-adding-types-to-generics",level:3},{value:"Generic types act as bounds",id:"toc-generic-types-act-as-bounds",level:3},{value:"Parameterized generics",id:"toc-parameterized-generics",level:3},{value:"Adding defaults to parameterized generics",id:"toc-adding-defaults-to-parameterized-generics",level:3},{value:"Variance Sigils",id:"toc-variance-sigils",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Generics (sometimes referred to as polymorphic types) are a way of abstracting\na type away."}),"\n",(0,r.jsxs)(n.p,{children:["Imagine writing the following ",(0,r.jsx)(n.code,{children:"identity"})," function which returns whatever value\nwas passed."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function identity(value) {\n  return value;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"We would have a lot of trouble trying to write specific types for this function\nsince it could be anything."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function identity(value: string): string {\n  return value;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Instead we can create a generic (or polymorphic type) in our function and use\nit in place of other types."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function identity<T>(value: T): T {\n  return value;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Generics can be used within functions, function types, classes, type aliases,\nand interfaces."}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Warning:"})," Flow does not infer generic types. If you want something to have a\ngeneric type, ",(0,r.jsx)(n.strong,{children:"annotate it"}),". Otherwise, Flow may infer a type that is less\npolymorphic than you expect."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"toc-syntax-of-generics",children:"Syntax of generics"}),"\n",(0,r.jsx)(n.p,{children:"There are a number of different places where generic types appear in syntax."}),"\n",(0,r.jsx)(n.h3,{id:"toc-functions-with-generics",children:"Functions with generics"}),"\n",(0,r.jsxs)(n.p,{children:["Functions can create generics by adding the type parameter list ",(0,r.jsx)(n.code,{children:"<T>"})," before\nthe function parameter list."]}),"\n",(0,r.jsx)(n.p,{children:"You can use generics in the same places you'd add any other type in a function\n(parameter or return types)."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function method<T>(param: T): T {\n  return param;\n}\n\nconst f = function<T>(param: T): T {\n  return param;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"toc-function-types-with-generics",children:"Function types with generics"}),"\n",(0,r.jsxs)(n.p,{children:["Function types can create generics in the same way as normal functions, by\nadding the type parameter list ",(0,r.jsx)(n.code,{children:"<T>"})," before the function type parameter list."]}),"\n",(0,r.jsx)(n.p,{children:"You can use generics in the same places you'd add any other type in a function\ntype (parameter or return types)."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"<T>(param: T) => T\n"})}),"\n",(0,r.jsx)(n.p,{children:"Which then gets used as its own type."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function method(func: <T>(param: T) => T) {\n  // ...\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"toc-classes-with-generics",children:"Classes with generics"}),"\n",(0,r.jsx)(n.p,{children:"Classes can create generics by placing the type parameter list before the body\nof the class."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"class Item<T> {\n  // ...\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"You can use generics in the same places you'd add any other type in a class\n(property types and method parameter/return types)."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"class Item<T> {\n  prop: T;\n\n  constructor(param: T) {\n    this.prop = param;\n  }\n\n  method(): T {\n    return this.prop;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"toc-type-aliases-with-generics",children:"Type aliases with generics"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type Item<T> = {\n  foo: T,\n  bar: T,\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"toc-interfaces-with-generics",children:"Interfaces with generics"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"interface Item<T> {\n  foo: T,\n  bar: T,\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"toc-supplying-type-arguments-to-callables",children:"Supplying Type Arguments to Callables"}),"\n",(0,r.jsx)(n.p,{children:"You can give callable entities type arguments for their generics directly in the call:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function doSomething<T>(param: T): T {\n  // ...\n  return param;\n}\n\ndoSomething<number>(3);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You can also give generic classes type arguments directly in the ",(0,r.jsx)(n.code,{children:"new"})," expression:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"class GenericClass<T> {}\nconst c = new GenericClass<number>();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If you only want to specify some of the type arguments, you can use ",(0,r.jsx)(n.code,{children:"_"})," to let flow infer a type for you:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"class GenericClass<T, U=string, V=number>{}\nconst c = new GenericClass<boolean, _, string>();\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Warning:"})," For performance purposes, we always recommend you annotate with\nconcrete arguments when you can. ",(0,r.jsx)(n.code,{children:"_"})," is not unsafe, but it is slower than explicitly\nspecifying the type arguments."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"toc-behavior-of-generics",children:"Behavior of generics"}),"\n",(0,r.jsx)(n.h3,{id:"toc-generics-act-like-variables",children:"Generics act like variables"}),"\n",(0,r.jsx)(n.p,{children:"Generic types work a lot like variables or function parameters except that they\nare used for types. You can use them whenever they are in scope."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function constant<T>(value: T): () => T {\n  return function(): T {\n    return value;\n  };\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"toc-create-as-many-generics-as-you-need",children:"Create as many generics as you need"}),"\n",(0,r.jsx)(n.p,{children:"You can have as many of these generics as you need in the type parameter list,\nnaming them whatever you want:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function identity<One, Two, Three>(one: One, two: Two, three: Three) {\n  // ...\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"toc-generics-track-values-around",children:"Generics track values around"}),"\n",(0,r.jsx)(n.p,{children:"When using a generic type for a value, Flow will track the value and make sure\nthat you aren't replacing it with something else."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":2,"startColumn":10,"endLine":2,"endColumn":14,"description":"Cannot return `\\"foo\\"` because string [1] is incompatible with `T` [2]. [incompatible-type]"},{"startLine":5,"startColumn":10,"endLine":5,"endColumn":17,"description":"Cannot declare `identity` [1] because the name is already bound. [name-already-bound]"},{"startLine":6,"startColumn":11,"endLine":6,"endColumn":15,"description":"Cannot assign `\\"foo\\"` to `value` because string [1] is incompatible with `T` [2]. [incompatible-type]"},{"startLine":7,"startColumn":10,"endLine":7,"endColumn":14,"description":"Cannot return `value` because string [1] is incompatible with `T` [2]. [incompatible-type]"}]',children:'function identity<T>(value: T): T {\n  return "foo"; // Error!\n}\n\nfunction identity<T>(value: T): T {\n  value = "foo"; // Error!\n  return value;  // Error!\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Flow tracks the specific type of the value you pass through a generic, letting\nyou use it later."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":7,"startColumn":16,"endLine":7,"endColumn":27,"description":"Cannot assign `identity(...)` to `three` because number literal `42` [1] is incompatible with number literal `3` [2]. [incompatible-type]"}]',children:"function identity<T>(value: T): T {\n  return value;\n}\n\nlet one: 1 = identity(1);\nlet two: 2 = identity(2);\nlet three: 3 = identity(42); // Error\n"})}),"\n",(0,r.jsx)(n.h3,{id:"toc-adding-types-to-generics",children:"Adding types to generics"}),"\n",(0,r.jsxs)(n.p,{children:["Similar to  ",(0,r.jsx)(n.code,{children:"mixed"}),', generics have an "unknown" type. You\'re not allowed to use\na generic as if it were a specific type.']}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":2,"startColumn":19,"endLine":2,"endColumn":21,"description":"Cannot get `obj.foo` because property `foo` is missing in mixed [1]. [incompatible-use]"}]',children:"function logFoo<T>(obj: T): T {\n  console.log(obj.foo); // Error!\n  return obj;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"You could refine the type, but the generic will still allow any type to be\npassed in."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function logFoo<T>(obj: T): T {\n  if (obj && obj.foo) {\n    console.log(obj.foo); // Works.\n  }\n  return obj;\n}\n\nlogFoo({ foo: 'foo', bar: 'bar' });  // Works.\nlogFoo({ bar: 'bar' }); // Works. :(\n"})}),"\n",(0,r.jsx)(n.p,{children:"Instead, you could add a type to your generic like you would with a function\nparameter."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":7,"startColumn":8,"endLine":7,"endColumn":21,"description":"Cannot call `logFoo` because property `foo` is missing in object literal [1] but exists in object type [2] in type argument `T`. [incompatible-type]"}]',children:"function logFoo<T: {foo: string, ...}>(obj: T): T {\n  console.log(obj.foo); // Works!\n  return obj;\n}\n\nlogFoo({ foo: 'foo', bar: 'bar' });  // Works!\nlogFoo({ bar: 'bar' }); // Error!\n"})}),"\n",(0,r.jsx)(n.p,{children:"This way you can keep the behavior of generics while only allowing certain\ntypes to be used."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":7,"startColumn":31,"endLine":7,"endColumn":37,"description":"Cannot call `identity` because string [1] is incompatible with number [2] in type argument `T`. [incompatible-type]"}]',children:'function identity<T: number>(value: T): T {\n  return value;\n}\n\nlet one: 1 = identity(1);\nlet two: 2 = identity(2);\nlet three: "three" = identity("three"); // Error!\n'})}),"\n",(0,r.jsx)(n.h3,{id:"toc-generic-types-act-as-bounds",children:"Generic types act as bounds"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function identity<T>(val: T): T {\n  return val;\n}\n\nlet foo: 'foo' = 'foo';           // Works!\nlet bar: 'bar' = identity('bar'); // Works!\n"})}),"\n",(0,r.jsx)(n.p,{children:'In Flow, most of the time when you pass one type into another you lose the\noriginal type. So that when you pass a specific type into a less specific one\nFlow "forgets" it was once something more specific.'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":6,"startColumn":18,"endLine":6,"endColumn":32,"description":"Cannot assign `identity(...)` to `bar` because string [1] is incompatible with string literal `bar` [2]. [incompatible-type]"}]',children:"function identity(val: string): string {\n  return val;\n}\n\nlet foo: 'foo' = 'foo';           // Works!\nlet bar: 'bar' = identity('bar'); // Error!\n"})}),"\n",(0,r.jsx)(n.p,{children:'Generics allow you to hold onto the more specific type while adding a\nconstraint. In this way types on generics act as "bounds".'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function identity<T: string>(val: T): T {\n  return val;\n}\n\nlet foo: 'foo' = 'foo';           // Works!\nlet bar: 'bar' = identity('bar'); // Works!\n"})}),"\n",(0,r.jsx)(n.p,{children:"Note that when you have a value with a bound generic type, you can't use it as\nif it were a more specific type."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":21,"endLine":3,"endColumn":23,"description":"Cannot assign `val` to `bar` because string [1] is incompatible with string literal `bar` [2]. [incompatible-type]"}]',children:"function identity<T: string>(val: T): T {\n  let str: string = val; // Works!\n  let bar: 'bar'  = val; // Error!\n  return val;\n}\n\nidentity('bar');\n"})}),"\n",(0,r.jsx)(n.h3,{id:"toc-parameterized-generics",children:"Parameterized generics"}),"\n",(0,r.jsx)(n.p,{children:"Generics sometimes allow you to pass types in like arguments to a function.\nThese are known as parameterized generics (or parametric polymorphism)."}),"\n",(0,r.jsx)(n.p,{children:"For example, a type alias with a generic is parameterized. When you go to use\nit you will have to provide a type argument."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'type Item<T> = {\n  prop: T,\n}\n\nlet item: Item<string> = {\n  prop: "value"\n};\n'})}),"\n",(0,r.jsx)(n.p,{children:"You can think of this like passing arguments to a function, only the return\nvalue is a type that you can use."}),"\n",(0,r.jsx)(n.p,{children:"Classes (when being used as a type), type aliases, and interfaces all require\nthat you pass type arguments. Functions and function types do not have\nparameterized generics."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"Classes"})})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":9,"startColumn":12,"endLine":9,"endColumn":15,"description":"Cannot use `Item` [1] without 1 type argument. [missing-type-arg]"}]',children:"class Item<T> {\n  prop: T;\n  constructor(param: T) {\n    this.prop = param;\n  }\n}\n\nlet item1: Item<number> = new Item(42); // Works!\nlet item2: Item = new Item(42); // Error!\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"Type Aliases"})})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":6,"startColumn":12,"endLine":6,"endColumn":15,"description":"Cannot use `Item` [1] without 1 type argument. [missing-type-arg]"}]',children:"type Item<T> = {\n  prop: T,\n};\n\nlet item1: Item<number> = { prop: 42 }; // Works!\nlet item2: Item = { prop: 42 }; // Error!\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"Interfaces"})})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":10,"startColumn":19,"endLine":10,"endColumn":25,"description":"Cannot use `HasProp` [1] without 1 type argument. [missing-type-arg]"}]',children:"interface HasProp<T> {\n  prop: T,\n}\n\nclass Item {\n  prop: string;\n}\n\nItem.prototype as HasProp<string>; // Works!\nItem.prototype as HasProp; // Error!\n"})}),"\n",(0,r.jsx)(n.h3,{id:"toc-adding-defaults-to-parameterized-generics",children:"Adding defaults to parameterized generics"}),"\n",(0,r.jsx)(n.p,{children:"You can also provide defaults for parameterized generics just like parameters\nof a function."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type Item<T: number = 1> = {\n  prop: T,\n};\n\nlet foo: Item<> = { prop: 1 };\nlet bar: Item<2> = { prop: 2 };\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You must always include the brackets ",(0,r.jsx)(n.code,{children:"<>"})," when using the type (just like\nparentheses for a function call)."]}),"\n",(0,r.jsx)(n.h3,{id:"toc-variance-sigils",children:"Variance Sigils"}),"\n",(0,r.jsxs)(n.p,{children:["You can also specify the subtyping behavior of a generic via variance sigils.\nBy default, generics behave invariantly, but you may add a ",(0,r.jsx)(n.code,{children:"+"})," to their\ndeclaration to make them behave covariantly, or a ",(0,r.jsx)(n.code,{children:"-"})," to their declaration to\nmake them behave contravariantly. See ",(0,r.jsx)(n.a,{href:"../../lang/variance",children:"our docs on variance"}),"\nfor a more information on variance in Flow."]}),"\n",(0,r.jsx)(n.p,{children:"Variance sigils allow you to be more specific about how you intend to\nuse your generics, giving Flow the power to do more precise type checking.\nFor example, you may want this relationship to hold:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type GenericBox<+T> = T;\n\nconst x: GenericBox<number> = 3;\nx as GenericBox<number| string>;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The example above could not be accomplished without the ",(0,r.jsx)(n.code,{children:"+"})," variance sigil:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":4,"startColumn":1,"endLine":4,"endColumn":1,"description":"Cannot cast `x` to `GenericBoxError` because string [1] is incompatible with number [2] in type argument `T` [3]. [incompatible-type]"}]',children:"type GenericBoxError<T> = T;\n\nconst x: GenericBoxError<number> = 3;\nx as GenericBoxError<number| string>; // number | string is not compatible with number.\n"})}),"\n",(0,r.jsx)(n.p,{children:"Note that if you annotate your generic with variance sigils then Flow will\ncheck to make sure those types only appear in positions that make sense for\nthat variance sigil. For example, you cannot declare a generic type parameter\nto behave covariantly and use it in a contravariant position:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":1,"startColumn":34,"endLine":1,"endColumn":34,"description":"Cannot use `T` [1] in an input position because `T` [1] is expected to occur only in output positions. [incompatible-variance]"}]',children:"type NotActuallyCovariant<+T> = (T) => void;\n"})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(96540);const r={},s=i.createContext(r);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);