"use strict";(globalThis.webpackChunknew_website=globalThis.webpackChunknew_website||[]).push([[2433],{22433(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"cli/annotate-exports","title":"Flow Annotate-Exports","description":"Upgrading to Types-First mode may require a substantial","source":"@site/docs/cli/annotate-exports.md","sourceDirName":"cli","slug":"/cli/annotate-exports","permalink":"/en/docs/cli/annotate-exports","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/cli/annotate-exports.md","tags":[],"version":"current","frontMatter":{"title":"Flow Annotate-Exports","slug":"/cli/annotate-exports"},"sidebar":"docsSidebar","previous":{"title":"Flow Coverage","permalink":"/en/docs/cli/coverage"},"next":{"title":".flowconfig","permalink":"/en/docs/config"}}');var i=t(74848),s=t(28453);const r={title:"Flow Annotate-Exports",slug:"/cli/annotate-exports"},a=void 0,l={},d=[{value:"How to apply the codemod",id:"toc-how-to-apply-the-codemod",level:3},{value:"Codemod output",id:"toc-codemod-output",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Upgrading to ",(0,i.jsx)(n.a,{href:"../../lang/types-first",children:"Types-First"})," mode may require a substantial\nnumber of type annotations at module boundaries. To help with the process of\nupgrading large codebases, we are providing a codemod command, whose goal is to\nfill in these missing annotations. This command is included in the Flow binary\nin versions ",(0,i.jsx)(n.code,{children:">= 0.125"}),"."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Note: As of version 0.134, types-first is the default mode. If you are using a\nversion ",(0,i.jsx)(n.code,{children:">=0.134"}),", make sure you set ",(0,i.jsx)(n.code,{children:"types_first=false"})," in your .flowconfig while\nrunning this codemod."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["This command uses types that Flow infers, to fill in positions that would otherwise\nraise ",(0,i.jsx)(n.em,{children:"signature-verification"})," failures. It will include the necessary type import\nstatements, as long as the respective types are exported from their defining modules."]}),"\n",(0,i.jsx)(n.p,{children:"It is designed for use on multiple files at once, rather than one file at a time.\nFor this reason it doesn't connect to an existing Flow server, but rather starts\na checking process of its own."}),"\n",(0,i.jsx)(n.p,{children:"As is typical with such mechanized approaches, it comes with a few caveats:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"It won\u2019t be able to fill in every required type annotation. Some cases will\nrequire manual effort."}),"\n",(0,i.jsx)(n.li,{children:"Inserted annotations may cause new flow errors, since it\u2019s not always possible\nto match inferred type with types that can be written as annotations."}),"\n",(0,i.jsx)(n.li,{children:"File formatting may be affected. If a code formatter (e.g. prettier) is used,\nit is recommended that you run it after the codemod has finished running."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"toc-how-to-apply-the-codemod",children:"How to apply the codemod"}),"\n",(0,i.jsx)(n.p,{children:"A typical way to invoke this command is"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"flow codemod annotate-exports \\\n  --write \\\n  --repeat \\\n  --log-level info \\\n  /path/to/folder \\\n  2> out.log\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This command will transform files under ",(0,i.jsx)(n.code,{children:"/path/to/folder"}),". This does not need to\nbe the root directory (the one containing ",(0,i.jsx)(n.code,{children:".flowconfig"}),")."]}),"\n",(0,i.jsx)(n.p,{children:"It uses the following flags:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"--write"})," will update files that require annotations under ",(0,i.jsx)(n.code,{children:"/path/to/folder"}),"\nin-place. Without this flag the resulting files will be printed on the command line."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"--repeat"})," ensures that the transformation will be applied until no more files\nchange. This mode is necessary here, because each new type the codemod adds may\nrequire new locations to be annotated."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"--log-level info"})," outputs useful debugging information in the standard error stream.\nThis option might lead to verbose output, so we're redirecting the error output\nto a log file ",(0,i.jsx)(n.code,{children:"out.log"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Another convenient way to provide the input is by passing the flag"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"--input-file file.txt\n"})}),"\n",(0,i.jsxs)(n.p,{children:["where ",(0,i.jsx)(n.code,{children:"file.txt"})," contains a specific list of files to be transformed."]}),"\n",(0,i.jsx)(n.h3,{id:"toc-codemod-output",children:"Codemod output"}),"\n",(0,i.jsx)(n.p,{children:"After each iteration of the codemod, a summary will be printed on the CLI. This\nsummary includes statistical information about the number of annotations that were\nadded, and how many locations were skipped. It also prints counts for various kinds\nof errors that were encountered. These can be matched to the errors printed in the\nlogs."}),"\n",(0,i.jsxs)(n.p,{children:["A common error case is when a type ",(0,i.jsx)(n.code,{children:"A"}),", defined in a file ",(0,i.jsx)(n.code,{children:"a.js"}),", but not exported,\nis inferred in file ",(0,i.jsx)(n.code,{children:"b.js"}),". The codemod will skip adding this annotation and report\nan error in the logs. The fix this case, you can export ",(0,i.jsx)(n.code,{children:"A"})," in ",(0,i.jsx)(n.code,{children:"a.js"}),". Note that\nit is not necessary to manually import ",(0,i.jsx)(n.code,{children:"A"})," in ",(0,i.jsx)(n.code,{children:"b.js"}),". The codemod will do this\nautomatically."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453(e,n,t){t.d(n,{R:()=>r,x:()=>a});var o=t(96540);const i={},s=o.createContext(i);function r(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);