"use strict";(globalThis.webpackChunknew_website=globalThis.webpackChunknew_website||[]).push([[195],{50195(e,n,s){s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"types/classes","title":"Classes","description":"JavaScript classes","source":"@site/docs/types/classes.md","sourceDirName":"types","slug":"/types/classes","permalink":"/en/docs/types/classes","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/types/classes.md","tags":[],"version":"current","frontMatter":{"title":"Classes","slug":"/types/classes"},"sidebar":"docsSidebar","previous":{"title":"Tuples","permalink":"/en/docs/types/tuples"},"next":{"title":"Type Aliases","permalink":"/en/docs/types/aliases"}}');var a=s(74848),r=s(28453);const o={title:"Classes",slug:"/types/classes"},i=void 0,l={},c=[{value:"Class Syntax",id:"toc-class-syntax",level:2},{value:"Class Methods",id:"toc-class-methods",level:3},{value:"Class Fields (Properties)",id:"toc-class-fields-properties",level:3},{value:"Extending classes and implementing interfaces",id:"extending-classes-and-implementing-interfaces",level:3},{value:"Class Constructors",id:"toc-class-fields-constructors",level:3},{value:"Class Generics",id:"toc-class-generics",level:3},{value:"Classes in annotations",id:"toc-classes-in-annotations",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["JavaScript ",(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes",children:"classes"}),"\nin Flow operate both as a value and a type. You can use the name of the class as the type of its instances:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"class MyClass {\n  // ...\n}\n\nconst myInstance: MyClass = new MyClass(); // Works!\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This is because classes in Flow are ",(0,a.jsx)(n.a,{href:"../../lang/nominal-structural",children:"nominally typed"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"This means two classes with identical shapes are not compatible:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":7,"startColumn":16,"endLine":7,"endColumn":22,"description":"Cannot assign `new A()` to `foo` because `A` [1] is incompatible with `B` [2]. [incompatible-type]"},{"startLine":8,"startColumn":16,"endLine":8,"endColumn":22,"description":"Cannot assign `new B()` to `bar` because `B` [1] is incompatible with `A` [2]. [incompatible-type]"}]',children:"class A {\n  x: number;\n}\nclass B {\n  x: number;\n}\nconst foo: B = new A(); // Error!\nconst bar: A = new B(); // Error!\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You also cannot use an ",(0,a.jsx)(n.a,{href:"../objects",children:"object type"})," to describe an instance of a class:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":4,"startColumn":31,"endLine":4,"endColumn":43,"description":"Cannot assign `new MyClass()` to `foo` because `MyClass` [1] is not a subtype of object type [2]. Class instances are not subtypes of object types; consider rewriting object type [2] as an interface. [class-object-subtyping]"}]',children:"class MyClass {\n  x: number;\n}\nconst foo: {x: number, ...} = new MyClass(); // Error!\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You can use ",(0,a.jsx)(n.a,{href:"../interfaces",children:"interfaces"})," to accomplish this instead:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"class A {\n  x: number;\n}\nclass B {\n  x: number;\n}\n\ninterface WithXNum {\n  x: number;\n}\n\nconst foo: WithXNum = new A(); // Works!\nconst bar: WithXNum = new B(); // Works!\n\nconst n: number = foo.x; // Works!\n"})}),"\n",(0,a.jsx)(n.h2,{id:"toc-class-syntax",children:"Class Syntax"}),"\n",(0,a.jsx)(n.p,{children:"Classes in Flow are just like normal JavaScript classes, but with added types."}),"\n",(0,a.jsx)(n.h3,{id:"toc-class-methods",children:"Class Methods"}),"\n",(0,a.jsxs)(n.p,{children:["Just like in ",(0,a.jsx)(n.a,{href:"../functions",children:"functions"}),", class methods can have annotations for both parameters\n(input) and returns (output):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"class MyClass {\n  method(value: string): number {\n    return 0;\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Also just like regular functions, class methods may have ",(0,a.jsx)(n.code,{children:"this"})," annotations as well.\nHowever, if one is not provided, Flow will infer the class instance type (or the class type for static methods)\ninstead of ",(0,a.jsx)(n.code,{children:"mixed"}),". When an explicit ",(0,a.jsx)(n.code,{children:"this"})," parameter is provided, it must be a ",(0,a.jsx)(n.a,{href:"../../lang/subtypes/",children:"supertype"})," of\nthe class instance type (or class type for static methods)."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":2,"startColumn":3,"endLine":2,"endColumn":8,"description":"Cannot define method `method` [1] on `MyClass` because property `x` is missing in `MyClass` [2] but exists in interface type [3]. [incompatible-type]"}]',children:"class MyClass {\n  method(this: interface {x: string}) { /* ... */ } // Error!\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Unlike class properties, however, class methods cannot be unbound or rebound from\nthe class on which you defined them. So all of the following are errors in Flow:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":3,"endLine":3,"endColumn":8,"description":"Cannot get `a.method` because property `method` [1] cannot be unbound from the context [2] where it was defined. [method-unbinding]"},{"startLine":4,"startColumn":8,"endLine":4,"endColumn":13,"description":"property `method` [1] cannot be unbound from the context [2] where it was defined. [method-unbinding]"},{"startLine":5,"startColumn":3,"endLine":5,"endColumn":8,"description":"Cannot get `a.method` because property `method` [1] cannot be unbound from the context [2] where it was defined. [method-unbinding]"}]',children:"class MyClass { method() {} }\nconst a = new MyClass();\na.method; // Error!\nconst {method} = a; // Error!\na.method.bind({}); // Error!\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Methods are considered ",(0,a.jsx)(n.a,{href:"../../lang/variance",children:"read-only"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":6,"startColumn":3,"endLine":6,"endColumn":8,"description":"Cannot assign function to `a.method` because property `method` is not writable. [cannot-write]"}]',children:"class MyClass {\n  method() {}\n}\n\nconst a = new MyClass();\na.method = function() {}; // Error!\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Flow supports ",(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields",children:"private methods"}),",\na feature of ES2022. Private methods start with a hash symbol ",(0,a.jsx)(n.code,{children:"#"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":11,"startColumn":3,"endLine":11,"endColumn":17,"description":"Private fields can only be referenced from within a class. [ParseError]"}]',children:"class MyClass {\n  #internalMethod() {\n    return 1;\n  }\n  publicApi() {\n    return this.#internalMethod();\n  }\n}\n\nconst a = new MyClass();\na.#internalMethod(); // Error!\na.publicApi(); // Works!\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Flow requires return type annotations on methods in most cases.\nThis is because it is common to reference ",(0,a.jsx)(n.code,{children:"this"})," inside of a method, and ",(0,a.jsx)(n.code,{children:"this"})," is typed as the instance of the class -\nbut to know the type of the class we need to know the return type of its methods!"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":2,"startColumn":8,"endLine":2,"endColumn":7,"description":"Missing an annotation on return. [missing-local-annot]"},{"startLine":5,"startColumn":8,"endLine":5,"endColumn":7,"description":"Missing an annotation on return. [missing-local-annot]"}]',children:"class MyClass {\n  foo() { // Error!\n    return this.bar();\n  }\n  bar() { // Error!\n    return 1;\n  }\n}\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"class MyClassFixed {\n  foo(): number { // Works!\n    return this.bar();\n  }\n  bar(): number { // Works!\n    return 1;\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"toc-class-fields-properties",children:"Class Fields (Properties)"}),"\n",(0,a.jsx)(n.p,{children:"Whenever you want to use a class field in Flow you must first give it an\nannotation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":10,"endLine":3,"endColumn":13,"description":"Cannot assign `42` to `this.prop` because property `prop` is missing in `MyClass` [1]. [prop-missing]"}]',children:"class MyClass {\n  method() {\n    this.prop = 42; // Error!\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Fields are annotated within the body of the class with the field name followed\nby a colon ",(0,a.jsx)(n.code,{children:":"})," and the type:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"class MyClass {\n  prop: number;\n  method() {\n    this.prop = 42;\n  }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Fields added outside of the class definition need to be annotated within the body\nof the class:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function func(x: number): number {\n  return x + 1;\n}\n\nclass MyClass {\n  static constant: number;\n  static helper: (number) => number;\n  prop: number => number;\n}\nMyClass.helper = func\nMyClass.constant = 42\nMyClass.prototype.prop = func\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Flow also supports using the ",(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#field_declarations",children:"class properties syntax"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"class MyClass {\n  prop = 42;\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"When using this syntax, you are not required to give it a type annotation. But\nyou still can if you need to:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"class MyClass {\n  prop: number = 42;\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You can mark a class field as read-only (or write-only) using ",(0,a.jsx)(n.a,{href:"../../lang/variance",children:"variance"})," annotations.\nThese can only be written to in the constructor:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":9,"startColumn":10,"endLine":9,"endColumn":13,"description":"Cannot assign `1` to `this.prop` because property `prop` is not writable. [cannot-write]"},{"startLine":15,"startColumn":3,"endLine":15,"endColumn":6,"description":"Cannot assign `1` to `a.prop` because property `prop` is not writable. [cannot-write]"}]',children:"class MyClass {\n  +prop: number;\n\n  constructor() {\n    this.prop = 1; // Works!\n  }\n\n  method() {\n    this.prop = 1; // Error!\n  }\n}\n\nconst a = new MyClass();\nconst n: number = a.prop; // Works!\na.prop = 1; // Error!\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Flow supports ",(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields",children:"private fields"}),",\na feature of ES2022. Private fields start with a hash symbol ",(0,a.jsx)(n.code,{children:"#"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":14,"startColumn":21,"endLine":14,"endColumn":34,"description":"Private fields can only be referenced from within a class. [ParseError]"}]',children:"class MyClass {\n  #internalValue: number;\n\n  constructor() {\n    this.#internalValue = 1;\n  }\n\n  publicApi() {\n    return this.#internalValue;\n  }\n}\n\nconst a = new MyClass();\nconst x: number = a.#internalValue; // Error!\nconst y: number = a.publicApi(); // Works!\n"})}),"\n",(0,a.jsx)(n.h3,{id:"extending-classes-and-implementing-interfaces",children:"Extending classes and implementing interfaces"}),"\n",(0,a.jsxs)(n.p,{children:["You can optionally ",(0,a.jsx)(n.code,{children:"extend"})," one other class:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"class Base {\n  x: number;\n}\n\nclass MyClass extends Base {\n  y: string;\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["And also implement multiple ",(0,a.jsx)(n.a,{href:"../interfaces",children:"interfaces"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"interface WithXNum {\n  x: number;\n}\ninterface Readable {\n  read(): string;\n}\n\nclass MyClass implements WithXNum, Readable {\n  x: number;\n  read(): string {\n    return String(this.x);\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You don't need to ",(0,a.jsx)(n.code,{children:"implement"})," an interface to be a subtype of it, but doing so enforces that your class meets the requirements:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":5,"startColumn":7,"endLine":5,"endColumn":13,"description":"Cannot implement `WithXNum` [1] with `MyClass` because property `x` is missing in `MyClass` [2] but exists in `WithXNum` [1]. [incompatible-type]"}]',children:"interface WithXNum {\n  x: number;\n}\n\nclass MyClass implements WithXNum { // Error!\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"toc-class-fields-constructors",children:"Class Constructors"}),"\n",(0,a.jsx)(n.p,{children:"You can initialize your class properties in class constructors:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"class MyClass {\n  foo: number;\n\n  constructor() {\n    this.foo = 1;\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You must first call ",(0,a.jsx)(n.code,{children:"super(...)"})," in a derived class before you can access ",(0,a.jsx)(n.code,{children:"this"})," and ",(0,a.jsx)(n.code,{children:"super"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":9,"startColumn":5,"endLine":9,"endColumn":8,"description":"Must call `super` before accessing `this` [1] in a derived constructor. [reference-before-declaration]"},{"startLine":10,"startColumn":5,"endLine":10,"endColumn":8,"description":"Must call `super` before accessing `this` [1] in a derived constructor. [reference-before-declaration]"},{"startLine":11,"startColumn":5,"endLine":11,"endColumn":9,"description":"Must call `super` before accessing `super` [1] in a derived constructor. [reference-before-declaration]"}]',children:"class Base {\n  bar: number;\n}\n\nclass MyClass extends Base {\n  foo: number;\n\n  constructor() {\n    this.foo; // Error\n    this.bar; // Error\n    super.bar; // Error\n    super();\n    this.foo; // OK\n    this.bar; // OK\n    super.bar; // OK\n  }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"However, Flow will not enforce that all class properties are initialized in constructors:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"class MyClass {\n  foo: number;\n  bar: number;\n\n  constructor() {\n    this.foo = 1;\n  }\n\n  useBar() {\n    (this.bar: number); // No errors.\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"toc-class-generics",children:"Class Generics"}),"\n",(0,a.jsxs)(n.p,{children:["Classes can also have their own ",(0,a.jsx)(n.a,{href:"../generics",children:"generics"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"class MyClass<A, B, C> {\n  property: A;\n  method(val: B): C {\n    throw new Error();\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Class generics are ",(0,a.jsx)(n.a,{href:"../generics#toc-parameterized-generics",children:"parameterized"}),".\nWhen you use a class as a type you need to pass parameters for each of its\ngenerics:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"class MyClass<A, B, C> {\n  constructor(arg1: A, arg2: B, arg3: C) {\n    // ...\n  }\n}\n\nconst val: MyClass<number, boolean, string> = new MyClass(1, true, 'three');\n"})}),"\n",(0,a.jsx)(n.h2,{id:"toc-classes-in-annotations",children:"Classes in annotations"}),"\n",(0,a.jsxs)(n.p,{children:["When you use the name of your class in an annotation, it means an ",(0,a.jsx)(n.em,{children:"instance"})," of your class:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"class MyClass {}\n\nconst b: MyClass = new MyClass(); // Works!\nconst a: MyClass = MyClass; // Error!\n"})}),"\n",(0,a.jsxs)(n.p,{children:["See ",(0,a.jsx)(n.a,{href:"../utilities#toc-class",children:"here"})," for details on ",(0,a.jsx)(n.code,{children:"Class<T>"}),", which allows you\nto refer to the type of the class in an annotation."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453(e,n,s){s.d(n,{R:()=>o,x:()=>i});var t=s(96540);const a={},r=t.createContext(a);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);