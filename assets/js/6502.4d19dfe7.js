"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[6502],{26502:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"match/patterns","title":"Match Patterns","description":"Match patterns both define a condition that must be matched, and new variables that are extracted (like destructuring).","source":"@site/docs/match/patterns.md","sourceDirName":"match","slug":"/match/patterns","permalink":"/en/docs/match/patterns","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/match/patterns.md","tags":[],"version":"current","frontMatter":{"title":"Match Patterns","description":"Match patterns both define a condition that must be matched, and new variables that are extracted (like destructuring).","slug":"/match/patterns"},"sidebar":"docsSidebar","previous":{"title":"Match Expressions and Statements","permalink":"/en/docs/match"},"next":{"title":"Migration from existing patterns","permalink":"/en/docs/match/migration"}}');var r=a(74848),s=a(28453);const i={title:"Match Patterns",description:"Match patterns both define a condition that must be matched, and new variables that are extracted (like destructuring).",slug:"/match/patterns"},c=void 0,o={},l=[{value:"Primitive value patterns",id:"primitive-value-patterns",level:2},{value:"Wildcard patterns",id:"wildcard-patterns",level:2},{value:"Variable declaration patterns",id:"variable-declaration-patterns",level:2},{value:"Object patterns",id:"object-patterns",level:2},{value:"Array patterns",id:"array-patterns",level:2},{value:"\u201cOr\u201d patterns",id:"or-patterns",level:2},{value:"\u201cAs\u201d patterns",id:"as-patterns",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"Match patterns both define a condition that must be matched, and new variables that are extracted (like destructuring)."}),"\n",(0,r.jsx)(t.h2,{id:"primitive-value-patterns",children:"Primitive value patterns"}),"\n",(0,r.jsxs)(t.p,{children:["Primitive value patterns include string literals (e.g. ",(0,r.jsx)(t.code,{children:"'light'"}),"), number literals (e.g. ",(0,r.jsx)(t.code,{children:"42"}),"), BigInt literals (e.g. ",(0,r.jsx)(t.code,{children:"10n"}),"), boolean literals (e.g. ",(0,r.jsx)(t.code,{children:"true"}),"), ",(0,r.jsx)(t.code,{children:"null"}),", and ",(0,r.jsx)(t.code,{children:"undefined"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["You can use variables (e.g. ",(0,r.jsx)(t.code,{children:"name"}),") or property accesses (e.g. ",(0,r.jsx)(t.code,{children:"Status.Active"}),") which are either typed as a ",(0,r.jsx)(t.a,{href:"../../types/literals",children:"literal type"}),", or a ",(0,r.jsx)(t.a,{href:"../../enums",children:"Flow Enum"})," member. Using variables that are a general type like ",(0,r.jsx)(t.code,{children:"string"})," or ",(0,r.jsx)(t.code,{children:"number"})," is not allowed for match patterns - they must be a literal type like ",(0,r.jsx)(t.code,{children:"'light'"}),". You can add a type annotation or ",(0,r.jsx)(t.a,{href:"../../types/const-expression/",children:(0,r.jsx)(t.code,{children:"as const"})})," to your string value to type it with a literal type. Computed properties in match patterns only allow literals like ",(0,r.jsx)(t.code,{children:"foo['bar']"})," or ",(0,r.jsx)(t.code,{children:"foo[2]"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["The identifier ",(0,r.jsx)(t.code,{children:"_"})," is special cased for \u201cWildcard patterns\u201d, if you want to match against a value with that name, rename it to something else first. If you want to create a new variable, take a look at \u201cvariable declaration patterns\u201d below - it is done by doing ",(0,r.jsx)(t.code,{children:"const x"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["You can use a number literal prefixed with  ",(0,r.jsx)(t.code,{children:"+"})," or ",(0,r.jsx)(t.code,{children:"-"}),", or BigInt literals prefixed with ",(0,r.jsx)(t.code,{children:"-"})," (",(0,r.jsx)(t.code,{children:"+"})," on a BigInt is an error in JS). ",(0,r.jsx)(t.code,{children:"+0"})," and ",(0,r.jsx)(t.code,{children:"-0"})," are not allowed (Flow doesn\u2019t differentiate these type-wise from ",(0,r.jsx)(t.code,{children:"0"}),"). ",(0,r.jsx)(t.code,{children:"NaN"})," is special-cased, since ",(0,r.jsx)(t.code,{children:"NaN === NaN"})," is always ",(0,r.jsx)(t.code,{children:"false"}),". It is matched using ",(0,r.jsx)(t.code,{children:"Number.isNaN"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"Other types of expressions are not supported. To match against an arbitrary expression (which has a literal type), first assign it to a variable, and then match against that variable."}),"\n",(0,r.jsx)(t.p,{children:"Example:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"match (x) {\n  1 => {}\n  'foo' => {}\n  null => {}\n  -1 => {}\n  foo => {}\n  bar.baz => {}\n  bar['bort'] => {}\n  xs[2] => {}\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Flow will never output an \u201cunused pattern\u201d error for the ",(0,r.jsx)(t.code,{children:"undefined"})," pattern, so you can always add it even if the input type does not contain ",(0,r.jsx)(t.code,{children:"void"}),". This is to cover the case where Flow does not compute a type that is 100% accurate to the runtime value (for example, from indexed access of an array past its length)."]}),"\n",(0,r.jsxs)(t.p,{children:["At runtime, these checks are done using triple equals ",(0,r.jsx)(t.code,{children:"==="}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"wildcard-patterns",children:"Wildcard patterns"}),"\n",(0,r.jsxs)(t.p,{children:["Wildcard patterns, which are a single underscore ",(0,r.jsx)(t.code,{children:"_"}),", match everything. If you want to match against the value of a variable named ",(0,r.jsx)(t.code,{children:"_"}),", assign it to a different name first."]}),"\n",(0,r.jsxs)(t.p,{children:["If part of your input type cannot be matched exhaustively (e.g. ",(0,r.jsx)(t.code,{children:"string"}),"), then the ",(0,r.jsx)(t.code,{children:"match"})," will require a wildcard."]}),"\n",(0,r.jsx)(t.p,{children:"Example:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"match (x) {\n  _ => {}\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"variable-declaration-patterns",children:"Variable declaration patterns"}),"\n",(0,r.jsxs)(t.p,{children:["Variable declaration patterns, like ",(0,r.jsx)(t.code,{children:"const name"}),", take whatever value is at that position and assign it to a new variable. Conditional check wise, they act like a wildcard and match everything."]}),"\n",(0,r.jsx)(t.p,{children:"Example:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"const e = match (x) {\n  const x => x,\n};\n"})}),"\n",(0,r.jsxs)(t.p,{children:["While ",(0,r.jsx)(t.code,{children:"let"})," variables are also supported by the runtime, these are a type error for now and only ",(0,r.jsx)(t.code,{children:"const"})," variables are allowed. If you have a use case, please share it with the team. ",(0,r.jsx)(t.code,{children:"var"})," is not supported."]}),"\n",(0,r.jsx)(t.h2,{id:"object-patterns",children:"Object patterns"}),"\n",(0,r.jsxs)(t.p,{children:["Object patterns match object values with the same structure. For example, the pattern ",(0,r.jsx)(t.code,{children:"{type: 'light', num: 42}"})," matches objects which have the property ",(0,r.jsx)(t.code,{children:"type"})," with value ",(0,r.jsx)(t.code,{children:"'light'"}),", and a ",(0,r.jsx)(t.code,{children:"num"})," property with value ",(0,r.jsx)(t.code,{children:"42"}),".  If the object value has additional unlisted properties, or is inexact, you need to make your pattern inexact using ",(0,r.jsx)(t.code,{children:"..."}),", for example ",(0,r.jsx)(t.code,{children:"{type: 'light', num: 42, ...}"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["Like destructuring, a variable declaration pattern nested inside an object pattern creates a new variable with the value of that property. E.g. ",(0,r.jsx)(t.code,{children:"match (arg) { {prop: const x} => x }"})," will initialize ",(0,r.jsx)(t.code,{children:"x"})," with the value ",(0,r.jsx)(t.code,{children:"arg.prop"}),". You can use object rest to gather the rest of the object\u2019s own properties: ",(0,r.jsx)(t.code,{children:"{foo: 1, ...const rest}"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["Doing just ",(0,r.jsx)(t.code,{children:"{name}"})," is ambiguous - it could mean ",(0,r.jsx)(t.code,{children:"{name: name}"})," (matching against the value of variable ",(0,r.jsx)(t.code,{children:"name"}),") or ",(0,r.jsx)(t.code,{children:"{name: const name}"})," (extracting the property\u2019s value as a new variable called ",(0,r.jsx)(t.code,{children:"name"}),"), so it\u2019s not allowed. If you want a shorthand for creating new variables, you can use ",(0,r.jsx)(t.code,{children:"{const name}"})," to mean ",(0,r.jsx)(t.code,{children:"{name: const name}"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["If you have a property with either a wildcard or variable declaration pattern, e.g. ",(0,r.jsx)(t.code,{children:"{foo: _}"})," or ",(0,r.jsx)(t.code,{children:"{foo: const x}"}),", it is checked that the property is ",(0,r.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in",children:"in"})," the object (checks own and non-own properties)."]}),"\n",(0,r.jsxs)(t.p,{children:["When checking objects with optional properties, in order to make the check exhaustive you must include a pattern that doesn\u2019t include the optional properties. For example, for ",(0,r.jsx)(t.code,{children:"{name: string, age?: number}"}),", if you first match with the pattern ",(0,r.jsx)(t.code,{children:"{name: _, age: _}"}),", you still need to match with the pattern ",(0,r.jsx)(t.code,{children:"{name: _, ...}"})," in order to handle the cases where the ",(0,r.jsx)(t.code,{children:"age"})," property doesn\u2019t exist."]}),"\n",(0,r.jsxs)(t.p,{children:["Property names can be identifiers (e.g. ",(0,r.jsx)(t.code,{children:"foo: pattern"}),"), string literals (e.g. ",(0,r.jsx)(t.code,{children:"'foo': <pattern>)"}),", or number literals (e.g. ",(0,r.jsx)(t.code,{children:"2: <pattern>"}),"). Repeated object keys are banned, and BigInts are not supported as object keys (Flow doesn\u2019t yet support them)."]}),"\n",(0,r.jsx)(t.p,{children:"Example:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"const e = match (x) {\n  {foo: 1, bar: const a} => a,\n  {const baz} => baz,\n  {foo: 2, ...const rest} => rest,\n};\n"})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get",children:"Getters"})," are also not supported - at runtime they will be evaluated multiple times, once for each conditional check done against them. Flow doesn\u2019t support getters anyway."]}),"\n",(0,r.jsx)(t.h2,{id:"array-patterns",children:"Array patterns"}),"\n",(0,r.jsxs)(t.p,{children:["Array patterns match both tuple and array values. For example, the pattern ",(0,r.jsx)(t.code,{children:"['small', true]"})," matches array values whose length is ",(0,r.jsx)(t.code,{children:"2"})," and whose elements match the pattern\u2019s elements. If you want a looser length check, you can make the pattern inexact using ",(0,r.jsx)(t.code,{children:"..."}),", for example ",(0,r.jsx)(t.code,{children:"['small', true, ...]"})," will match arrays whose length is ",(0,r.jsx)(t.code,{children:">= 2"})," and whose first elements match the pattern\u2019s elements. You can match any array or tuple with ",(0,r.jsx)(t.code,{children:"[...]"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["Like destructuring, a variable declaration pattern nested inside an array pattern creates a new variable with the value of that element.  E.g. ",(0,r.jsx)(t.code,{children:"match (arg) { [const x] => x }"})," will initialize ",(0,r.jsx)(t.code,{children:"x"})," with the value ",(0,r.jsx)(t.code,{children:"arg[0]"}),". You can use array rest at the end of the pattern to gather the remaining elements, and check that the length is greater or equal to the pattern length: e.g. ",(0,r.jsx)(t.code,{children:"[1, 2, ...const rest]"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["Array patterns match values which pass ",(0,r.jsx)(t.code,{children:"Array.isArray"}),", so they won\u2019t match array-like objects that aren\u2019t actually arrays, and won\u2019t match iterables. Use ",(0,r.jsx)(t.code,{children:"Array.from"})," on those types of values first first if you want to match them with array patterns."]}),"\n",(0,r.jsx)(t.p,{children:"Example:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"const e = match (x) {\n  [1, 2] => [],\n  [3, 4, ...] => [],\n  [5, 6, ...const rest] => rest,\n};\n"})}),"\n",(0,r.jsx)(t.h2,{id:"or-patterns",children:"\u201cOr\u201d patterns"}),"\n",(0,r.jsxs)(t.p,{children:["Or patterns allow you to combine multiple patterns using ",(0,r.jsx)(t.code,{children:"|"}),", for example ",(0,r.jsx)(t.code,{children:"'active' | 'paused'"})," will match either string literal."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"#variable-declaration-patterns",children:"Variable declaration patterns"}),' inside of "or" patterns are not yet supported.']}),"\n",(0,r.jsx)(t.p,{children:"Example:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"match (x) {\n  1 | 2 => {}\n  [4] | [5] => {}\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"as-patterns",children:"\u201cAs\u201d patterns"}),"\n",(0,r.jsxs)(t.p,{children:["As patterns both match a pattern and create a new variable. For example, ",(0,r.jsx)(t.code,{children:"[_, _] as pair"})," will first match any arrays whose length is ",(0,r.jsx)(t.code,{children:"2"}),", and then assign that value to a new variable called ",(0,r.jsx)(t.code,{children:"pair"}),". The syntax ",(0,r.jsx)(t.code,{children:"as const pair"})," also works, we\u2019ll decide which one to keep based on feedback."]}),"\n",(0,r.jsx)(t.p,{children:"Example:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"const e = match (x) {\n  // Either one works for now\n  [2, _] as x => x,\n  [1, _] as const x => x,\n};\n"})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,t,a)=>{a.d(t,{R:()=>i,x:()=>c});var n=a(96540);const r={},s=n.createContext(r);function i(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);