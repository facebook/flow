"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[2062],{28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var t=s(96540);const i={},a=t.createContext(i);function o(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(a.Provider,{value:n},e.children)}},62062:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"lang/refinements","title":"Type Refinements","description":"Refinements allow us to narrow the type of a value based on conditional tests.","source":"@site/docs/lang/refinements.md","sourceDirName":"lang","slug":"/lang/refinements","permalink":"/en/docs/lang/refinements","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/lang/refinements.md","tags":[],"version":"current","frontMatter":{"title":"Type Refinements","slug":"/lang/refinements"},"sidebar":"docsSidebar","previous":{"title":"Width Subtyping","permalink":"/en/docs/lang/width-subtyping"},"next":{"title":"Lazy Mode","permalink":"/en/docs/lang/lazy-modes"}}');var i=s(74848),a=s(28453);const o={title:"Type Refinements",slug:"/lang/refinements"},l=void 0,r={},c=[{value:"Ways to refine in Flow",id:"ways-to-refine-in-flow",level:2},{value:"<code>typeof</code> checks",id:"typeof-checks",level:3},{value:"Equality checks",id:"equality-checks",level:3},{value:"Truthiness checks",id:"truthiness-checks",level:3},{value:"<code>in</code> checks",id:"in-checks",level:3},{value:"<code>instanceof</code> checks",id:"instanceof-checks",level:3},{value:"Assignments",id:"assignments",level:3},{value:"Type Guards",id:"type-guards",level:3},{value:"Refinement Invalidations",id:"toc-refinement-invalidations",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Refinements allow us to narrow the type of a value based on conditional tests."}),"\n",(0,i.jsxs)(n.p,{children:["For example, in the function below ",(0,i.jsx)(n.code,{children:"value"})," is a ",(0,i.jsx)(n.a,{href:"../../types/unions",children:"union"})," of ",(0,i.jsx)(n.code,{children:'"A"'})," or ",(0,i.jsx)(n.code,{children:'"B"'}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'function func(value: "A" | "B") {\n  if (value === "A") {\n    value as "A";\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Inside of the ",(0,i.jsx)(n.code,{children:"if"})," block we know that value must be ",(0,i.jsx)(n.code,{children:'"A"'})," because that's the only\ntime the if-statement will be true."]}),"\n",(0,i.jsxs)(n.p,{children:["The ability for a static type checker to be able to tell that the value inside\nthe if statement must be ",(0,i.jsx)(n.code,{children:'"A"'})," is known as a refinement."]}),"\n",(0,i.jsxs)(n.p,{children:["Next we'll add an ",(0,i.jsx)(n.code,{children:"else"})," block to our if statement."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'function func(value: "A" | "B") {\n  if (value === "A") {\n    value as "A";\n  } else {\n    value as "B";\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Inside of the ",(0,i.jsx)(n.code,{children:"else"})," block we know that value must be ",(0,i.jsx)(n.code,{children:'"B"'})," because it can only\nbe ",(0,i.jsx)(n.code,{children:'"A"'})," or ",(0,i.jsx)(n.code,{children:'"B"'})," and we've removed ",(0,i.jsx)(n.code,{children:'"A"'})," from the possibilities."]}),"\n",(0,i.jsx)(n.h2,{id:"ways-to-refine-in-flow",children:"Ways to refine in Flow"}),"\n",(0,i.jsxs)(n.h3,{id:"typeof-checks",children:[(0,i.jsx)(n.code,{children:"typeof"})," checks"]}),"\n",(0,i.jsxs)(n.p,{children:["You can use a ",(0,i.jsx)(n.code,{children:'typeof value === "<type>"'})," check to refine a value to one of the categories supported by the ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof",children:(0,i.jsx)(n.code,{children:"typeof"})})," operator."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"typeof"})," operator can output ",(0,i.jsx)(n.code,{children:'"undefined"'}),",",(0,i.jsx)(n.code,{children:'"boolean"'}),", ",(0,i.jsx)(n.code,{children:'"number"'}),", ",(0,i.jsx)(n.code,{children:'"bigint"'}),", ",(0,i.jsx)(n.code,{children:'"string"'}),", ",(0,i.jsx)(n.code,{children:'"symbol"'}),", ",(0,i.jsx)(n.code,{children:'"function"'}),", or ",(0,i.jsx)(n.code,{children:'"object"'}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Keep in mind that the ",(0,i.jsx)(n.code,{children:"typeof"})," operator will return ",(0,i.jsx)(n.code,{children:'"object"'})," for objects, but also ",(0,i.jsx)(n.code,{children:"null"})," and arrays as well."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'function func(value: mixed) {\n  if (typeof value === "string") {\n    value as string;\n  } else if (typeof value === "boolean") {\n    value as boolean;\n  } else if (typeof value === "object") {\n    // `value` could be null, an array, or an object\n    value as null | interface {} | $ReadOnlyArray<mixed>;\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["To check for ",(0,i.jsx)(n.code,{children:"null"}),", use a ",(0,i.jsx)(n.code,{children:"value === null"})," ",(0,i.jsx)(n.a,{href:"#equality-checks",children:"equality"})," check."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function func(value: mixed) {\n  if (value === null) {\n    value as null; // `value` is null\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To check for ",(0,i.jsx)(n.a,{href:"../../types/arrays",children:"arrays"}),", use ",(0,i.jsx)(n.code,{children:"Array.isArray"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function func(value: mixed) {\n  if (Array.isArray(value)) {\n    value as $ReadOnlyArray<mixed>; // `value` is an array\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"equality-checks",children:"Equality checks"}),"\n",(0,i.jsxs)(n.p,{children:["As shown in the introductory example, you can use an equality check to narrow a value to a specific type.\nThis also applies to equality checks made in ",(0,i.jsx)(n.code,{children:"switch"})," statements."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'function func(value: "A" | "B" | "C") {\n  if (value === "A") {\n    value as "A";\n  } else {\n    value as "B" | "C";\n  }\n\n  switch (value) {\n    case "A":\n      value as "A";\n      break;\n    case "B":\n      value as "B";\n      break;\n    case "C":\n      value as "C";\n      break;\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["While in general it is not recommended to use ",(0,i.jsx)(n.code,{children:"=="})," in JavaScript, due to the coercions it performs,\ndoing ",(0,i.jsx)(n.code,{children:"value == null"})," (or ",(0,i.jsx)(n.code,{children:"value != null"}),") checks ",(0,i.jsx)(n.code,{children:"value"})," exactly for ",(0,i.jsx)(n.code,{children:"null"})," and ",(0,i.jsx)(n.code,{children:"void"}),".\nThis works well with Flow's ",(0,i.jsx)(n.a,{href:"../../types/maybe",children:"maybe"})," types, which create a union with ",(0,i.jsx)(n.code,{children:"null"})," and ",(0,i.jsx)(n.code,{children:"void"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function func(value: ?string) {\n  if (value != null) {\n    value as string;\n  } else {\n    value as null | void;\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can refine a union of object types based on a common tag, which we call ",(0,i.jsx)(n.a,{href:"../../types/unions/#toc-disjoint-object-unions",children:"disjoint object unions"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'type A = {type: "A", s: string};\ntype B = {type: "B", n: number};\n\nfunction func(value: A | B) {\n  if (value.type === "A") {\n    // `value` is A\n    value.s as string; // Works\n  } else {\n    // `value` is B\n    value.n as number; // Works\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"truthiness-checks",children:"Truthiness checks"}),"\n",(0,i.jsxs)(n.p,{children:["You can use non-booleans in JavaScript conditionals.\n",(0,i.jsx)(n.code,{children:"0"}),", ",(0,i.jsx)(n.code,{children:"NaN"}),", ",(0,i.jsx)(n.code,{children:'""'}),", ",(0,i.jsx)(n.code,{children:"null"}),", and ",(0,i.jsx)(n.code,{children:"undefined"})," will all coerce to ",(0,i.jsx)(n.code,{children:"false"}),' (and so are considered "falsey").\nOther values will coerce to ',(0,i.jsx)(n.code,{children:"true"}),' (and so are considered "truthy").']}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":5,"startColumn":5,"endLine":5,"endColumn":9,"description":"Cannot cast `value` to union type because string [1] is incompatible with union type [2]. [incompatible-type]"}]',children:'function func(value: ?string) {\n  if (value) {\n    value as string; // Works\n  } else {\n    value as null | void; // Error! Could still be the empty string ""\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["You can see in the above example why doing a truthy check when your value can be a string or number is not suggested:\nit is possible to unintentionally check against the ",(0,i.jsx)(n.code,{children:'""'})," or ",(0,i.jsx)(n.code,{children:"0"}),".\nWe created a ",(0,i.jsx)(n.a,{href:"../../linting",children:"Flow lint"})," called ",(0,i.jsx)(n.a,{href:"../../linting/rule-reference/#toc-sketchy-null",children:"sketchy-null"})," to guard against this scenario:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":7,"endLine":3,"endColumn":11,"description":"Sketchy null check on string [1] which is potentially an empty string. Perhaps you meant to check for null or undefined [2]? [sketchy-null-string]"}]',children:"// flowlint sketchy-null:error\nfunction func(value: ?string) {\n  if (value) { // Error!\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"in-checks",children:[(0,i.jsx)(n.code,{children:"in"})," checks"]}),"\n",(0,i.jsxs)(n.p,{children:["You can use the ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in",children:"in"}),"\noperator to check if a property exists on an object (either in its own properties, or up the prototype chain).\nThis can be used to refine a union of objects:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function func(obj: {foo: string, value: boolean} | {bar: string, value: number}) {\n  if ('foo' in obj) {\n    obj.value as boolean; // Works!\n  } else {\n    obj.value as number; // Works!\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This works best on unions of ",(0,i.jsx)(n.a,{href:"../../types/objects/#exact-and-inexact-object-types",children:"exact objects"}),", since in the negation we know the property does not exist.\nWe cannot say the same for ",(0,i.jsx)(n.a,{href:"../../types/objects/#exact-and-inexact-object-types",children:"inexact objects"}),", ",(0,i.jsx)(n.a,{href:"../../types/interfaces/",children:"interfaces"}),", and ",(0,i.jsx)(n.a,{href:"../../types/classes/",children:"instance types"}),",\nsince they may have other unknown properties, including the one we are checking.\nAdditionally, ",(0,i.jsx)(n.a,{href:"../../types/objects/#toc-optional-object-type-properties",children:"optional properties"})," may or may not exist, so are not particularly useful to check against."]}),"\n",(0,i.jsxs)(n.p,{children:["If you want to refine a union of ",(0,i.jsx)(n.a,{href:"../../types/tuples/",children:"tuple types"})," based on whether an element exists,\ncheck the ",(0,i.jsx)(n.a,{href:"../../types/tuples/#length-refinement",children:"length"})," property instead of attempting to use ",(0,i.jsx)(n.code,{children:"in"}),"."]}),"\n",(0,i.jsxs)(n.h3,{id:"instanceof-checks",children:[(0,i.jsx)(n.code,{children:"instanceof"})," checks"]}),"\n",(0,i.jsxs)(n.p,{children:["You can use the ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof",children:"instanceof"})," operator to narrow a value as well.\nIt checks if the supplied constructor's prototype is anywhere in a value's prototype chain."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":16,"startColumn":11,"endLine":16,"endColumn":15,"description":"Cannot call `value.build` because property `build` is missing in `A` [1]. [prop-missing]"}]',children:"class A {\n  amaze(): void {}\n}\nclass B extends A {\n  build(): void {}\n}\n\nfunction func(value: mixed) {\n  if (value instanceof B) {\n    value.amaze(); // Works\n    value.build(); // Works\n  }\n\n  if (value instanceof A) {\n    value.amaze(); // Works\n    value.build(); // Error\n  }\n\n  if (value instanceof Object) {\n    value.toString(); // Works\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"assignments",children:"Assignments"}),"\n",(0,i.jsx)(n.p,{children:"Flow follows your control flow and narrows the type of a variable after you have assigned to it."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'declare const b: boolean;\n\nlet x: ?string = b ? "str" : null;\n\nx as ?string;\n\nx = "hi";\n\n// We know `x` must now be a string after the assignment\nx as string; // Works\n'})}),"\n",(0,i.jsx)(n.h3,{id:"type-guards",children:"Type Guards"}),"\n",(0,i.jsxs)(n.p,{children:["You can create a reusable refinement by defining a function which is a ",(0,i.jsx)(n.a,{href:"../../types/type-guards/",children:"type guard"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":2,"startColumn":10,"endLine":2,"endColumn":18,"description":"Cannot return `x != null` because the negation of the predicate encoded in this expression needs to completely refine away the guard type `T` [1]. Consider using a one-sided type-guard (`implies x is T`). See 2. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]"}]',children:"function nonMaybe<T>(x: ?T): x is T {\n  return x != null;\n}\n\nfunction func(value: ?string) {\n  if (nonMaybe(value)) {\n    value as string; // Works!\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"toc-refinement-invalidations",children:"Refinement Invalidations"}),"\n",(0,i.jsx)(n.p,{children:"It is also possible to invalidate refinements, for example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":6,"startColumn":16,"endLine":6,"endColumn":21,"description":"Cannot call `value.prop.charAt` because property `charAt` is missing in undefined [1]. [incompatible-use]"}]',children:"function otherFunc() { /* ... */ }\n\nfunction func(value: {prop?: string}) {\n  if (value.prop) {\n    otherFunc();\n    value.prop.charAt(0); // Error!\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The reason for this is that we don't know that ",(0,i.jsx)(n.code,{children:"otherFunc()"})," hasn't done\nsomething to our value. Imagine the following scenario:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":12,"startColumn":16,"endLine":12,"endColumn":21,"description":"Cannot call `value.prop.charAt` because property `charAt` is missing in undefined [1]. [incompatible-use]"}]',children:'const obj: {prop?: string} = {prop: "test"};\n\nfunction otherFunc() {\n  if (Math.random() > 0.5) {\n    delete obj.prop;\n  }\n}\n\nfunction func(value: {prop?: string}) {\n  if (value.prop) {\n    otherFunc();\n    value.prop.charAt(0); // Error!\n  }\n}\n\nfunc(obj);\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Inside of ",(0,i.jsx)(n.code,{children:"otherFunc()"})," we sometimes remove ",(0,i.jsx)(n.code,{children:"prop"}),". Flow doesn't know if the\n",(0,i.jsx)(n.code,{children:"if (value.prop)"})," check is still true, so it invalidates the refinement."]}),"\n",(0,i.jsx)(n.p,{children:"There's a straightforward way to get around this. Store the value before\ncalling another function and use the stored value instead. This way you can\nprevent the refinement from invalidating."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function otherFunc() { /* ... */ }\n\nfunction func(value: {prop?: string}) {\n  if (value.prop) {\n    const prop = value.prop;\n    otherFunc();\n    prop.charAt(0);\n  }\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);