"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[851],{28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>a});var s=t(96540);const r={},o=s.createContext(r);function c(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),s.createElement(o.Provider,{value:n},e.children)}},50851:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>a,default:()=>d,frontMatter:()=>c,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"match/migration","title":"Migration from existing patterns","description":"You can migrate from switch statements and conditional expressions to match expressions and statements","source":"@site/docs/match/migration.md","sourceDirName":"match","slug":"/match/migration","permalink":"/en/docs/match/migration","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/match/migration.md","tags":[],"version":"current","frontMatter":{"title":"Migration from existing patterns","description":"You can migrate from switch statements and conditional expressions to match expressions and statements","slug":"/match/migration"},"sidebar":"docsSidebar","previous":{"title":"Match Patterns","permalink":"/en/docs/match/patterns"},"next":{"title":"Declarations","permalink":"/en/docs/declarations"}}');var r=t(74848),o=t(28453);const c={title:"Migration from existing patterns",description:"You can migrate from switch statements and conditional expressions to match expressions and statements",slug:"/match/migration"},a=void 0,i={},l=[{value:"Replacing <code>switch</code>",id:"replacing-switch",level:2},{value:"To match statement",id:"to-match-statement",level:3},{value:"To match expression",id:"to-match-expression",level:3},{value:"Replacing conditional ternary expressions",id:"replacing-conditional-ternary-expressions",level:2},{value:"Dealing with disjoint object unions",id:"dealing-with-disjoint-object-unions",level:2}];function h(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h2,{id:"replacing-switch",children:["Replacing ",(0,r.jsx)(n.code,{children:"switch"})]}),"\n",(0,r.jsxs)(n.p,{children:["You can turn a ",(0,r.jsx)(n.code,{children:"switch"})," into either a match statement or a match expression, depending on its usage."]}),"\n",(0,r.jsxs)(n.p,{children:["If you are using an IDE, you can use the \u201cRefactor ",(0,r.jsx)(n.code,{children:"switch"})," to ",(0,r.jsx)(n.code,{children:"match"}),"\u201d refactoring code-action to do most of the below. To activate, the ",(0,r.jsx)(n.code,{children:"switch"})," needs the following properties:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Every case of the switch must end with a ",(0,r.jsx)(n.code,{children:"break"}),", ",(0,r.jsx)(n.code,{children:"return"}),", or ",(0,r.jsx)(n.code,{children:"throw"}),", except the last case."]}),"\n",(0,r.jsxs)(n.li,{children:["If there is a ",(0,r.jsx)(n.code,{children:"default"}),", it must be the last case."]}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"case"})," test must be convertible to a match pattern."]}),"\n",(0,r.jsxs)(n.li,{children:["If there is a ",(0,r.jsx)(n.code,{children:"let"})," or ",(0,r.jsx)(n.code,{children:"const"})," in the case body, it must be wrapped in a block."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"And the caveats for the resulting match:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["It may contain other ",(0,r.jsx)(n.code,{children:"break"}),"s (other than the last one that was removed) that will be a parse error and you will have to figure out what to do with that."]}),"\n",(0,r.jsxs)(n.li,{children:["It may not be exhaustively checked, or identifier patterns may not be valid (e.g. just typed as ",(0,r.jsx)(n.code,{children:"string"}),"). You will get new errors you will have to resolve."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"to-match-statement",children:"To match statement"}),"\n",(0,r.jsxs)(n.p,{children:["Most ",(0,r.jsx)(n.code,{children:"switch"})," statements can be turned into match statements:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Replace ",(0,r.jsx)(n.code,{children:"switch"})," with ",(0,r.jsx)(n.code,{children:"match"})]}),"\n",(0,r.jsxs)(n.li,{children:["Delete the ",(0,r.jsx)(n.code,{children:"case"})]}),"\n",(0,r.jsxs)(n.li,{children:["Replace the colon ",(0,r.jsx)(n.code,{children:":"})," after the case test with an arrow  ",(0,r.jsx)(n.code,{children:"=>"})]}),"\n",(0,r.jsxs)(n.li,{children:["Wrap the case body in a block ",(0,r.jsx)(n.code,{children:"{ ... }"})]}),"\n",(0,r.jsxs)(n.li,{children:["Remove the ",(0,r.jsx)(n.code,{children:"break;"})]}),"\n",(0,r.jsxs)(n.li,{children:["If multiple cases share a body, use an ",(0,r.jsx)(n.a,{href:"../patterns#or-patterns",children:'"or" pattern'})," ",(0,r.jsx)(n.code,{children:"|"})]}),"\n",(0,r.jsxs)(n.li,{children:["Replace the ",(0,r.jsx)(n.code,{children:"default"})," with a ",(0,r.jsx)(n.a,{href:"../patterns#wildcard-patterns",children:"wildcard"})," ",(0,r.jsx)(n.code,{children:"_"})]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// Before\nswitch (action) {\n  case 'delete':\n  case 'remove':\n    data.pop();\n    break;\n  case 'add':\n    data.push(1);\n    break;\n  default:\n    show(data);\n}\n\n// After\nmatch (action) {\n  'delete' | 'remove' => {\n    data.pop();\n  }\n  'add' => {\n    data.push(1);\n  }\n  _ => {\n    show(data);\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If you are depending on the fallthrough behavior of ",(0,r.jsx)(n.code,{children:"switch"})," cases when not using ",(0,r.jsx)(n.code,{children:"break"})," (other than the simple case where the body is completely shared), then you will likely have to refactor your case body code into a function which is called."]}),"\n",(0,r.jsx)(n.h3,{id:"to-match-expression",children:"To match expression"}),"\n",(0,r.jsxs)(n.p,{children:["If every case of your ",(0,r.jsx)(n.code,{children:"switch"})," has a body that contains a single ",(0,r.jsx)(n.code,{children:"return"})," or a single assignment, then you can turn your ",(0,r.jsx)(n.code,{children:"switch"})," into a match expression."]}),"\n",(0,r.jsxs)(n.p,{children:["For the ",(0,r.jsx)(n.code,{children:"return"})," case, make the same changes as in the ",(0,r.jsx)(n.a,{href:"#to-match-statement",children:"to match statement"})," section, except:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Replace each case body with only the expression being returned, and delete the ",(0,r.jsx)(n.code,{children:"return"}),", and don't use braces for the ",(0,r.jsx)(n.code,{children:"case"})," body"]}),"\n",(0,r.jsxs)(n.li,{children:["Separate each case with a comma ",(0,r.jsx)(n.code,{children:","})]}),"\n",(0,r.jsx)(n.li,{children:"Return the entire match expression"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"// Before\nfunction getSizeBefore(imageSize: 'small' | 'medium' | 'large') {\n  switch (imageSize) {\n    case 'small':\n      return 50;\n    case 'medium':\n      return 100;\n    case 'large':\n      return 200;\n  };\n}\n\n// After\nfunction getSizeAfter(imageSize: 'small' | 'medium' | 'large') {\n  return match (imageSize) {\n    'small' => 50,\n    'medium' => 100,\n    'large' => 200,\n  };\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["For the assignment case, make the same changes as in the ",(0,r.jsx)(n.a,{href:"#to-match-statement",children:"to match statement"})," section, except:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Replace each case body with only the expression being assigned, and don't use braces for the ",(0,r.jsx)(n.code,{children:"case"})," body"]}),"\n",(0,r.jsxs)(n.li,{children:["Separate each case with a comma ",(0,r.jsx)(n.code,{children:","})]}),"\n",(0,r.jsx)(n.li,{children:"Assign the entire match expression to the variable"}),"\n",(0,r.jsxs)(n.li,{children:["If you no longer re-assign the variable, you can change it to a ",(0,r.jsx)(n.code,{children:"const"})]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// Before\nlet colorSchemeStyles;\nswitch (colorScheme) {\n  case 'darker':\n    colorSchemeStyles = colorSchemeDarker;\n    break;\n  case 'light':\n    colorSchemeStyles = colorSchemeLight;\n    break;\n  case 'unset':\n    colorSchemeStyles = colorSchemeDefault;\n    break;\n}\n\n// After\nconst colorSchemeStyles = match (colorScheme) {\n  'darker' => colorSchemeDarker,\n  'light' => colorSchemeLight,\n  'unset' => colorSchemeDefault,\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"You can replace multiple assignments with a single match expression:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// Before\nlet color;\nlet size;\nswitch (status) {\n  case Status.Active:\n    color = 'green';\n    size = 2;\n    break;\n  case Status.Paused:\n    color = 'yellow';\n    size = 1;\n    break;\n  case Status.Off:\n    color = 'red';\n    size = 0;\n    break;\n}\n\n// After (using a tuple):\nconst [color, size] = match (status) {\n  Status.Active => ['green', 2],\n  Status.Paused => ['yellow', 1],\n  Status.Off => ['red', 0],\n};\n\n// After (using an object):\nconst {color, size} = match (status) {\n  Status.Active => {color: 'green', size: 2},\n  Status.Paused => {color: 'yellow', size: 1},\n  Status.Off => {color: 'red', size: 0},\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"Using an object is more verbose, but may be more readable, especially if dealing with more than two variables."}),"\n",(0,r.jsx)(n.h2,{id:"replacing-conditional-ternary-expressions",children:"Replacing conditional ternary expressions"}),"\n",(0,r.jsxs)(n.p,{children:["You can replace most conditional expressions ",(0,r.jsx)(n.code,{children:"cond ? x : y"})," with match expressions. This is particularly useful for complex or nested conditional expressions. For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"declare const obj:\n  | {type: 'a', foo: number}\n  | {type: 'b', bar: string}\n  | null;\n\n// Before\nconst a =\n  obj === null\n    ? 0\n    : obj.type === 'a'\n      ? obj.foo\n      : obj.bar.length;\n\n// After\nconst b = match (obj) {\n  {type: 'a', const foo} => foo,\n  {type: 'b', const bar} => bar.length,\n  null => 0,\n};\n"})}),"\n",(0,r.jsx)(n.h2,{id:"dealing-with-disjoint-object-unions",children:"Dealing with disjoint object unions"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"../../types/unions#toc-disjoint-object-unions",children:"Disjoint object unions"})," are unions of object types with some distinguishing property. In the following example, that would be the ",(0,r.jsx)(n.code,{children:"type"})," property:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type Result = {type: 'ok', value: number} | {type: 'error', error: Error};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Previous patterns would involve checking the ",(0,r.jsx)(n.code,{children:"result.type"})," property, and then accessing properties off of ",(0,r.jsx)(n.code,{children:"result"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type Result = {type: 'ok', value: number} | {type: 'error', error: Error};\ndeclare const result: Result;\n\nswitch (result.type) {\n  case 'ok':\n    console.log(result.value);\n    break;\n  case 'error':\n    throw result.error;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["With pattern matching you have to change how you think about it. Rather than doing the conditional checks on the ",(0,r.jsx)(n.code,{children:"type"})," property, you do it on the object itself, and destructure what you need right in the pattern:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type Result = {type: 'ok', value: number} | {type: 'error', error: Error};\ndeclare const result: Result;\n\nmatch (result) {\n  {type: 'ok', const value} => {\n    console.log(value);\n  }\n  {type: 'error', const error} => {\n    throw error;\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If you need to pass in the refined object type itself, you can use an ",(0,r.jsx)(n.code,{children:"as"})," pattern on the object pattern:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type OK = {type: 'ok', value: number};\ntype Err = {type: 'error', error: Error}\ntype Result = OK | Err;\n\ndeclare const result: Result;\n\nmatch (result) {\n  {type: 'ok', const value} => {\n    console.log(value);\n  }\n  {type: 'error', ...} as err => { // Using `as`\n    throw processError(err);\n  }\n}\n\ndeclare function processError(err: Err): Error;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If you don't need the ",(0,r.jsx)(n.code,{children:"type"})," property included, you could also use an ",(0,r.jsx)(n.a,{href:"../patterns#object-patterns",children:"object rest pattern"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type Result = {type: 'ok', value: number} | {type: 'error', error: Error};\n\ndeclare const result: Result;\n\nmatch (result) {\n  {type: 'ok', const value} => {\n    console.log(value);\n  }\n  {type: 'error', ...const err} => { // Using object rest\n    throw processError(err);\n  }\n}\n\ndeclare function processError(err: {error: Error}): Error;\n"})})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}}}]);