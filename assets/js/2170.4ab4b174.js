"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[2170],{28453:(n,e,o)=>{o.d(e,{R:()=>c,x:()=>i});var t=o(96540);const r={},a=t.createContext(r);function c(n){const e=t.useContext(a);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:c(n.components),t.createElement(a.Provider,{value:e},n.children)}},62170:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>c,metadata:()=>t,toc:()=>p});const t=JSON.parse('{"id":"react/hoc","title":"Higher-order Components","description":"Higher-order components are discouraged in modern React code and will not be updated for Component Syntax.","source":"@site/docs/react/hoc.md","sourceDirName":"react","slug":"/react/hoc","permalink":"/en/docs/react/hoc","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/react/hoc.md","tags":[],"version":"current","frontMatter":{"title":"Higher-order Components","slug":"/react/hoc"},"sidebar":"docsSidebar","previous":{"title":"Ref Functions","permalink":"/en/docs/react/refs"},"next":{"title":"Render Types","permalink":"/en/docs/react/render-types"}}');var r=o(74848),a=o(28453);const c={title:"Higher-order Components",slug:"/react/hoc"},i=void 0,s={},p=[{value:"The Trivial HOC",id:"toc-the-trivial-hoc",level:3},{value:"Injecting Props",id:"toc-injecting-props",level:3},{value:"Preserving the Instance Type of a Component",id:"toc-preserving-the-instance-type-of-a-component",level:3},{value:"Exporting Wrapped Components",id:"toc-exporting-wrapped-components",level:3}];function d(n){const e={a:"a",admonition:"admonition",code:"code",h3:"h3",p:"p",pre:"pre",...(0,a.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.admonition,{type:"danger",children:(0,r.jsxs)(e.p,{children:["Higher-order components are discouraged in modern React code and will not be updated for ",(0,r.jsx)(e.a,{href:"../component-syntax",children:"Component Syntax"}),".\nConsider using a hook to accomplish your task instead."]})}),"\n",(0,r.jsxs)(e.p,{children:["A popular pattern in React is the ",(0,r.jsx)(e.a,{href:"https://facebook.github.io/react/docs/higher-order-components.html",children:"higher-order component pattern"}),", so it's\nimportant that we can provide effective types for higher-order components in\nFlow. If you don't already know what a higher-order component is then make sure\nto read the ",(0,r.jsx)(e.a,{href:"https://facebook.github.io/react/docs/higher-order-components.html",children:"React documentation on higher-order components"})," before\ncontinuing."]}),"\n",(0,r.jsxs)(e.p,{children:["You can make use of the ",(0,r.jsx)(e.a,{href:"../component-types/",children:"Component Types"})," to annotate your higher order components."]}),"\n",(0,r.jsx)(e.h3,{id:"toc-the-trivial-hoc",children:"The Trivial HOC"}),"\n",(0,r.jsx)(e.p,{children:"Let's start with the simplest HOC:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-flow",metastring:"[]",children:"import * as React from 'react';\n\nfunction trivialHOC<Config: {...}>(\n  Component: component(...Config),\n): component(...Config) {\n  return Component;\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"This is a basic template for what your HOCs might look like. At runtime, this HOC doesn't\ndo anything at all. Let's take a look at some more complex examples."}),"\n",(0,r.jsx)(e.h3,{id:"toc-injecting-props",children:"Injecting Props"}),"\n",(0,r.jsx)(e.p,{children:"A common use case for higher-order components is to inject a prop.\nThe HOC automatically sets a prop and returns a component which no longer requires\nthat prop. For example, consider a navigation prop. How would one type this?"}),"\n",(0,r.jsx)(e.p,{children:"To remove a prop from the config, we can take a component that includes the\nprop and return a component that does not. It's best to construct these\ntypes using object type spread."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-flow",metastring:'[{"startLine":27,"startColumn":2,"endLine":27,"endColumn":20,"description":"Cannot create `MyEnhancedComponent` element because property `b` is missing in props [1] but exists in object type [2]. [incompatible-type]"}]',children:"import * as React from 'react';\n\ntype InjectedProps = {foo: number}\n\nfunction injectProp<Config>(\n  Component: component(...{...$Exact<Config>, ...InjectedProps})\n): component(...$Exact<Config>) {\n  return function WrapperComponent(\n    props: Config,\n  ) {\n    return <Component {...props} foo={42} />;\n  };\n}\n\nfunction MyComponent(props: {\n  a: number,\n  b: number,\n  ...InjectedProps,\n}): React.Node {}\n\nconst MyEnhancedComponent = injectProp(MyComponent);\n\n// We don't need to pass in `foo` even though `MyComponent` requires it:\n<MyEnhancedComponent a={1} b={2} />; // OK\n\n// We still require `a` and `b`:\n<MyEnhancedComponent a={1} />; // ERROR\n"})}),"\n",(0,r.jsx)(e.h3,{id:"toc-preserving-the-instance-type-of-a-component",children:"Preserving the Instance Type of a Component"}),"\n",(0,r.jsxs)(e.p,{children:["Recall that the instance type of a function component is ",(0,r.jsx)(e.code,{children:"void"}),". Our example\nabove wraps a component in a function, so the returned component has the instance\ntype ",(0,r.jsx)(e.code,{children:"void"}),"."]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-flow",metastring:'[{"startLine":29,"startColumn":2,"endLine":29,"endColumn":20,"description":"Cannot create `MyEnhancedComponent` element because property `ref` is extra in props [1] but missing in object type [2]. Exact objects do not accept extra props. [incompatible-type]"}]',children:"import * as React from 'react';\n\ntype InjectedProps = {foo: number}\n\nfunction injectProp<Config>(\n  Component: component(...{...$Exact<Config>, ...InjectedProps})\n): component(...$Exact<Config>) {\n  return function WrapperComponent(\n    props: Config,\n  ) {\n    return <Component {...props} foo={42} />;\n  };\n}\n\n// A class component in this example\nclass MyComponent extends React.Component<{\n  a: number,\n  b: number,\n  ...InjectedProps,\n}> {}\n\nconst MyEnhancedComponent = injectProp(MyComponent);\n\n// If we create a ref object for the component, it will never be assigned\n// an instance of MyComponent!\nconst ref = React.createRef<MyComponent>();\n\n// Error, mixed is incompatible with MyComponent.\n<MyEnhancedComponent ref={ref} a={1} b={2} />;\n"})}),"\n",(0,r.jsxs)(e.p,{children:["We get this error message because component type doesn't declare the ",(0,r.jsx)(e.code,{children:"ref"})," prop,\nso it is treated as ",(0,r.jsx)(e.code,{children:"React.RefSetter<void>"}),". If we wanted to preserve the instance type\nof the component, we can use ",(0,r.jsx)(e.a,{href:"https://reactjs.org/docs/forwarding-refs.html",children:(0,r.jsx)(e.code,{children:"React.forwardRef"})}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-flow",metastring:"[]",children:"import * as React from 'react';\n\ntype InjectedProps = {foo: number}\n\nfunction injectAndPreserveInstance<Config: {...}, Instance>(\n  Component: component(ref?: React.RefSetter<Instance>, ...{...$Exact<Config>, ...InjectedProps})\n): component(ref?: React.RefSetter<Instance>, ...$Exact<Config>) {\n  return React.forwardRef<$Exact<Config>, Instance>((props, ref) =>\n      <Component ref={ref} foo={3} {...props} />\n  );\n}\n\nclass MyComponent extends React.Component<{\n  a: number,\n  b: number,\n  ...InjectedProps,\n}> {}\n\nconst MyEnhancedComponent = injectAndPreserveInstance(MyComponent);\n\nconst ref = React.createRef<MyComponent>();\n\n// All good! The ref is forwarded.\n<MyEnhancedComponent ref={ref} a={1} b={2} />;\n"})}),"\n",(0,r.jsx)(e.h3,{id:"toc-exporting-wrapped-components",children:"Exporting Wrapped Components"}),"\n",(0,r.jsx)(e.p,{children:"If you try to export a wrapped component, chances are that you'll run into a missing annotation error:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-flow",metastring:'[{"startLine":13,"startColumn":36,"endLine":13,"endColumn":58,"description":"Cannot build a typed interface for this module. You should annotate the exports of this module with types. Cannot determine the type of this call expression. Please provide an annotation, e.g., by adding a type cast around this expression. [signature-verification-failure]"}]',children:"import * as React from 'react';\n\nfunction trivialHOC<Config: {...}>(\n  Component: component(...Config),\n): component(...Config) {\n  return Component;\n}\n\ntype Props = $ReadOnly<{bar: number, foo?: number}>;\n\nfunction MyComponent({bar, foo = 3}: Props): React.Node {}\n\nexport const MyEnhancedComponent = trivialHOC(MyComponent); // ERROR\n"})}),"\n",(0,r.jsx)(e.p,{children:"You can add an annotation to your exported component using component types:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-flow",metastring:"[]",children:"import * as React from 'react';\n\nfunction trivialHOC<Config: {...}>(\n  Component: component(...Config),\n): component(...Config) {\n  return Component;\n}\n\ntype Props = $ReadOnly<{bar: number, foo?: number}>;\n\nfunction MyComponent({bar, foo = 3}: Props): React.Node {}\n\nexport const MyEnhancedComponent: component(...Props) = trivialHOC(MyComponent); // OK\n"})})]})}function m(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}}}]);