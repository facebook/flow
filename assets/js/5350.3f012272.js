"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[5350],{15350:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"lang/variance","title":"Type Variance","description":"Variance is a topic that comes up fairly often in type systems. It is used to determine","source":"@site/docs/lang/variance.md","sourceDirName":"lang","slug":"/lang/variance","permalink":"/en/docs/lang/variance","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/lang/variance.md","tags":[],"version":"current","frontMatter":{"title":"Type Variance","slug":"/lang/variance"},"sidebar":"docsSidebar","previous":{"title":"Type Hierarchy","permalink":"/en/docs/lang/type-hierarchy"},"next":{"title":"Nominal & Structural Typing","permalink":"/en/docs/lang/nominal-structural"}}');var s=i(74848),r=i(28453);const a={title:"Type Variance",slug:"/lang/variance"},o=void 0,c={},d=[{value:"Covariance",id:"toc-covariance",level:2},{value:"Invariance",id:"toc-invariance",level:2},{value:"Contravariance",id:"toc-contravariance",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Variance is a topic that comes up fairly often in type systems. It is used to determine\nhow type parameters behave with respect to subtyping."}),"\n",(0,s.jsx)(n.p,{children:"First we'll setup a couple of classes that extend one another."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class Noun {}\nclass City extends Noun {}\nclass SanFrancisco extends City {}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We saw in the section on ",(0,s.jsx)(n.a,{href:"../../types/generics/#toc-variance-sigils",children:"generic types"}),"\nthat it is possible to\nuse variance sigils to describe when a type parameter is used in an output position,\nwhen it is used in an input position, and when it is used in either one."]}),"\n",(0,s.jsx)(n.p,{children:"Here we'll dive deeper into each one of these cases."}),"\n",(0,s.jsx)(n.h2,{id:"toc-covariance",children:"Covariance"}),"\n",(0,s.jsx)(n.p,{children:"Consider for example the type"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"type CovariantOf<X> = {\n  +prop: X;\n  getter(): X;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here, ",(0,s.jsx)(n.code,{children:"X"})," appears strictly in ",(0,s.jsx)(n.em,{children:"output"})," positions: it is used to read out information\nfrom objects ",(0,s.jsx)(n.code,{children:"o"})," of type ",(0,s.jsx)(n.code,{children:"CovariantOf<X>"}),", either through property accesses ",(0,s.jsx)(n.code,{children:"o.prop"}),",\nor through calls to ",(0,s.jsx)(n.code,{children:"o.getter()"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Notably, there is no way to input data through the reference to the object ",(0,s.jsx)(n.code,{children:"o"}),",\ngiven that ",(0,s.jsx)(n.code,{children:"prop"})," is a readonly property."]}),"\n",(0,s.jsxs)(n.p,{children:["When these conditions hold, we can use the sigil ",(0,s.jsx)(n.code,{children:"+"})," to annotate ",(0,s.jsx)(n.code,{children:"X"})," in the definition\nof ",(0,s.jsx)(n.code,{children:"CovariantOf"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"type CovariantOf<+X> = {\n  +prop: X;\n  getter(): X;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["These conditions have important implications on the way that we can treat an object\nof type ",(0,s.jsx)(n.code,{children:"CovariantOf<T>"}),' with respect to subtyping. As a reminder, subtyping rules\nhelp us answer the question: "given some context that expects values of type\n',(0,s.jsx)(n.code,{children:"T"}),", is it safe to pass in values of type ",(0,s.jsx)(n.code,{children:"S"}),'?" If this is the case, then ',(0,s.jsx)(n.code,{children:"S"})," is a\nsubtype of ",(0,s.jsx)(n.code,{children:"T"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Using our ",(0,s.jsx)(n.code,{children:"CovariantOf"})," definition, and given that ",(0,s.jsx)(n.code,{children:"City"})," is a subtype of ",(0,s.jsx)(n.code,{children:"Noun"}),", it is\nalso the case that ",(0,s.jsx)(n.code,{children:"CovariantOf<City>"})," is a subtype of ",(0,s.jsx)(n.code,{children:"CovariantOf<Noun>"}),". Indeed"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["it is safe to ",(0,s.jsx)(n.em,{children:"read"})," a property ",(0,s.jsx)(n.code,{children:"prop"})," of type ",(0,s.jsx)(n.code,{children:"City"})," when a property\nof type ",(0,s.jsx)(n.code,{children:"Noun"})," is expected, and"]}),"\n",(0,s.jsxs)(n.li,{children:["it is safe to ",(0,s.jsx)(n.em,{children:"return"})," values of type ",(0,s.jsx)(n.code,{children:"City"})," when calling ",(0,s.jsx)(n.code,{children:"getter()"}),", when\nvalues of type ",(0,s.jsx)(n.code,{children:"Noun"})," are expected."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Combining these two, it will always be safe to use ",(0,s.jsx)(n.code,{children:"CovariantOf<City>"})," whenever a\n",(0,s.jsx)(n.code,{children:"CovariantOf<Noun>"})," is expected."]}),"\n",(0,s.jsxs)(n.p,{children:["A commonly used example where covariance is used is ",(0,s.jsx)(n.a,{href:"../../types/arrays/#toc-readonlyarray",children:(0,s.jsx)(n.code,{children:"$ReadOnlyArray<T>"})}),".\nJust like with the ",(0,s.jsx)(n.code,{children:"prop"})," property, one cannot use a ",(0,s.jsx)(n.code,{children:"$ReadOnlyArray"})," reference to write data\nto an array. This allows more flexible subtyping rules: Flow only needs to prove that\n",(0,s.jsx)(n.code,{children:"S"})," is a subtype of ",(0,s.jsx)(n.code,{children:"T"})," to determine that ",(0,s.jsx)(n.code,{children:"$ReadOnlyArray<S>"})," is also a subtype\nof ",(0,s.jsx)(n.code,{children:"$ReadOnlyArray<T>"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"toc-invariance",children:"Invariance"}),"\n",(0,s.jsxs)(n.p,{children:["Let's see what happens if we try to relax the restrictions on the use of ",(0,s.jsx)(n.code,{children:"X"})," and make,\nfor example, ",(0,s.jsx)(n.code,{children:"prop"})," be a read-write property. We arrive at the type definition"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"type NonCovariantOf<X> = {\n  prop: X;\n  getter(): X;\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Let's also declare a variable ",(0,s.jsx)(n.code,{children:"nonCovariantCity"})," of type ",(0,s.jsx)(n.code,{children:"NonCovariantOf<City>"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"declare const nonCovariantCity: NonCovariantOf<City>;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now, it is not safe to consider ",(0,s.jsx)(n.code,{children:"nonCovariantCity"})," as an object of type ",(0,s.jsx)(n.code,{children:"NonCovariantOf<Noun>"}),".\nWere we allowed to do this, we could have the following declaration:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const nonCovariantNoun: NonCovariantOf<Noun> = nonCovariantCity;\n"})}),"\n",(0,s.jsx)(n.p,{children:"This type permits the following assignment:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"nonCovariantNoun.prop = new Noun;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["which would invalidate the original type for ",(0,s.jsx)(n.code,{children:"nonCovariantCity"})," as it would now be storing\na ",(0,s.jsx)(n.code,{children:"Noun"})," in its ",(0,s.jsx)(n.code,{children:"prop"})," field."]}),"\n",(0,s.jsxs)(n.p,{children:["What distinguishes ",(0,s.jsx)(n.code,{children:"NonCovariantOf"})," from the ",(0,s.jsx)(n.code,{children:"CovariantOf"})," definition is that type parameter ",(0,s.jsx)(n.code,{children:"X"})," is used both\nin input and output positions, as it is being used to both read and write to\nproperty ",(0,s.jsx)(n.code,{children:"prop"}),". Such a type parameter is called ",(0,s.jsx)(n.em,{children:"invariant"})," and is the default case\nof variance, thus requiring no prepending sigil:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"type InvariantOf<X> = {\n  prop: X;\n  getter(): X;\n  setter(X): void;\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"Assuming a variable"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"declare const invariantCity: InvariantOf<City>;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["it is ",(0,s.jsx)(n.em,{children:"not"})," safe to use ",(0,s.jsx)(n.code,{children:"invariantCity"})," in a context where:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["an ",(0,s.jsx)(n.code,{children:"InvariantOf<Noun>"})," is needed, because we should not be able to write a ",(0,s.jsx)(n.code,{children:"Noun"})," to property\n",(0,s.jsx)(n.code,{children:"prop"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["an ",(0,s.jsx)(n.code,{children:"InvariantOf<SanFrancisco>"})," is needed, because reading ",(0,s.jsx)(n.code,{children:"prop"})," could return a ",(0,s.jsx)(n.code,{children:"City"})," which\nmay not be ",(0,s.jsx)(n.code,{children:"SanFrancisco"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["In orther words, ",(0,s.jsx)(n.code,{children:"InvariantOf<City>"})," is neither a subtype of ",(0,s.jsx)(n.code,{children:"InvariantOf<Noun>"})," nor\na subtype of ",(0,s.jsx)(n.code,{children:"InvariantOf<SanFrancisco>"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"toc-contravariance",children:"Contravariance"}),"\n",(0,s.jsxs)(n.p,{children:["When a type parameter is only used in ",(0,s.jsx)(n.em,{children:"input"})," positions, we say that it is used in\na ",(0,s.jsx)(n.em,{children:"contravariant"})," way. This means that it only appears in positions through which\nwe write data to the structure. We use the sigil ",(0,s.jsx)(n.code,{children:"-"})," to describe this kind of type\nparameters:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"type ContravariantOf<-X> = {\n  -prop: X;\n  setter(X): void;\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:'Common contravariant positions are write-only properties and "setter" functions.'}),"\n",(0,s.jsxs)(n.p,{children:["An object of type ",(0,s.jsx)(n.code,{children:"ContravariantOf<City>"})," can be used whenever an object of type\n",(0,s.jsx)(n.code,{children:"ContravariantOf<SanFrancisco>"})," is expected, but not when a ",(0,s.jsx)(n.code,{children:"ContravariantOf<Noun>"})," is.\nIn other words, ",(0,s.jsx)(n.code,{children:"ContravariantOf<City>"})," is a subtype of ",(0,s.jsx)(n.code,{children:"ContravariantOf<SanFrancisco>"}),", but not\n",(0,s.jsx)(n.code,{children:"ContravariantOf<Noun>"}),".\nThis is because it is fine to write ",(0,s.jsx)(n.code,{children:"SanFrancisco"})," into a property that can have any ",(0,s.jsx)(n.code,{children:"City"})," written\nto, but it is not safe to write just any ",(0,s.jsx)(n.code,{children:"Noun"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var t=i(96540);const s={},r=t.createContext(s);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);