"use strict";(globalThis.webpackChunknew_website=globalThis.webpackChunknew_website||[]).push([[9041],{69041(e,n,i){i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"declarations/index","title":"Declaration Files","description":"Learn how to write types in .flow files.","source":"@site/docs/declarations/index.md","sourceDirName":"declarations","slug":"/declarations","permalink":"/en/docs/declarations","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/declarations/index.md","tags":[],"version":"current","frontMatter":{"title":"Declaration Files","slug":"/declarations","description":"Learn how to write types in .flow files."},"sidebar":"docsSidebar","previous":{"title":"Migration from existing patterns","permalink":"/en/docs/match/migration"},"next":{"title":"Library Definitions","permalink":"/en/docs/libdefs"}}');var t=i(74848),o=i(28453);const a={title:"Declaration Files",slug:"/declarations",description:"Learn how to write types in .flow files."},r=void 0,c={},l=[{value:"What&#39;s a Declaration File?",id:"toc-what-s-a-declaration-file",level:2},{value:"Inlining declarations in regular code",id:"toc-inlining-declarations-in-regular-code",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"toc-what-s-a-declaration-file",children:"What's a Declaration File?"}),"\n",(0,t.jsxs)(n.p,{children:["Let's look at a more general, and sometimes more convenient way to\ndeclare types for modules: ",(0,t.jsx)(n.code,{children:".flow"})," files."]}),"\n",(0,t.jsx)(n.p,{children:"There are two possible use cases, depending on whether an implementation file exists\nor not."}),"\n",(0,t.jsxs)(n.p,{children:["In the first case, the exported types of a module are declared in a ",(0,t.jsx)(n.em,{children:"declaration\nfile"})," ",(0,t.jsx)(n.code,{children:"<FILENAME>.flow"}),", that is located in the same directory as the corresponding ",(0,t.jsx)(n.em,{children:"implementation\nfile"})," ",(0,t.jsx)(n.code,{children:"<FILENAME>"}),". The declaration file completely shadows the colocated\nimplementation. In other words, Flow will completely ignore ",(0,t.jsx)(n.code,{children:"<FILENAME>"})," and just\nread ",(0,t.jsx)(n.code,{children:"<FILENAME>.flow"})," instead."]}),"\n",(0,t.jsxs)(n.p,{children:["In the second case, the implementation file is missing entirely. ",(0,t.jsx)(n.code,{children:"<FILENAME>.flow"}),"\nis treated as if it is named ",(0,t.jsx)(n.code,{children:"<FILENAME>"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Note that the ",(0,t.jsx)(n.code,{children:".flow"})," extension applies both to ",(0,t.jsx)(n.code,{children:".js"})," files as well as ",(0,t.jsx)(n.code,{children:".json"}),"\nones. The corresponding declaration files have extensions ",(0,t.jsx)(n.code,{children:".js.flow"})," and ",(0,t.jsx)(n.code,{children:".json.flow"}),",\nrespectively."]}),"\n",(0,t.jsxs)(n.p,{children:["Now let's see an example of the first case documented above. Suppose we have the\nfollowing code in a file ",(0,t.jsx)(n.code,{children:"src/LookBeforeYouLeap.js"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'import { isLeapYear } from "./Misc";\nif (isLeapYear("2020")) console.log("Yay!");\n'})}),"\n",(0,t.jsxs)(n.p,{children:["and suppose that ",(0,t.jsx)(n.code,{children:"src/Misc.js"})," has an incompatible implementation of ",(0,t.jsx)(n.code,{children:"isLeapYear"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"export function isLeapYear(year: number): boolean {\n  return year % 4 == 0; // yeah, this is approximate\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If we now create a declaration file ",(0,t.jsx)(n.code,{children:"src/Misc.js.flow"}),", the declarations in it\nwill be used instead of the code in ",(0,t.jsx)(n.code,{children:"src/Misc.js"}),". Let's say we have the\nfollowing declarations in ",(0,t.jsx)(n.code,{children:"src/Misc.js.flow"}),"."]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["NOTE: The syntax for declarations in a declaration file is the same as we've seen in\n",(0,t.jsx)(n.a,{href:"../libdefs/creation",children:"Creating Library Definitions section"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"declare export function isLeapYear(year: string): boolean;\n"})}),"\n",(0,t.jsx)(n.p,{children:"What do you think will happen?"}),"\n",(0,t.jsxs)(n.p,{children:["Right, the ",(0,t.jsx)(n.code,{children:"isLeapYear"})," call in ",(0,t.jsx)(n.code,{children:"src/LookBeforeYouLeap.js"})," will typecheck, since\nthe ",(0,t.jsx)(n.code,{children:"year"})," parameter expects a ",(0,t.jsx)(n.code,{children:"string"})," in the declaration file."]}),"\n",(0,t.jsx)(n.p,{children:"As this example shows, declaration files must be written with care: it is up\nto the programmer to ensure they are correct, otherwise they may hide type\nerrors."}),"\n",(0,t.jsx)(n.h2,{id:"toc-inlining-declarations-in-regular-code",children:"Inlining declarations in regular code"}),"\n",(0,t.jsx)(n.p,{children:"Sometimes it is useful to make declarations inline, as part of the source of\nan implementation file."}),"\n",(0,t.jsxs)(n.p,{children:["In the following example, say you want to finish writing\nthe function ",(0,t.jsx)(n.code,{children:"fooList"})," without bothering to mock up its dependencies first: a\nfunction ",(0,t.jsx)(n.code,{children:"foo"})," that takes a ",(0,t.jsx)(n.code,{children:"number"})," and returns a ",(0,t.jsx)(n.code,{children:"string"}),", and a class\n",(0,t.jsx)(n.code,{children:"List"})," that has a ",(0,t.jsx)(n.code,{children:"map"})," method. You can do this by including declarations for\n",(0,t.jsx)(n.code,{children:"List"})," and ",(0,t.jsx)(n.code,{children:"foo"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"declare class List<T> {\n  map<U>(f: (x: T) => U): List<U>;\n}\ndeclare function foo(n: number): string;\n\nfunction fooList(ns: List<number>): List<string> {\n  return ns.map(foo);\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Just don't forget to replace the declarations with proper implementations."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453(e,n,i){i.d(n,{R:()=>a,x:()=>r});var s=i(96540);const t={},o=s.createContext(t);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);