"use strict";(globalThis.webpackChunknew_website=globalThis.webpackChunknew_website||[]).push([[9251],{19251(e,n,t){t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>p,default:()=>y,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"types/mapped-types","title":"Mapped Types","description":"Flow\'s mapped types allow you to transform object types. They are useful for modeling complex runtime operations over objects.","source":"@site/docs/types/mapped-types.md","sourceDirName":"types","slug":"/types/mapped-types","permalink":"/en/docs/types/mapped-types","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/types/mapped-types.md","tags":[],"version":"current","frontMatter":{"title":"Mapped Types","slug":"/types/mapped-types"},"sidebar":"docsSidebar","previous":{"title":"Conditional Types","permalink":"/en/docs/types/conditional"},"next":{"title":"Type Guards","permalink":"/en/docs/types/type-guards"}}');var s=t(74848),o=t(28453),i=t(86543);const a={title:"Mapped Types",slug:"/types/mapped-types"},p=void 0,d={},l=[{value:"Basic Usage",id:"toc-basic-usage",level:2},{value:"Mapped Type Sources",id:"toc-mapped-type-sources",level:2},{value:"Distributive Mapped Types",id:"toc-distributive-mapped-types",level:2},{value:"Property Modifiers",id:"toc-property-modifiers",level:2},{value:"Mapped Type on Arrays  <SinceVersion></SinceVersion>",id:"toc-mapped-type-on-arrays",level:2},{value:"Adoption",id:"toc-adoption",level:2}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Flow's mapped types allow you to transform object types. They are useful for modeling complex runtime operations over objects."}),"\n",(0,s.jsx)(n.h2,{id:"toc-basic-usage",children:"Basic Usage"}),"\n",(0,s.jsxs)(n.p,{children:["Mapped Types have syntax similar to indexed object types but use the ",(0,s.jsx)(n.code,{children:"in"})," keyword:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type O = {foo: number, bar: string};\n\ntype Methodify<T> = () => T;\n\ntype MappedType = {[key in keyof O]: Methodify<O[key]>};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this example, ",(0,s.jsx)(n.code,{children:"MappedType"})," has all of the keys from ",(0,s.jsx)(n.code,{children:"O"})," with all of the value types transformed by\n",(0,s.jsx)(n.code,{children:"Methoditfy<O[key]>"}),". The ",(0,s.jsx)(n.code,{children:"key"})," variable is substituted for each key in ",(0,s.jsx)(n.code,{children:"O"})," when creating the property, so\nthis type evaluates to:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"{\n  foo: Methodify<O['foo']>,\n  bar: Methodify<O['bar']>,\n}\n= {\n  foo: () => number,\n  bar: () => string,\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"toc-mapped-type-sources",children:"Mapped Type Sources"}),"\n",(0,s.jsxs)(n.p,{children:["We call the type that comes after the ",(0,s.jsx)(n.code,{children:"in"})," keyword the ",(0,s.jsx)(n.em,{children:"source"})," of the mapped type. The source of\na mapped type must be a subtype of ",(0,s.jsx)(n.code,{children:"string | number | symbol"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":1,"startColumn":28,"endLine":1,"endColumn":34,"description":"Cannot instantiate mapped type [1] because boolean [2] is incompatible with `string | number | symbol`, so it cannot be used to generate keys for mapped type [1]. [incompatible-type]"}]',children:"type MappedType = {[key in boolean]: number}; // ERROR!\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Typically, you'll want to create a mapped type based on another object type. In this case, you\nshould write your mapped type using an inline ",(0,s.jsx)(n.code,{children:"keyof"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type GetterOf<T> = () => T;\ntype Obj = {foo: number, bar: string};\ntype MappedObj = {[key in keyof Obj]: GetterOf<Obj[key]>};\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["NOTE: ",(0,s.jsx)(n.code,{children:"keyof"})," only works inline in mapped types for now. Full support for ",(0,s.jsx)(n.code,{children:"keyof"})," is not yet available."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"But you do not need to use an object to generate a mapped type. You can also use a union of string\nliteral types to represent the keys of an object type:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type Union = 'foo' | 'bar' | 'baz';\ntype MappedType = {[key in Union]: number};\n// = {foo: number, bar: number, baz: number};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Importantly, when using string literals the union is collapsed into a ",(0,s.jsx)(n.em,{children:"single object type"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type MappedTypeFromKeys<Keys: string> = {[key in Keys]: number};\ntype MappedFooAndBar = MappedTypeFromKeys<'foo' | 'bar'>;\n// = {foo: number, bar: number}, not {foo: number} | {bar: number}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If you use a type like ",(0,s.jsx)(n.code,{children:"number"})," or ",(0,s.jsx)(n.code,{children:"string"})," in the source of your mapped type then Flow will create\nan indexer:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type MappedTypeFromKeys<Keys: string> = {[key in Keys]: number};\ntype MappedFooAndBarWithIndexer = MappedTypeFromKeys<'foo' | 'bar' | string>;\n// = {foo: number, bar: number, [string]: number}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"toc-distributive-mapped-types",children:"Distributive Mapped Types"}),"\n",(0,s.jsxs)(n.p,{children:["When the mapped type uses an inline ",(0,s.jsx)(n.code,{children:"keyof"})," or a type parameter bound by a ",(0,s.jsx)(n.code,{children:"$Keys"}),"\nFlow will distribute the mapped type over unions of object types."]}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"// This mapped type uses keyof inline\ntype MakeAllValuesNumber<O: {...}> = {[key in keyof O]: number};\ntype ObjWithFoo = {foo: string};\ntype ObjWithBar = {bar: string};\n\ntype DistributedMappedType = MakeAllValuesNumber<\n  | ObjWithFoo\n  | ObjWithBar\n>; // = {foo: number} | {bar: number};\n\n// This mapped type uses a type parameter bound by $Keys\ntype Pick<O: {...}, Keys: $Keys<O>> = {[key in Keys]: O[key]};\ntype O1 = {foo: number, bar: number};\ntype O2 = {bar: string, baz: number};\ntype PickBar = Pick<O1 | O2, 'bar'>; // = {bar: number} | {bar: string};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Distributive mapped types will also distribute over ",(0,s.jsx)(n.code,{children:"null"})," and ",(0,s.jsx)(n.code,{children:"undefined"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type Distributive<O: ?{...}> = {[key in keyof O]: O[key]};\ntype Obj = {foo: number};\ntype MaybeMapped = Distributive<?Obj>;// = ?{foo: number}\nnull as MaybeMapped; // OK\nundefined as MaybeMapped; // OK\n({foo: 3}) as MaybeMapped; // OK\n"})}),"\n",(0,s.jsx)(n.h2,{id:"toc-property-modifiers",children:"Property Modifiers"}),"\n",(0,s.jsxs)(n.p,{children:["You can also add ",(0,s.jsx)(n.code,{children:"+"})," or ",(0,s.jsx)(n.code,{children:"-"})," variance modifiers and the optionality modifier ",(0,s.jsx)(n.code,{children:"?"})," in mapped types:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type O = {foo: number, bar: string}\ntype ReadOnlyPartialO = {+[key in keyof O]?: O[key]}; // = {+foo?: number, +bar?: string};\n"})}),"\n",(0,s.jsx)(n.p,{children:"When no variance nor optionality modifiers are provided and the mapped type is distributive,\nthe variance and optionality are determined by the input object:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type O = {+foo: number, bar?: string};\ntype Mapped = {[key in keyof O]: O[key]}; // = {+foo: number, bar?: string}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Otherwise, the properties are read-write and required when no property modifiers are present:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type Union = 'foo' | 'bar' | 'baz';\ntype MappedType = {[key in Union]: number};\n// = {foo: number, bar: number, baz: number};\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"NOTE: Flow does not yet support removing variance or optionality modifiers."}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"toc-mapped-type-on-arrays",children:["Mapped Type on Arrays  ",(0,s.jsx)(i.V,{version:"0.246"})]}),"\n",(0,s.jsx)(n.p,{children:"Mapped type also works on array or tuple inputs. If the mapped type is in the form of"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"{[K in keyof <type_1>]: <type_2>}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["then ",(0,s.jsx)(n.code,{children:"type_1"})," is allowed to be an array or tuple type."]}),"\n",(0,s.jsx)(n.p,{children:"This feature will be especially useful if you want to map over elements of a tuple:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":5,"startColumn":1,"endLine":5,"endColumn":2,"description":"Cannot cast empty string to indexed access because string [1] is incompatible with boolean [2]. [incompatible-type]"},{"startLine":6,"startColumn":1,"endLine":6,"endColumn":5,"description":"Cannot cast `false` to indexed access because boolean [1] is incompatible with string [2]. [incompatible-type]"},{"startLine":8,"startColumn":1,"endLine":8,"endColumn":9,"description":"Cannot assign `true` to `mapped[0]` because tuple element at index `0` [1] labeled `a` is not writable. [cannot-write]"}]',children:"type Tuple = [+a: number, b?: string];\ntype MappedTuple = {[K in keyof Tuple]: Tuple[K] extends number ? boolean : string};\nconst a: MappedTuple[0] = true;\nconst b: MappedTuple[1] = '';\n'' as MappedTuple[0] // error\nfalse as MappedTuple[1] // error\ndeclare const mapped: MappedTuple;\nmapped[0] = true; // error: cannot-write\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For now, the only supported property modifier on array input is the optionality modifier ",(0,s.jsx)(n.code,{children:"?"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":21,"endLine":3,"endColumn":49,"description":"Mapped Types do not yet support variance annotations on array inputs. [invalid-mapped-type]"},{"startLine":4,"startColumn":21,"endLine":4,"endColumn":49,"description":"Mapped Types do not yet support variance annotations on array inputs. [invalid-mapped-type]"}]',children:"type Tuple = [+a: number, b?: string];\ntype Supported = {[K in keyof Tuple]?: string};\ntype Unsupported1 = {+[K in keyof Tuple]: string};\ntype Unsupported2 = {-[K in keyof Tuple]: string};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"toc-adoption",children:"Adoption"}),"\n",(0,s.jsx)(n.p,{children:"To use mapped types, you need to upgrade your infrastructure so that it supports the syntax:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"flow"})," and ",(0,s.jsx)(n.code,{children:"flow-parser"}),": 0.210.0. Between v0.210.0 to v0.211.1, you need to explicitly enable it in your .flowconfig, under the ",(0,s.jsx)(n.code,{children:"[options]"})," heading, add ",(0,s.jsx)(n.code,{children:"mapped_type=true"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"prettier"}),": 3"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"babel"})," with ",(0,s.jsx)(n.code,{children:"babel-plugin-syntax-hermes-parser"}),". See ",(0,s.jsx)(n.a,{href:"../../tools/babel/",children:"our Babel guide"})," for setup instructions."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"eslint"})," with ",(0,s.jsx)(n.code,{children:"hermes-eslint"}),". See ",(0,s.jsx)(n.a,{href:"../../tools/eslint/",children:"our ESLint guide"})," for setup instructions."]}),"\n"]})]})}function y(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},86543(e,n,t){t.d(n,{V:()=>s,v:()=>o});t(96540);var r=t(74848);function s(e){let{version:n}=e;return(0,r.jsxs)("span",{class:"version added",title:`Added in ${n}`,children:["\u2265",n]})}function o(e){let{version:n}=e;return(0,r.jsxs)("span",{class:"version removed",title:`Removed after ${n}`,children:["\u2264",n]})}},28453(e,n,t){t.d(n,{R:()=>i,x:()=>a});var r=t(96540);const s={},o=r.createContext(s);function i(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);