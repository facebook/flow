"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[6314],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>l});var o=n(96540);const s={},r=o.createContext(s);function i(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(r.Provider,{value:t},e.children)}},56314:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"types/typeof","title":"Typeof Types","description":"JavaScript has a typeof operator which returns a string describing a value.","source":"@site/docs/types/typeof.md","sourceDirName":"types","slug":"/types/typeof","permalink":"/en/docs/types/typeof","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/types/typeof.md","tags":[],"version":"current","frontMatter":{"title":"Typeof Types","slug":"/types/typeof"},"sidebar":"docsSidebar","previous":{"title":"Type Guards","permalink":"/en/docs/types/type-guards"},"next":{"title":"Type Casting Expressions","permalink":"/en/docs/types/casting"}}');var s=n(74848),r=n(28453);const i={title:"Typeof Types",slug:"/types/typeof"},l=void 0,a={},c=[{value:"<code>typeof</code> type syntax",id:"toc-typeof-type-syntax",level:2},{value:"<code>typeof</code> inherits behaviors of inference",id:"toc-typeof-inherits-behaviors-of-inference",level:2},{value:"<code>typeof</code> inherits behaviors of other types",id:"toc-typeof-inherits-behaviors-of-other-types",level:2}];function p(e){const t={code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["JavaScript has a ",(0,s.jsx)(t.code,{children:"typeof"})," operator which returns a string describing a value."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-flow",metastring:"[]",children:"typeof 1 === 'number'\ntypeof true === 'boolean'\ntypeof 'three' === 'string'\n"})}),"\n",(0,s.jsx)(t.p,{children:"However it is limited in that this string only describes so much about the type."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-flow",metastring:"[]",children:"typeof {foo: true} === 'object'\ntypeof null === 'object'\ntypeof [true, false] === 'object'\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In Flow, there is a similar ",(0,s.jsx)(t.code,{children:"typeof"})," type operator, but it's much more powerful."]}),"\n",(0,s.jsxs)(t.h2,{id:"toc-typeof-type-syntax",children:[(0,s.jsx)(t.code,{children:"typeof"})," type syntax"]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"typeof"})," operator returns the Flow type of a given value to be used as a type."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":25,"endLine":3,"endColumn":31,"description":"Cannot assign `\'world\'` to `num3` because string [1] is incompatible with number [2]. [incompatible-type]"},{"startLine":7,"startColumn":27,"endLine":7,"endColumn":28,"description":"Cannot assign `42` to `bool3` because number [1] is incompatible with boolean [2]. [incompatible-type]"},{"startLine":11,"startColumn":25,"endLine":11,"endColumn":29,"description":"Cannot assign `false` to `str3` because boolean [1] is incompatible with string [2]. [incompatible-type]"}]',children:"let num1 = 42;\nlet num2: typeof num1 = 3.14;     // Works!\nlet num3: typeof num1 = 'world';  // Error!\n\nlet bool1 = true;\nlet bool2: typeof bool1 = false;  // Works!\nlet bool3: typeof bool1 = 42;     // Error!\n\nlet str1 = 'hello';\nlet str2: typeof str1 = 'world'; // Works!\nlet str3: typeof str1 = false;   // Error!\n"})}),"\n",(0,s.jsxs)(t.p,{children:["You can use any value with ",(0,s.jsx)(t.code,{children:"typeof"}),", as long as the argument itself is a variable or member access:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-flow",metastring:'[{"startLine":8,"startColumn":17,"endLine":8,"endColumn":17,"description":"`typeof` can only be used to get the type of variables."}]',children:"let obj1 = {foo: 1, bar: true, baz: 'three'};\nlet obj2: typeof obj1 = {foo: 42, bar: false, baz: 'hello'};\nlet num: typeof obj1.bar = 1;\n\nlet arr1 = [1, 2, 3];\nlet arr2: typeof arr1 = [3, 2, 1];\n\ntype T = typeof {a: 1}; // Invalid!\n"})}),"\n",(0,s.jsxs)(t.h2,{id:"toc-typeof-inherits-behaviors-of-inference",children:[(0,s.jsx)(t.code,{children:"typeof"})," inherits behaviors of inference"]}),"\n",(0,s.jsxs)(t.p,{children:["When you use ",(0,s.jsx)(t.code,{children:"typeof"}),", you're taking the results of Flow's inference and\nasserting it as a type. While this can be very useful, it can also lead to some\nunexpected results."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, when you use literal values in Flow, their inferred type is the\nprimitive that it belongs to. Thus, the number 42 has the inferred type of\n",(0,s.jsx)(t.code,{children:"number"}),". You can see this when you use ",(0,s.jsx)(t.code,{children:"typeof"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-flow",metastring:"[]",children:"let num1 = 42;\nlet num2: typeof num1 = 3.14;    // Works!\n\nlet bool1 = true;\nlet bool2: typeof bool1 = false; // Works!\n\nlet str1 = 'hello';\nlet str2: typeof str1 = 'world'; // Works!\n"})}),"\n",(0,s.jsxs)(t.p,{children:["However, this only happens with the inferred type. If you specify the literal\ntype, it will be used in ",(0,s.jsx)(t.code,{children:"typeof"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-flow",metastring:'[{"startLine":2,"startColumn":25,"endLine":2,"endColumn":28,"description":"Cannot assign `3.14` to `num2` because number literal `3.14` [1] is incompatible with number literal `42` [2]. [incompatible-type]"},{"startLine":5,"startColumn":27,"endLine":5,"endColumn":31,"description":"Cannot assign `false` to `bool2` because boolean literal `false` [1] is incompatible with boolean literal `true` [2]. [incompatible-type]"},{"startLine":8,"startColumn":25,"endLine":8,"endColumn":31,"description":"Cannot assign `\'world\'` to `str2` because string literal `world` [1] is incompatible with string literal `hello` [2]. [incompatible-type]"}]',children:"let num1: 42 = 42;\nlet num2: typeof num1 = 3.14;    // Error!\n\nlet bool1: true = true;\nlet bool2: typeof bool1 = false; // Error!\n\nlet str1: 'hello' = 'hello';\nlet str2: typeof str1 = 'world'; // Error!\n"})}),"\n",(0,s.jsxs)(t.h2,{id:"toc-typeof-inherits-behaviors-of-other-types",children:[(0,s.jsx)(t.code,{children:"typeof"})," inherits behaviors of other types"]}),"\n",(0,s.jsx)(t.p,{children:"There are many different types in Flow, some of these types behave differently\nthan others. These differences make sense for that particular type but not for\nothers."}),"\n",(0,s.jsxs)(t.p,{children:["When you use ",(0,s.jsx)(t.code,{children:"typeof"}),", you're inserting another type with all of its behaviors.\nThis can make ",(0,s.jsx)(t.code,{children:"typeof"})," seem inconsistent where it is not."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, if you use ",(0,s.jsx)(t.code,{children:"typeof"})," with a class you need to remember that classes\nare ",(0,s.jsx)(t.em,{children:"nominally"})," typed instead of ",(0,s.jsx)(t.em,{children:"structurally"})," typed. So that two classes with\nthe same exact shape are not considered equivalent."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-flow",metastring:'[{"startLine":9,"startColumn":29,"endLine":9,"endColumn":37,"description":"Cannot assign `YourClass` to `test1` because `YourClass` [1] is incompatible with `MyClass` [2]. [incompatible-type]"}]',children:"class MyClass {\n  method(val: number) { /* ... */ }\n}\n\nclass YourClass {\n  method(val: number) { /* ... */ }\n}\n\nlet test1: typeof MyClass = YourClass; // Error!\nlet test2: typeof MyClass = MyClass;   // Works!\n"})})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}}}]);