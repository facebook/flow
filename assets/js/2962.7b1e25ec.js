"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[2962],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var s=t(96540);const a={},i=s.createContext(a);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:n},e.children)}},32962:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"match/index","title":"Match Expressions and Statements","description":"match an input value against a series of patterns, which conditionally check the structure of the input and extract values, and either produce an expression (match expressions) or execute a block (match statements).","source":"@site/docs/match/index.md","sourceDirName":"match","slug":"/match","permalink":"/en/docs/match","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/match/index.md","tags":[],"version":"current","frontMatter":{"title":"Match Expressions and Statements","description":"match an input value against a series of patterns, which conditionally check the structure of the input and extract values, and either produce an expression (match expressions) or execute a block (match statements).","slug":"/match"},"sidebar":"docsSidebar","previous":{"title":"Migrating from legacy patterns","permalink":"/en/docs/enums/migrating-legacy-patterns"},"next":{"title":"Match Patterns","permalink":"/en/docs/match/patterns"}}');var a=t(74848),i=t(28453);const r={title:"Match Expressions and Statements",description:"match an input value against a series of patterns, which conditionally check the structure of the input and extract values, and either produce an expression (match expressions) or execute a block (match statements).",slug:"/match"},c=void 0,o={},l=[{value:"Match Expressions",id:"match-expressions",level:2},{value:"Match Statements",id:"match-statements",level:2},{value:"Exhaustive Checking",id:"exhaustive-checking",level:2},{value:"More",id:"more",level:2},{value:"Adoption",id:"adoption",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.em,{children:["An experimental Flow language feature. See ",(0,a.jsx)(n.a,{href:"#adoption",children:"adoption"})," for how to enable."]})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"match"})," an input value against a series of ",(0,a.jsx)(n.a,{href:"./patterns",children:"patterns"}),", which conditionally check the structure of the input and extract values, and either produce an expression (",(0,a.jsx)(n.code,{children:"match"})," expressions) or execute a block (",(0,a.jsx)(n.code,{children:"match"})," statements)."]}),"\n",(0,a.jsxs)(n.p,{children:["You can ",(0,a.jsxs)(n.a,{href:"./migration#replacing-switch",children:["replace ",(0,a.jsx)(n.code,{children:"switch"})," statements"]})," using ",(0,a.jsx)(n.code,{children:"match"}),", avoiding the problems associated with ",(0,a.jsx)(n.code,{children:"switch"})," (like fall-through behavior) while gaining benefits like ",(0,a.jsx)(n.a,{href:"#exhaustive-checking",children:"exhaustiveness checks"})," and complex pattern support."]}),"\n",(0,a.jsxs)(n.p,{children:["You can also ",(0,a.jsx)(n.a,{href:"./migration#replacing-conditional-ternary-expressions",children:"replace nested conditional ternary expressions"})," using ",(0,a.jsx)(n.code,{children:"match"})," expressions, making your code much more readable while gaining the power of ",(0,a.jsx)(n.code,{children:"match"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"component AgePane(\n  maybeAge?: {type: 'valid', age: number} | {type: 'error', msg: string}\n) {\n  return match (maybeAge) {\n    {type: 'valid', const age} if (age < 0) =>\n      <Err>Age cannot be negative!</Err>,\n    {type: 'valid', const age} => <Pane>Age: {age}</Pane>,\n    {type: 'error', const msg} => <Err>{msg}</Err>,\n    undefined => <Err>Age is not defined.</Err>,\n  };\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"match-expressions",children:"Match Expressions"}),"\n",(0,a.jsx)(n.p,{children:"Match expressions allow you to define conditional logic as an expression. They can replace nested conditional ternary expressions."}),"\n",(0,a.jsx)(n.p,{children:"A match expression is made up of its argument and a series of cases, each which define a pattern and an expression body. Each pattern is checked in sequence, and the resulting expression is the one accompanying the matching pattern. The resulting expression is typed as the union of every case expression type."}),"\n",(0,a.jsxs)(n.p,{children:["A pattern can be followed by a guard, with the ",(0,a.jsx)(n.code,{children:"if (<cond-expression>)"})," syntax. If the pattern matches, the expression in the guard is also executed, and the entire case only matches if the result is truthy."]}),"\n",(0,a.jsx)(n.p,{children:"Example structure:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const e = match (<arg>) {\n  <pattern-1> => <expression-1>,\n  <pattern-2> if (<cond>) => <expression-2>,\n  <pattern-3> => <expression-3>,\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The guard applies to the entire pattern, including ",(0,a.jsx)(n.a,{href:"./patterns#or-patterns",children:'"or" patterns'}),", e.g. ",(0,a.jsx)(n.code,{children:"1 | 2 if (cond)"})," will first match if the value is ",(0,a.jsx)(n.code,{children:"1 | 2"}),", and then finally succeed if ",(0,a.jsx)(n.code,{children:"cond"})," is also true. Guarded cases do not count toward ",(0,a.jsx)(n.a,{href:"#exhaustive-checking",children:"exhaustiveness checks"}),", since they may or may not match based on the condition."]}),"\n",(0,a.jsxs)(n.p,{children:["You can initialize two or more variables using a ",(0,a.jsx)(n.code,{children:"match"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// Using a tuple:\nconst [color, size] = match (status) {\n  Status.Active => ['green', 2],\n  Status.Paused => ['yellow', 1],\n  Status.Off => ['red', 0],\n};\n\n// Using an object (especially useful for more than two variables):\nconst {color, size} = match (status) {\n  Status.Active => {color: 'green', size: 2},\n  Status.Paused => {color: 'yellow', size: 1},\n  Status.Off => {color: 'red', size: 0},\n};\n"})}),"\n",(0,a.jsx)(n.p,{children:"Match expressions cannot be used in an expression statement position, as that is reserved for match statements."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"match (<arg>) {} //  This is a match statement, not a match expression\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If no pattern matches, Flow will error due to a non-exhaustive match, and an exception will be thrown at runtime. You can use a ",(0,a.jsx)(n.a,{href:"./patterns#wildcard-patterns",children:"wildcard"})," (",(0,a.jsx)(n.code,{children:"_"}),") or ",(0,a.jsx)(n.a,{href:"./patterns#variable-declaration-patterns",children:"variable declaration pattern"})," (",(0,a.jsx)(n.code,{children:"const x"}),") as the last case of a match to catch all remaining possible matches."]}),"\n",(0,a.jsxs)(n.p,{children:["To throw an exception in a ",(0,a.jsx)(n.code,{children:"match"})," expression case body you can't use ",(0,a.jsx)(n.code,{children:"throw"})," as it is a statement, and ",(0,a.jsx)(n.code,{children:"match"})," expressions require expression bodies. Instead, you can use ",(0,a.jsx)(n.code,{children:"invariant(false, <msg>)"}),", which Flow understands will always throw (with the supplied message)."]}),"\n",(0,a.jsxs)(n.p,{children:["Match expression case bodies do not yet support usage of ",(0,a.jsx)(n.code,{children:"yield"}),", ",(0,a.jsx)(n.code,{children:"yield*"}),", or ",(0,a.jsx)(n.code,{children:"await"}),". Unlike match expressions, ",(0,a.jsx)(n.a,{href:"#match-statements",children:"match statements"})," do support these keywords."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"Fine print:"})," The opening brace ",(0,a.jsx)(n.code,{children:"{"})," is required to be on the same line as the match argument ",(0,a.jsx)(n.code,{children:"match (<arg>)"}),". This way, we can introduce this feature in a way that is backwards compatible with all existing syntax: ",(0,a.jsx)(n.code,{children:"match(x);"})," is still a call to a function called ",(0,a.jsx)(n.code,{children:"match"}),". Prettier will automatically format match expressions in this way."]}),"\n",(0,a.jsx)(n.h2,{id:"match-statements",children:"Match Statements"}),"\n",(0,a.jsxs)(n.p,{children:["Match statements can replace ",(0,a.jsx)(n.code,{children:"switch"})," statements or chained ",(0,a.jsx)(n.code,{children:"if"}),"-",(0,a.jsx)(n.code,{children:"else"})," statements. Similar to match expressions, they have an argument and a series of cases. The difference is each case body is a block (i.e. ",(0,a.jsx)(n.code,{children:"{ ...statements... }"}),") instead of an expression, and the construct is a statement so it does not result in a value. No ",(0,a.jsx)(n.code,{children:"break"})," needed: the cases don\u2019t fall-through (but you can still combine multiple patterns using ",(0,a.jsx)(n.a,{href:"./patterns#or-patterns",children:'"or" patterns'})," ",(0,a.jsx)(n.code,{children:"|"}),")."]}),"\n",(0,a.jsx)(n.p,{children:"Example structure:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"match (<arg>) {\n  <pattern-1> => {\n    <statements-1>;\n  }\n  <pattern-2> if (<cond>) => {\n    <statements-2>;\n  }\n  <pattern-3> => {\n    <statements-3>;\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"Fine print:"})," Like match expressions, the opening brace ",(0,a.jsx)(n.code,{children:"{"})," is required to be on the same line as the match argument ",(0,a.jsx)(n.code,{children:"match (<arg>)"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"exhaustive-checking",children:"Exhaustive Checking"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"match"})," requires that you have considered all cases of the input. If you don't, Flow will error and tell you what patterns you could add to make the match exhaustive:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":1,"endLine":3,"endColumn":5,"description":"`match` hasn\'t checked all possible cases of the input type. To fix, add the missing pattern: `\'details\'` to match string literal `details` [1]. [match-not-exhaustive]"}]',children:"declare const tab: 'home' | 'details' | 'settings';\n\nmatch (tab) { // ERROR\n  'home' => {}\n  'settings' => {}\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Checks on ",(0,a.jsx)(n.a,{href:"../types/unions#toc-disjoint-object-unions",children:"disjoint object unions"})," are supported."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":1,"endLine":3,"endColumn":5,"description":"`match` hasn\'t checked all possible cases of the input type. To fix, add the missing pattern: `{type: \'ok\', value: _}` to match object type [1]. [match-not-exhaustive]"}]',children:"declare const result: {type: 'ok', value: number} | {type: 'error'};\n\nmatch (result) { // ERROR\n  {type: 'error'} => {}\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"It even works for nested structures:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":5,"startColumn":10,"endLine":5,"endColumn":14,"description":"`match` hasn\'t checked all possible cases of the input type. To fix, add the missing pattern: `[\'end\', \'below\']` to match const array literal [1]. [match-not-exhaustive]"}]',children:"function getStyle(\n  align: 'start' | 'end',\n  position: 'above' | 'below',\n) {\n  return match ([align, position]) { // ERROR\n    ['start', 'above'] => 0,\n    ['start', 'below'] => 1,\n    ['end', 'above'] => 2,\n  };\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Flow will also error if a pattern is unused:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":7,"startColumn":3,"endLine":7,"endColumn":11,"description":"This match pattern [1] is unused. The values it matches are either already covered by previous patterns, or are not part of the input type. To fix, either remove this pattern or restructure previous patterns. [match-unused-pattern]"}]',children:"declare const tab: 'home' | 'details' | 'settings';\n\nmatch (tab) {\n  'home' => {}\n  'details' => {}\n  'settings' => {}\n  'invalid' => {} // ERROR\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"more",children:"More"}),"\n",(0,a.jsxs)(n.p,{children:["Learn more about ",(0,a.jsx)(n.a,{href:"./patterns",children:"match patterns"}),", including primitive value patterns, array and object patterns, variable declaration patterns, and \u201cor\u201d and \u201cas\u201d patterns."]}),"\n",(0,a.jsxs)(n.p,{children:["You can also ",(0,a.jsx)(n.a,{href:"./migration",children:"migrate from existing patterns"})," like ",(0,a.jsx)(n.code,{children:"switch"})," or conditional ternary expressions."]}),"\n",(0,a.jsx)(n.h2,{id:"adoption",children:"Adoption"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Flow: 0.274.1+ with option: ",(0,a.jsx)(n.code,{children:"experimental.pattern_matching=true"})]}),"\n",(0,a.jsxs)(n.li,{children:["Babel: use the ",(0,a.jsx)(n.a,{href:"https://www.npmjs.com/package/babel-plugin-syntax-hermes-parser",children:"babel-plugin-syntax-hermes-parser"})," plugin version 0.29+, see our ",(0,a.jsx)(n.a,{href:"../tools/babel",children:"Babel guide"})," for more details."]}),"\n",(0,a.jsxs)(n.li,{children:["ESLint: use ",(0,a.jsx)(n.a,{href:"https://www.npmjs.com/package/hermes-eslint",children:"hermes-eslint"})," plugin version 0.29+, see our ",(0,a.jsx)(n.a,{href:"../tools/eslint",children:"ESLint guide"})," for more details."]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}}}]);