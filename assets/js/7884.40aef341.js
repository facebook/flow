"use strict";(globalThis.webpackChunknew_website=globalThis.webpackChunknew_website||[]).push([[7884],{37884(e,n,i){i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"config/declarations","title":".flowconfig [declarations]","description":"Often third-party libraries have broken type definitions or have type","source":"@site/docs/config/declarations.md","sourceDirName":"config","slug":"/config/declarations","permalink":"/en/docs/config/declarations","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/config/declarations.md","tags":[],"version":"current","frontMatter":{"title":".flowconfig [declarations]","slug":"/config/declarations"},"sidebar":"docsSidebar","previous":{"title":".flowconfig [untyped]","permalink":"/en/docs/config/untyped"},"next":{"title":".flowconfig [libs]","permalink":"/en/docs/config/libs"}}');var t=i(74848),o=i(28453);const s={title:".flowconfig [declarations]",slug:"/config/declarations"},c=void 0,l={},d=[];function a(e){const n={a:"a",code:"code",em:"em",li:"li",ol:"ol",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Often third-party libraries have broken type definitions or have type\ndefinitions only compatible with a certain version of Flow. In those cases it\nmay be useful to use type information from the third-party libraries without\ntypechecking their contents."}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"[declarations]"})," section in a ",(0,t.jsx)(n.code,{children:".flowconfig"})," file tells Flow to parse files\nmatching the specified regular expressions in ",(0,t.jsx)(n.em,{children:"declaration mode"}),". In declaration\nmode the code is not typechecked. However, the signatures of functions, classes,\netc are extracted and used by the typechecker when checking other code."]}),"\n",(0,t.jsxs)(n.p,{children:["Conceptually one can think of declaration mode as if Flow still typechecks the\nfiles but acts as if there is a ",(0,t.jsx)(n.code,{children:"$FlowFixMe"})," comment on every line."]}),"\n",(0,t.jsxs)(n.p,{children:["See also ",(0,t.jsx)(n.a,{href:"../untyped",children:(0,t.jsx)(n.code,{children:"[untyped]"})})," for not typechecking files, and instead using ",(0,t.jsx)(n.code,{children:"any"})," for all contents."]}),"\n",(0,t.jsx)(n.p,{children:"Things to keep in mind:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Declaration mode should only be used for existing third-party code. You\nshould never use this for code under your control."}),"\n",(0,t.jsxs)(n.li,{children:["These are ",(0,t.jsx)(n.a,{href:"http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp",children:"OCaml regular expressions"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["These regular expressions match against absolute paths. They probably should\nstart with ",(0,t.jsx)(n.code,{children:".*"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["An example ",(0,t.jsx)(n.code,{children:"[declarations]"})," section might look like:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"[declarations]\n.*/third_party/.*\n.*/src/\\(foo\\|bar\\)/.*\n.*\\.decl\\.js\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This ",(0,t.jsx)(n.code,{children:"[declarations]"})," section will parse in declaration mode:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Any file or directory under a directory named ",(0,t.jsx)(n.code,{children:"third_party"})]}),"\n",(0,t.jsxs)(n.li,{children:["Any file or directory under ",(0,t.jsx)(n.code,{children:".*/src/foo"})," or under ",(0,t.jsx)(n.code,{children:".*/src/bar"})]}),"\n",(0,t.jsxs)(n.li,{children:["Any file that ends with the extension ",(0,t.jsx)(n.code,{children:".decl.js"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["You may use the ",(0,t.jsx)(n.code,{children:"<PROJECT_ROOT>"})," placeholder in your regular expressions.\nAt runtime, Flow will treat the placeholder as if it were the absolute\npath to the project's root directory. This is useful for writing regular\nexpressions that are relative rather than absolute."]}),"\n",(0,t.jsx)(n.p,{children:"For example, you can write:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"[declarations]\n<PROJECT_ROOT>/third_party/.*\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Which would parse in declaration mode any file or directory under the directory\nnamed ",(0,t.jsx)(n.code,{children:"third_party/"})," within the project root. However, unlike the previous\nexample's ",(0,t.jsx)(n.code,{children:".*/third_party/.*"}),", it would NOT parse files or directories under\ndirectories named ",(0,t.jsx)(n.code,{children:"third_party/"}),", like ",(0,t.jsx)(n.code,{children:"src/third_party/"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},28453(e,n,i){i.d(n,{R:()=>s,x:()=>c});var r=i(96540);const t={},o=r.createContext(t);function s(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);