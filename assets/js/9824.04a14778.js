"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[9824],{28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>i});var a=r(96540);const t={},s=a.createContext(t);function o(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),a.createElement(s.Provider,{value:n},e.children)}},67443:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"types/interfaces","title":"Interfaces","description":"Classes in Flow are nominally typed. This means that when you have two separate","source":"@site/docs/types/interfaces.md","sourceDirName":"types","slug":"/types/interfaces","permalink":"/en/docs/types/interfaces","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/types/interfaces.md","tags":[],"version":"current","frontMatter":{"title":"Interfaces","slug":"/types/interfaces"},"sidebar":"docsSidebar","previous":{"title":"Opaque Type Aliases","permalink":"/en/docs/types/opaque-types"},"next":{"title":"Generics","permalink":"/en/docs/types/generics"}}');var t=r(74848),s=r(28453);const o={title:"Interfaces",slug:"/types/interfaces"},i=void 0,c={},l=[{value:"Interface Syntax",id:"toc-interface-syntax",level:2},{value:"Interface Methods",id:"toc-interface-methods",level:3},{value:"Interface Properties",id:"toc-interface-properties",level:3},{value:"Interfaces as maps",id:"toc-interfaces-as-maps",level:3},{value:"Interface Generics",id:"toc-interface-generics",level:3},{value:"Interface property variance (read-only and write-only)",id:"toc-interface-property-variance-read-only-and-write-only",level:2},{value:"Covariant (read-only) properties on interfaces",id:"toc-covariant-read-only-properties-on-interfaces",level:4},{value:"Contravariant (write-only) properties on interfaces",id:"toc-contravariant-write-only-properties-on-interfaces",level:4}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"../classes",children:"Classes"})," in Flow are ",(0,t.jsx)(n.a,{href:"../../lang/nominal-structural",children:"nominally typed"}),". This means that when you have two separate\nclasses you cannot use one in place of the other even when they have the same\nexact properties and methods:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":9,"startColumn":18,"endLine":9,"endColumn":26,"description":"Cannot assign `new Bar()` to `foo` because `Bar` [1] is incompatible with `Foo` [2]. [incompatible-type]"}]',children:"class Foo {\n  serialize(): string { return '[Foo]'; }\n}\n\nclass Bar {\n  serialize(): string { return '[Bar]'; }\n}\n\nconst foo: Foo = new Bar(); // Error!\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Instead, you can use ",(0,t.jsx)(n.code,{children:"interface"})," in order to declare the structure of the class\nthat you are expecting."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"interface Serializable {\n  serialize(): string;\n}\n\nclass Foo {\n  serialize(): string { return '[Foo]'; }\n}\n\nclass Bar {\n  serialize(): string { return '[Bar]'; }\n}\n\nconst foo: Serializable = new Foo(); // Works!\nconst bar: Serializable = new Bar(); // Works!\n"})}),"\n",(0,t.jsx)(n.p,{children:"You can also declare an anonymous interface:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"class Foo {\n  a: number;\n}\n\nfunction getNumber(o: interface {a: number}): number {\n  return o.a;\n}\n\ngetNumber(new Foo()); // Works!\n"})}),"\n",(0,t.jsxs)(n.p,{children:["You can also use ",(0,t.jsx)(n.code,{children:"implements"})," to tell Flow that you want the class to match an\ninterface. This prevents you from making incompatible changes when editing the\nclass."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":10,"startColumn":16,"endLine":10,"endColumn":21,"description":"Cannot implement `Serializable` [1] with `Bar` because number [2] is incompatible with string [3] in the return value of property `serialize`. [incompatible-type]"}]',children:"interface Serializable {\n  serialize(): string;\n}\n\nclass Foo implements Serializable {\n  serialize(): string { return '[Foo]'; } // Works!\n}\n\nclass Bar implements Serializable {\n  serialize(): number { return 42; } // Error!\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["You can also use ",(0,t.jsx)(n.code,{children:"implements"})," with multiple interfaces."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"class Foo implements Bar, Baz {\n  // ...\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Interfaces can describe both instances and objects, unlike object types which can only describe objects:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":17,"startColumn":12,"endLine":17,"endColumn":14,"description":"Cannot call `acceptsObj` with `foo` bound to `x` because `Foo` [1] is not a subtype of object type [2]. Class instances are not subtypes of object types; consider rewriting object type [2] as an interface. [class-object-subtyping]"}]',children:"class Foo {\n  a: number;\n}\nconst foo = new Foo();\nconst o: {a: number} = {a: 1};\n\ninterface MyInterface {\n  a: number;\n}\n\nfunction acceptsMyInterface(x: MyInterface) { /* ... */ }\nacceptsMyInterface(o); // Works!\nacceptsMyInterface(foo); // Works!\n\nfunction acceptsObj(x: {a: number, ...}) { /* ... */ }\nacceptsObj(o); // Works!\nacceptsObj(foo); // Error!\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Unlike objects, interfaces cannot be ",(0,t.jsx)(n.a,{href:"../objects/#exact-and-inexact-object-types",children:"exact"}),", as they can always have other, unknown properties."]}),"\n",(0,t.jsx)(n.h2,{id:"toc-interface-syntax",children:"Interface Syntax"}),"\n",(0,t.jsxs)(n.p,{children:["Interfaces are created using the keyword ",(0,t.jsx)(n.code,{children:"interface"})," followed by its name and\na block which contains the body of the type definition."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"interface MyInterface {\n  // ...\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"The syntax of the block matches the syntax of object types."}),"\n",(0,t.jsx)(n.h3,{id:"toc-interface-methods",children:"Interface Methods"}),"\n",(0,t.jsxs)(n.p,{children:["You can add methods to interfaces following the same syntax as class methods. Any ",(0,t.jsxs)(n.a,{href:"../functions/#this-parameter",children:[(0,t.jsx)(n.code,{children:"this"})," parameters"]})," you\nprovide are also subject to the same restrictions as class methods."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"interface MyInterface {\n  method(value: string): number;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Also like ",(0,t.jsx)(n.a,{href:"../classes#toc-class-methods",children:"class methods"}),", interface methods must also remain bound to the interface on which they were defined."]}),"\n",(0,t.jsxs)(n.p,{children:["You can define ",(0,t.jsx)(n.a,{href:"../intersections/#declaring-overloaded-functions",children:"overloaded methods"})," by declaring the same method name multiple times with different type signatures:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":10,"startColumn":22,"endLine":10,"endColumn":35,"description":"Cannot assign `a.method(...)` to `z` because string [1] is incompatible with boolean [2]. [incompatible-type]"}]',children:"interface MyInterface {\n  method(value: string): string;\n  method(value: boolean): boolean;\n}\n\nfunction func(a: MyInterface) {\n  const x: string = a.method('hi'); // Works!\n  const y: boolean = a.method(true); // Works!\n\n  const z: boolean = a.method('hi'); // Error!\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"toc-interface-properties",children:"Interface Properties"}),"\n",(0,t.jsx)(n.p,{children:"You can add properties to interfaces following the same syntax as class\nproperties:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"interface MyInterface {\n  property: string;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Interface properties can be optional as well:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"interface MyInterface {\n  property?: string;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"toc-interfaces-as-maps",children:"Interfaces as maps"}),"\n",(0,t.jsxs)(n.p,{children:["You can create ",(0,t.jsx)(n.a,{href:"../objects#toc-objects-as-maps",children:"indexer properties"})," the same\nway as with objects:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"interface MyInterface {\n  [key: string]: number;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"toc-interface-generics",children:"Interface Generics"}),"\n",(0,t.jsxs)(n.p,{children:["Interfaces can also have their own ",(0,t.jsx)(n.a,{href:"../generics/",children:"generics"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"interface MyInterface<A, B, C> {\n  property: A;\n  method(val: B): C;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Interface generics are ",(0,t.jsx)(n.a,{href:"../generics#toc-parameterized-generics",children:"parameterized"}),".\nWhen you use an interface you need to pass parameters for each of its generics:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"interface MyInterface<A, B, C> {\n  foo: A;\n  bar: B;\n  baz: C;\n}\n\nconst val: MyInterface<number, boolean, string> = {\n  foo: 1,\n  bar: true,\n  baz: 'three',\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"toc-interface-property-variance-read-only-and-write-only",children:"Interface property variance (read-only and write-only)"}),"\n",(0,t.jsxs)(n.p,{children:["Interface properties are ",(0,t.jsx)(n.a,{href:"../../lang/variance/",children:"invariant"})," by default. But you\ncan add modifiers to make them covariant (read-only) or contravariant\n(write-only)."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"interface MyInterface {\n  +covariant: number;     // read-only\n  -contravariant: number; // write-only\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"toc-covariant-read-only-properties-on-interfaces",children:"Covariant (read-only) properties on interfaces"}),"\n",(0,t.jsxs)(n.p,{children:["You can make a property covariant by adding a plus symbol ",(0,t.jsx)(n.code,{children:"+"})," in front of the\nproperty name:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"interface MyInterface {\n  +readOnly: number | string;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"This allows you to pass a more specific type in place of that property:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":11,"startColumn":27,"endLine":11,"endColumn":27,"description":"Cannot assign `x` to `value1` because `number` [1] is not exactly the same as `number | string` [2] in property `property`. \\n\\nThe above-mentioned two types must be the same because property `property` is invariantly typed. To fix the error,\\n- Either make `{property: number}` [3] and `{property: number | string, ...}` [4] exactly the same\\n- Or make property `property` in `Invariant` [5] readonly. See https://flow.org/en/docs/faq/#why-cant-i-pass-a-string-to-a-function-that-takes-a-string-number. [incompatible-type]"}]',children:"interface Invariant {\n  property: number | string;\n}\ninterface Covariant {\n  +readOnly: number | string;\n}\n\nconst x: {property: number} = {property: 42};\nconst y: {readOnly: number} = {readOnly: 42};\n\nconst value1: Invariant = x; // Error!\nconst value2: Covariant = y; // Works\n"})}),"\n",(0,t.jsx)(n.p,{children:"Because of how covariance works, covariant properties also become read-only\nwhen used. Which can be useful over normal properties."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":15,"startColumn":9,"endLine":15,"endColumn":16,"description":"Cannot assign `3.14` to `value.readOnly` because property `readOnly` is not writable. [cannot-write]"}]',children:"interface Invariant {\n  property: number | string;\n}\ninterface Covariant {\n  +readOnly: number | string;\n}\n\nfunction func1(value: Invariant) {\n  value.property;        // Works!\n  value.property = 3.14; // Works!\n}\n\nfunction func2(value: Covariant) {\n  value.readOnly;        // Works!\n  value.readOnly = 3.14; // Error!\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"toc-contravariant-write-only-properties-on-interfaces",children:"Contravariant (write-only) properties on interfaces"}),"\n",(0,t.jsx)(n.p,{children:"You can make a property contravariant by adding a minus symbol - in front of\nthe property name."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"interface InterfaceName {\n  -writeOnly: number;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"This allows you to pass a less specific type in place of that property."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":10,"startColumn":42,"endLine":10,"endColumn":55,"description":"Cannot assign object literal to `value1` because string [1] is incompatible with number [2] in property `property`. [incompatible-type]"}]',children:"interface Invariant {\n  property: number;\n}\ninterface Contravariant {\n  -writeOnly: number;\n}\n\nconst numberOrString = Math.random() > 0.5 ? 42 : 'forty-two';\n\nconst value1: Invariant     = {property: numberOrString};  // Error!\nconst value2: Contravariant = {writeOnly: numberOrString}; // Works!\n"})}),"\n",(0,t.jsx)(n.p,{children:"Because of how contravariance works, contravariant properties also become\nwrite-only when used. Which can be useful over normal properties."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":14,"startColumn":9,"endLine":14,"endColumn":17,"description":"Cannot get `value.writeOnly` because property `writeOnly` is not readable. [cannot-read]"}]',children:"interface Invariant {\n  property: number;\n}\ninterface Contravariant {\n  -writeOnly: number;\n}\n\nfunction func1(value: Invariant) {\n  value.property;        // Works!\n  value.property = 3.14; // Works!\n}\n\nfunction func2(value: Contravariant) {\n  value.writeOnly;        // Error!\n  value.writeOnly = 3.14; // Works!\n}\n"})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);