"use strict";(globalThis.webpackChunknew_website=globalThis.webpackChunknew_website||[]).push([[2359],{52359(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"types/type-guards","title":"Type Guards","description":"Flow lets you define functions whose return expression encodes some type predicate over a parameter param. This predicate is annotated in place of a return type annotation as param is PredicateType. It declares that if the function returns true then param is of type PredicateType.","source":"@site/docs/types/type-guards.md","sourceDirName":"types","slug":"/types/type-guards","permalink":"/en/docs/types/type-guards","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/types/type-guards.md","tags":[],"version":"current","frontMatter":{"title":"Type Guards","slug":"/types/type-guards"},"sidebar":"docsSidebar","previous":{"title":"Mapped Types","permalink":"/en/docs/types/mapped-types"},"next":{"title":"Typeof Types","permalink":"/en/docs/types/typeof"}}');var s=t(74848),i=t(28453);const o={title:"Type Guards",slug:"/types/type-guards"},a=void 0,c={},d=[{value:"Basic Usage",id:"toc-basic-usage",level:2},{value:"Defining a type guard function",id:"defining-a-type-guard-function",level:3},{value:"Using a type guard function to refine values",id:"using-a-type-guard-function-to-refine-values",level:3},{value:"One-sided Type Guards",id:"one-sided-type-guards",level:3},{value:"<code>this</code> Type guards",id:"this-type-guards",level:3},{value:"Refine with <code>Array.filter</code>",id:"refine-with-arrayfilter",level:2},{value:"Defining Type Guard Functions",id:"toc-restrictions-of-type-guard-functions",level:2},{value:"Predicate parameter is a regular parameter to the function",id:"predicate-parameter-is-a-regular-parameter-to-the-function",level:3},{value:"Predicate type is consistent with the parameter type",id:"predicate-type-is-consistent-with-the-parameter-type",level:3},{value:"Type guard function returns boolean",id:"type-guard-function-returns-boolean",level:3},{value:"Predicate type is consistent with refined type",id:"toc-consistency-checks-of-type-guard-functions",level:3},{value:"Adoption",id:"toc-adoption",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Flow lets you define functions whose return expression encodes some type predicate over a parameter ",(0,s.jsx)(n.code,{children:"param"}),". This predicate is annotated in place of a return type annotation as ",(0,s.jsx)(n.code,{children:"param is PredicateType"}),". It declares that if the function returns ",(0,s.jsx)(n.code,{children:"true"})," then ",(0,s.jsx)(n.code,{children:"param"})," is of type ",(0,s.jsx)(n.code,{children:"PredicateType"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The syntax for a function like this is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function predicate(param: InputType): param is PredicateType {\n  return <some_expression>;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The type of this function can also be written in terms of a type guard annotation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"type PredicateFunc = (param: InputType) => param is PredicateType;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"toc-basic-usage",children:"Basic Usage"}),"\n",(0,s.jsx)(n.p,{children:"Let's see a simple example where we define a type guard function and then use it to refine some values."}),"\n",(0,s.jsx)(n.h3,{id:"defining-a-type-guard-function",children:"Defining a type guard function"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'type A = { type: "A"; data: string };\ntype B = { type: "B"; data: number };\ntype AorB = A | B;\n\nfunction isA(value: AorB): value is A {\n  return value.type === "A";\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["We have defined a data type ",(0,s.jsx)(n.code,{children:"AorB"})," that is a disjoint union of two types ",(0,s.jsx)(n.code,{children:"A"})," and ",(0,s.jsx)(n.code,{children:"B"})," that each have a property ",(0,s.jsx)(n.code,{children:"type"})," used as tag."]}),"\n",(0,s.jsxs)(n.p,{children:["We have also written a ",(0,s.jsx)(n.em,{children:"user defined type guard"})," function ",(0,s.jsx)(n.code,{children:"isA"})," defined over objects of type ",(0,s.jsx)(n.code,{children:"AorB"}),". This function returns ",(0,s.jsx)(n.code,{children:"true"})," when the value of of the ",(0,s.jsx)(n.code,{children:"type"})," property of its input is ",(0,s.jsx)(n.code,{children:'"A"'}),". Using the definitions of ",(0,s.jsx)(n.code,{children:"A"})," and ",(0,s.jsx)(n.code,{children:"B"}),", Flow can prove that when the value of ",(0,s.jsx)(n.code,{children:"type"})," is ",(0,s.jsx)(n.code,{children:'"A"'})," then the type of ",(0,s.jsx)(n.code,{children:"value"})," will be ",(0,s.jsx)(n.code,{children:"A"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"using-a-type-guard-function-to-refine-values",children:"Using a type guard function to refine values"}),"\n",(0,s.jsxs)(n.p,{children:["Functions that have a declared type guard can be used to refine values in conditionals. In the example above, we can use ",(0,s.jsx)(n.code,{children:"isA"})," to refine a variable of type ",(0,s.jsx)(n.code,{children:"AorB"})," to just ",(0,s.jsx)(n.code,{children:"A"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":18,"startColumn":22,"endLine":18,"endColumn":22,"description":"Cannot assign `x` to `error` because properties `data` and `type` of `A` [1] are not exactly the same as those of `B` [2]. [incompatible-type] \\nThe above-mentioned two types must be the same because properties `data` and `type` are invariantly typed. To fix the error,\\n- Either make `A` [3] and `B` [4] exactly the same\\n- Or make properties `data` and `type` in `B` [2] readonly. See https://flow.org/en/docs/faq/#why-cant-i-pass-a-string-to-a-function-that-takes-a-string-number."}]',children:'type A = { type: "A"; data: string };\ntype B = { type: "B"; data: number };\ntype AorB = A | B;\n\nfunction isA(value: AorB): value is A {\n  return value.type === "A";\n}\n\nfunction test(x: AorB) {\n  if (isA(x)) {\n    // `x` has now been refined to type A.\n    // We can assign it variables of type A ...\n    const y: A = x;\n    // ...and access A\'s properties through `x`\n    const stringData: string = x.data;\n\n    // As a sanity check, the following assignment to B will error\n    const error: B = x;\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In the then-branch of the conditional ",(0,s.jsx)(n.code,{children:"if (isA(x))"}),", ",(0,s.jsx)(n.code,{children:"x"})," will have the type ",(0,s.jsx)(n.code,{children:"A"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"one-sided-type-guards",children:"One-sided Type Guards"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," This feature is available as of v0.237.0 when option ",(0,s.jsx)(n.code,{children:"one_sided_type_guards=true"})," is set in the flowconfig. It is enabled by default as of v0.239.0."]}),"\n",(0,s.jsx)(n.p,{children:"In some cases we may want to declare that a type guard function only refines the then-branch of a conditional. Consider for example the function"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function isPositive(n: ?number): boolean {\n  return n != null && n > 0;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If we declared ",(0,s.jsx)(n.code,{children:"n is number"})," as the type guard of this function then in the following code:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"declare var n: ?number;\nif (isPositive(n)) {\n  // n is number here\n} else {\n  // n would be null | void here\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["we would be able to establish that ",(0,s.jsx)(n.code,{children:"n"})," is ",(0,s.jsx)(n.code,{children:"null | void"})," in the else-branch. This is not true, however, since ",(0,s.jsx)(n.code,{children:"n"})," could just be a non-negative number."]}),"\n",(0,s.jsxs)(n.p,{children:["One-sided type guards, which we annotate as ",(0,s.jsx)(n.code,{children:"implies param is PredicateType"}),", let us specify that a predicate narrows the type in only the positive case. For example,"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function isPositive(n: ?number): implies n is number {\n  return n != null && n > 0;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now, we'll get the following behavior"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"declare var n: ?number;\nif (isPositive(n)) {\n  // n is number here\n} else {\n  // n is still ?number\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"this-type-guards",children:[(0,s.jsx)(n.code,{children:"this"})," Type guards"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," This feature is available as of v0.261.0 when option ",(0,s.jsx)(n.code,{children:"this_type_guards=true"})," is set in the flowconfig.\nIt is enabled by default as of v0.269.0."]}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes, it is useful to declare a type predicate over the class instance on which a method is called.\nThis can be done by adding ",(0,s.jsx)(n.code,{children:"this is Type"})," as return annotation for this method.\nCalling this method in a conditional context will refine the instance to the type ",(0,s.jsx)(n.code,{children:"Type"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"For example, consider the following class declarations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"declare class Shape {\n  isCircle(): this is Circle;\n  isSquare(): this is Square;\n}\n\ndeclare class Circle {\n  radius: number;\n}\n\ndeclare class Square {\n  side: number;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"this"})," type guard annotations allow us to refine a ",(0,s.jsx)(n.code,{children:"Shape"}),"-typed value to either ",(0,s.jsx)(n.code,{children:"Circle"})," or ",(0,s.jsx)(n.code,{children:"Square"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function area(shape: Shape): number {\n  if (shape.isCircle()) {\n    // shape is now a Circle\n    return Math.PI * shape.radius ** 2;\n  } else if (shape.isSquare()) {\n    // shape is now a Square\n    return shape.side ** 2;\n  } else {\n    throw new Error('unknown shape');\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," The ",(0,s.jsx)(n.code,{children:"this"})," type guard annotation is only allowed in the return annotation on non-static declare class and interface methods. For example the following are invalid forms:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"declare class InvalidStatic {\n  static m(): this is D;\n}\n\ntype InvalidTypeAlias = (x: unknown): this is A;\n\nfunction invalidFunction(this: unknown): this is A;\n\nclass InvalidNonDeclareClass {\n  m(): this is B { return this instanceof B; }\n}\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"refine-with-arrayfilter",children:["Refine with ",(0,s.jsx)(n.code,{children:"Array.filter"})]}),"\n",(0,s.jsxs)(n.p,{children:["Flow recognizes when you call ",(0,s.jsx)(n.code,{children:"filter"})," on an array of type ",(0,s.jsx)(n.code,{children:"Array<T>"})," with a callback function that holds a type guard with type ",(0,s.jsx)(n.code,{children:"(value: T) => value is S"}),".\nIt will use this to produce an output array of type ",(0,s.jsx)(n.code,{children:"Array<S>"}),". Note that ",(0,s.jsx)(n.code,{children:"S"})," needs to be a subtype of the type of the array element ",(0,s.jsx)(n.code,{children:"T"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"For example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":19,"startColumn":10,"endLine":19,"endColumn":15,"description":"Cannot return `result` because in array element: `Success` [1] is not exactly the same as `Error` [2]. [incompatible-type] \\nThe above-mentioned two types must be the same because arrays are invariantly typed. To fix the error,\\n- Either make `Array<Success>` [3] and `Array<Error>` [4] exactly the same\\n- Or make array type [4] a `ReadonlyArray`.\\nSee https://flow.org/en/docs/faq/#why-cant-i-pass-an-arraystring-to-a-function-that-takes-an-arraystring-number."},{"startLine":25,"startColumn":38,"endLine":25,"endColumn":64,"description":"Cannot return `response.type === \'success\'` because property `error` is missing in object type [1] but exists in object type [2]. [incompatible-type] \\nThe type of `response` [3] at the return expression `response.type === \'success\'` [4] needs to be compatible with the guard type `Error` [2]. See 1. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions."},{"startLine":25,"startColumn":38,"endLine":25,"endColumn":64,"description":"Cannot return `response.type === \'success\'` because property `value` is extra in object type [1] but missing in object type [2]. Exact objects do not accept extra props. [incompatible-type] \\nThe type of `response` [3] at the return expression `response.type === \'success\'` [4] needs to be compatible with the guard type `Error` [2]. See 1. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions."},{"startLine":25,"startColumn":38,"endLine":25,"endColumn":64,"description":"Cannot return `response.type === \'success\'` because in property `type`: string literal `success` [1] is incompatible with string literal `error` [2]. [incompatible-type-guard] \\nThe type of `response` [3] at the return expression `response.type === \'success\'` [4] needs to be compatible with the guard type `Error` [5]. See 1. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions."},{"startLine":25,"startColumn":38,"endLine":25,"endColumn":64,"description":"Cannot return `response.type === \'success\'` because the negation of the predicate encoded in this expression needs to completely refine away the guard type `Error` [1]. Consider using a one-sided type-guard (`implies x is T`). See 2. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]"}]',children:"type Success = Readonly<{type: 'success', value: 23}>;\ntype Error = Readonly<{type: 'error', error: string}>;\n\ntype Response =\n  | Success\n  | Error\n\nfunction filterSuccess(response: Array<Response>): Array<Success> {\n  return response.filter(\n    (response): response is Success => response.type === 'success'\n  );\n}\n\nfunction filterError1(response: Array<Response>): Array<Error> {\n  const result = response.filter(\n    (response): response is Success => response.type === 'success'\n  );\n  // The following is expected to error\n  return result;\n}\n\nfunction filterError2(response: Array<Response>): Array<Error> {\n  const result = response.filter(\n    // The following is expected to error\n    (response): response is Error => response.type === 'success'\n  );\n  return result;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In ",(0,s.jsx)(n.code,{children:"filterError1"}),", filtering produces ",(0,s.jsx)(n.code,{children:"Array<Success>"})," that is not compatible with the expected return type ",(0,s.jsx)(n.code,{children:"Array<Error>"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["In ",(0,s.jsx)(n.code,{children:"filterError2"}),", the predicate ",(0,s.jsx)(n.code,{children:"response.type === 'success'"})," is used to refine ",(0,s.jsx)(n.code,{children:"Response"}),"s to ",(0,s.jsx)(n.code,{children:"Success"}),"s, not ",(0,s.jsx)(n.code,{children:"Error"}),"s."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that as of version 0.261 it is not necessary to provide a type guard annotation for the argument of ",(0,s.jsx)(n.code,{children:".filter()"}),".\nThis will be inferred from the body of the arrow function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function filterSuccessShort(response: Array<Response>): Array<Success> {\n  return response.filter(\n    response => response.type === 'success'\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"toc-restrictions-of-type-guard-functions",children:"Defining Type Guard Functions"}),"\n",(0,s.jsx)(n.p,{children:"To ensure that refinement with type guard functions is sound, Flow runs a number of checks associated with these functions."}),"\n",(0,s.jsx)(n.h3,{id:"predicate-parameter-is-a-regular-parameter-to-the-function",children:"Predicate parameter is a regular parameter to the function"}),"\n",(0,s.jsxs)(n.p,{children:["In a type guard annotation of the form ",(0,s.jsx)(n.code,{children:"parameter is Type"}),", ",(0,s.jsx)(n.code,{children:"parameter"})," needs to belong to the current function's parameter list."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":1,"startColumn":35,"endLine":1,"endColumn":38,"description":"Cannot find type guard parameter `prop` [1] in the parameters of this function (type). [function-predicate]"}]',children:'function missing(param: unknown): prop is number {\n  return typeof param === "number";\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"It cannot be a parameter bound in a destructuring pattern, or a rest parameter:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":1,"startColumn":50,"endLine":1,"endColumn":53,"description":"A type guard parameter `prop` [1] cannot reference pattern parameter `prop` [2]. [function-predicate]"}]',children:'function destructuring({prop}: {prop: unknown}): prop is number {\n  return typeof prop === "number";\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":1,"startColumn":42,"endLine":1,"endColumn":46,"description":"A type guard parameter `value` [1] cannot reference rest parameter `value` [2]. [function-predicate]"}]',children:"function rest(...value: Array<unknown>): value is Array<unknown> {\n  return Array.isArray(value);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"predicate-type-is-consistent-with-the-parameter-type",children:"Predicate type is consistent with the parameter type"}),"\n",(0,s.jsxs)(n.p,{children:["The type guard ",(0,s.jsx)(n.code,{children:"Type"})," needs to be compatible with the type of the parameter. In other words, given a definition"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function isT(x: ParamType): x is Type {\n  return ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Flow will check that ",(0,s.jsx)(n.code,{children:"Type"})," is a subtype of ",(0,s.jsx)(n.code,{children:"ParamType"}),". So the following will be an error:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":1,"startColumn":36,"endLine":1,"endColumn":41,"description":"The type predicate number [1] needs to be compatible with parameter `x`\'s type: number [1] is incompatible with string [2]. [incompatible-type-guard]"}]',children:'function isNumber(x: string): x is number {\n  return typeof x === "number";\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"type-guard-function-returns-boolean",children:"Type guard function returns boolean"}),"\n",(0,s.jsx)(n.p,{children:"A type guard function needs to return a boolean expression. The following are invalid declarations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":1,"startColumn":39,"endLine":1,"endColumn":49,"description":"Cannot declare a type guard [1] for function [2] because boolean [1] is incompatible with implicitly-returned undefined. [incompatible-type]"}]',children:"function isNumberNoReturn(x: string): x is string {}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":2,"startColumn":10,"endLine":2,"endColumn":10,"description":"Cannot return `x` because null or undefined [1] is incompatible with boolean [2]. [incompatible-type]"},{"startLine":2,"startColumn":10,"endLine":2,"endColumn":10,"description":"Cannot return `x` because object type [1] is incompatible with boolean [2]. [incompatible-type]"}]',children:"function nonMaybe<V: {...}>(x: ?V): x is V {\n  return x;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A correct version of ",(0,s.jsx)(n.code,{children:"nonMaybe"})," would be"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function nonMaybe<V: {...}>(x: ?V): x is V {\n  return !!x;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"toc-consistency-checks-of-type-guard-functions",children:"Predicate type is consistent with refined type"}),"\n",(0,s.jsx)(n.p,{children:"In addition to the above checks, Flow also ensures that the declared type guard is consistent with the check happening in the body of the function. To establish this it needs to guarantee two things:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["The type of the refined parameter at the return location ",(0,s.jsx)(n.em,{children:"after"})," the predicate of the return expression has been applied is a subtype of the guard type. For example, the following definitions are correct:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'function numOrStr(x: unknown): x is number | string {\n  return (typeof x === "number" || typeof x === "string");\n}\n\nfunction numOrStrWithException(x: unknown): x is number | string {\n  if (typeof x === "number") {\n    return true;\n  } else {\n    if (typeof x === "string") {\n        return true;\n    } else {\n        throw new Error("");\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"But in the following Flow will raise errors:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":2,"startColumn":36,"endLine":2,"endColumn":57,"description":"Cannot return `((typeof x) === \\"number\\") || ((typeof x) === \\"boolean\\")` because: [incompatible-type-guard] Either boolean [1] is incompatible with number [2]. Or boolean [1] is incompatible with string [3]. \\nThe type of `x` [4] at the return expression `((typeof x) === \\"number\\") || ((typeof x) === \\"boolean\\")` [5] needs to be compatible with the guard type union type [6]. See 1. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions."},{"startLine":2,"startColumn":11,"endLine":2,"endColumn":57,"description":"Cannot return `((typeof x) === \\"number\\") || ((typeof x) === \\"boolean\\")` because the negation of the predicate encoded in this expression needs to completely refine away the guard type union type [1]. Consider using a one-sided type-guard (`implies x is T`). See 2. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]"}]',children:'function numOrStrError(x: unknown): x is number | string {\n  return (typeof x === "number" || typeof x === "boolean");\n}\n'})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"Type guard functions can be used to refine the else-branch of conditionals. For example,"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'function isNumber(x: unknown): x is number {\n  return typeof x === "number";\n}\n\ndeclare var value: number | string;\nif (isNumber(value)) {\n  value as number; // okay\n} else {\n  value as string; // also okay\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Therefore, the inverse form of the first requirement also needs to hold. Specifically, if we negate the predicate encoded in the function, and use it to refine the input, then the result must not overlap with the type guard at all. This condition is equivalent to checking that the type guard refined with the negation of the function predicate is a subtype of ",(0,s.jsx)(n.code,{children:"empty"}),". For example the following raises an error:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":2,"startColumn":12,"endLine":2,"endColumn":41,"description":"Cannot return `((typeof x) === \'number\') && (x > 0)` because the negation of the predicate encoded in this expression needs to completely refine away the guard type number [1]. Consider using a one-sided type-guard (`implies x is T`). See 2. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]"}]',children:"function isPosNum(x: unknown): x is number {\n    return typeof x === 'number' && x > 0;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This is because the negation of the predicate of ",(0,s.jsx)(n.code,{children:"isPosNum"}),' is "',(0,s.jsx)(n.code,{children:"x"})," is not a number or ",(0,s.jsx)(n.code,{children:"x<=0"}),'". This predicate is equivalent to the empty predicate and does not refine the input type it is applied to.']}),"\n",(0,s.jsxs)(n.p,{children:["If you're seeing errors related to this check, consider using a one-sided type guard (write ",(0,s.jsx)(n.code,{children:"implies x is T"}),"). Ones-sided type guards do not require this check, since they do not refine the else-branch of conditionals."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," This check only happens when ",(0,s.jsx)(n.code,{children:"one_sided_type_guards=true"})," is set in the flowconfig. It happens by default as of v0.239.0."]}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"The parameter that is refined cannot be reassigned in the body of the type guard function. Therefore the following are errors:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":10,"endLine":3,"endColumn":30,"description":"Cannot use type guard parameter `x` [1] because at this return point it is written to in [2]. [function-predicate]"}]',children:'function isNumberError1(x: unknown): x is number {\n  x = 1;\n  return typeof x === "number";\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":1,"startColumn":38,"endLine":1,"endColumn":38,"description":"Cannot use type guard parameter `x`, because `x` [1] is reassigned in [2]. [function-predicate]"}]',children:'function isNumberError2(x: unknown): x is number {\n  function foo() {\n    x = 1;\n  }\n  foo();\n  return typeof x === "number";\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"toc-adoption",children:"Adoption"}),"\n",(0,s.jsx)(n.p,{children:"To use type guards, you need to upgrade your infrastructure so that it supports the syntax:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"flow"})," and ",(0,s.jsx)(n.code,{children:"flow-parser"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["0.209.1. Between v0.209.1 to v0.211.1, you need to explicitly enable it in your .flowconfig, under the ",(0,s.jsx)(n.code,{children:"[options]"})," heading, add ",(0,s.jsx)(n.code,{children:"type_guards=true"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["One-sided type guards are available as of version 0.237.0 with the option ",(0,s.jsx)(n.code,{children:"one_sided_type_guards=true"}),", and are enabled by default as of v0.239.0."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"this"})," type guards are available as of version 0.261.0 with the option ",(0,s.jsx)(n.code,{children:"this_type_guards=true"}),", and are enabled by default as of v0.269.0."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"prettier"}),": 3. ",(0,s.jsx)(n.code,{children:"this"})," type guards require version 3.5 or later. See ",(0,s.jsx)(n.a,{href:"../../tools/prettier/",children:"these instructions"})," for installing prettier."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"babel"})," with ",(0,s.jsx)(n.code,{children:"babel-plugin-syntax-hermes-parser"}),". See ",(0,s.jsx)(n.a,{href:"../../tools/babel/",children:"our Babel guide"})," for setup instructions.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"this"})," type guards require hermes-parser version 0.26 or later."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"eslint"})," with ",(0,s.jsx)(n.code,{children:"hermes-eslint"}),". See ",(0,s.jsx)(n.a,{href:"../../tools/eslint/",children:"our ESLint guide"})," for setup instructions."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453(e,n,t){t.d(n,{R:()=>o,x:()=>a});var r=t(96540);const s={},i=r.createContext(s);function o(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);