"use strict";(globalThis.webpackChunknew_website=globalThis.webpackChunknew_website||[]).push([[7523],{97523(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"types/utilities","title":"Utility Types","description":"Flow provides a set of utility types to operate on other types to create new types.","source":"@site/docs/types/utilities.md","sourceDirName":"types","slug":"/types/utilities","permalink":"/en/docs/types/utilities","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/types/utilities.md","tags":[],"version":"current","frontMatter":{"title":"Utility Types","slug":"/types/utilities"},"sidebar":"docsSidebar","previous":{"title":"Const Expressions","permalink":"/en/docs/types/const-expression"},"next":{"title":"Module Types","permalink":"/en/docs/types/modules"}}');var r=t(74848),o=t(28453),a=t(86543);const i={title:"Utility Types",slug:"/types/utilities"},l=void 0,c={},d=[{value:"<code>keyof T</code> <SinceVersion></SinceVersion> (alias <code>$Keys&lt;T&gt;</code>)",id:"toc-keys",level:2},{value:"<code>Values&lt;T&gt;</code> <SinceVersion></SinceVersion> (alias <code>$Values&lt;T&gt;</code>)",id:"toc-values",level:2},{value:"<code>Readonly&lt;T&gt;</code> <SinceVersion></SinceVersion> (alias <code>$ReadOnly&lt;T&gt;</code>)",id:"toc-readonly",level:2},{value:"<code>Partial&lt;T&gt;</code>  <SinceVersion></SinceVersion>",id:"toc-partial",level:2},{value:"<code>Required&lt;T&gt;</code> <SinceVersion></SinceVersion>",id:"toc-required",level:2},{value:"<code>ReturnType&lt;F&gt;</code> <SinceVersion></SinceVersion>",id:"toc-return-type",level:2},{value:"<code>Parameters&lt;F&gt;</code> <SinceVersion></SinceVersion>",id:"toc-parameters",level:2},{value:"<code>Exclude&lt;T, U&gt;</code> <SinceVersion></SinceVersion>",id:"toc-exclude",level:2},{value:"<code>Extract&lt;T, U&gt;</code> <SinceVersion></SinceVersion>",id:"toc-extract",level:2},{value:"<code>ThisParameterType&lt;F&gt;</code> <SinceVersion></SinceVersion>",id:"toc-this-parameter-type",level:2},{value:"<code>OmitThisParameter&lt;F&gt;</code> <SinceVersion></SinceVersion>",id:"toc-omit-this-parameter-type",level:2},{value:"<code>Pick&lt;O, Keys&gt;</code> <SinceVersion></SinceVersion>",id:"toc-pick",level:2},{value:"<code>Omit&lt;O, Keys&gt;</code> <SinceVersion></SinceVersion>",id:"toc-omit",level:2},{value:"<code>Record&lt;Keys, Type&gt;</code> <SinceVersion></SinceVersion>",id:"toc-record",level:2},{value:"<code>$Exact&lt;T&gt;</code>",id:"toc-exact",level:2},{value:"<code>NonNullable&lt;T&gt;</code> <SinceVersion></SinceVersion> (alias <code>$NonMaybeType&lt;T&gt;</code>)",id:"toc-nonmaybe",level:2},{value:"<code>$KeyMirror&lt;O&gt;</code>",id:"toc-keymirror",level:2},{value:"<code>Class&lt;T&gt;</code>",id:"toc-class",level:2},{value:"<code>$Exports&lt;T&gt;</code>",id:"toc-exports",level:2},{value:"<code>StringPrefix</code> and <code>StringSuffix</code> <SinceVersion></SinceVersion>",id:"stringprefix-and-stringsuffix-",level:2},{value:"Removed utility types",id:"removed-utility-types",level:2},{value:"<code>$Diff&lt;A, B&gt;</code> <UntilVersion></UntilVersion>",id:"toc-diff",level:3},{value:"<code>$Rest&lt;A, B&gt;</code> <UntilVersion></UntilVersion>",id:"toc-rest",level:3},{value:"<code>$PropertyType&lt;T, k&gt;</code> <UntilVersion></UntilVersion>",id:"toc-propertytype",level:3},{value:"<code>$ElementType&lt;T, K&gt;</code> <UntilVersion></UntilVersion>",id:"toc-elementtype",level:3},{value:"<code>$TupleMap&lt;T, F&gt;</code> <UntilVersion></UntilVersion>",id:"toc-tuplemap",level:3},{value:"<code>$Call&lt;F, T...&gt;</code> <UntilVersion></UntilVersion>",id:"toc-call",level:3},{value:"<code>$ObjMap&lt;T, F&gt;</code> <UntilVersion></UntilVersion>",id:"toc-objmap",level:3},{value:"<code>$ObjMapi&lt;T, F&gt;</code> <UntilVersion></UntilVersion>",id:"toc-objmapi",level:3},{value:"<code>$ObjMapConst&lt;O, T&gt;</code> <UntilVersion></UntilVersion>",id:"toc-objmapconst",level:3},{value:"<code>$Partial</code> <UntilVersion></UntilVersion>",id:"partial-",level:3},{value:"<code>$Shape&lt;T&gt;</code> <UntilVersion></UntilVersion>",id:"toc-shape",level:3}];function p(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Flow provides a set of utility types to operate on other types to create new types."}),"\n",(0,r.jsxs)(n.h2,{id:"toc-keys",children:[(0,r.jsx)(n.code,{children:"keyof T"})," ",(0,r.jsx)(a.V,{version:"0.290"})," (alias ",(0,r.jsx)(n.code,{children:"$Keys<T>"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:["You can extract the type of the keys from an ",(0,r.jsx)(n.a,{href:"../objects",children:"object type"}),". Typically this will be a ",(0,r.jsx)(n.a,{href:"../unions",children:"union"})," of ",(0,r.jsx)(n.a,{href:"../literals",children:"string literal"})," types:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":10,"startColumn":23,"endLine":10,"endColumn":28,"description":"Cannot assign `\'nope\'` to `nope` because property `nope` is missing in object literal [1]. [prop-missing]"}]',children:'const countries = {\n  US: "United States",\n  IT: "Italy",\n  FR: "France"\n};\n\ntype Country = keyof typeof countries;\n\nconst italy: Country = \'IT\'; // Works\nconst nope: Country = \'nope\'; // Error!\n'})}),"\n",(0,r.jsxs)(n.p,{children:["In the example above, the type of ",(0,r.jsx)(n.code,{children:"Country"})," is equivalent to ",(0,r.jsx)(n.code,{children:"type Country = 'US' | 'IT' | 'FR'"}),", but Flow was able to extract it from the keys of ",(0,r.jsx)(n.code,{children:"countries"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If you want to create an enum type, ",(0,r.jsx)(n.a,{href:"../../enums",children:"Flow Enums"})," might be a better fit for your use-case."]}),"\n",(0,r.jsxs)(n.h2,{id:"toc-values",children:[(0,r.jsx)(n.code,{children:"Values<T>"})," ",(0,r.jsx)(a.V,{version:"0.290"})," (alias ",(0,r.jsx)(n.code,{children:"$Values<T>"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Values<T>"})," represents the union type of all the value types of the enumerable properties in an ",(0,r.jsx)(n.a,{href:"../objects/",children:"object type"}),",\nor the elements of an ",(0,r.jsx)(n.a,{href:"../arrays",children:"array"})," or ",(0,r.jsx)(n.a,{href:"../tuples",children:"tuple"})," type (support for arrays and tuples in Flow version ",(0,r.jsx)(a.V,{version:"0.240"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":12,"startColumn":25,"endLine":12,"endColumn":28,"description":"Cannot assign `true` to `fn` because: [incompatible-type] Either boolean [1] is incompatible with string [2]. Or boolean [1] is incompatible with number [3]."}]',children:"type Props = {\n  name: string,\n  age: number,\n};\n\n// The following two types are equivalent:\ntype PropValues = string | number;\ntype Prop$Values = Values<Props>;\n\nconst name: Prop$Values = 'Jon';  // Works\nconst age: Prop$Values = 42;  // Works\nconst fn: Prop$Values = true; // Error!\n"})}),"\n",(0,r.jsx)(n.p,{children:"For arrays and tuples:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type Arr = Array<string>;\ntype Str = Values<Arr>; //=> string\n's' as Str; // OK\n\ntype Tup = [1, 2];\ntype Num = Values<Tup>; //=> 1 | 2\n1 as Num; // OK\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Note that using ",(0,r.jsx)(n.code,{children:"Values"})," on the ",(0,r.jsx)(n.a,{href:"../typeof",children:(0,r.jsx)(n.code,{children:"typeof"})})," an object or array literal will result in a type more general than you might expect:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"const obj = {\n  foo: 1,\n  bar: 2,\n};\n\nfunction acceptsValues(x: Values<typeof obj>) { /* ... */ }\n\nacceptsValues(1); // Works\nacceptsValues(3); // Works, because the type was interpreted as `number`.\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This behavior changes if you use ",(0,r.jsx)(n.code,{children:"Object.freeze"})," on the object literal expression:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":9,"startColumn":15,"endLine":9,"endColumn":15,"description":"Cannot call `acceptsValues` with `3` bound to `x` because number [1] is incompatible with `Values` [2]. [incompatible-type]"}]',children:"const obj = Object.freeze({\n  foo: 1,\n  bar: 2,\n});\n\nfunction acceptsValues(x: Values<typeof obj>) { /* ... */ }\n\nacceptsValues(1); // Works\nacceptsValues(3); // Error! Because the type was interpreted as `1 | 2`.\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If you want to create an enum type, ",(0,r.jsx)(n.a,{href:"../../enums",children:"Flow Enums"})," might be a better fit for your use-case."]}),"\n",(0,r.jsxs)(n.h2,{id:"toc-readonly",children:[(0,r.jsx)(n.code,{children:"Readonly<T>"})," ",(0,r.jsx)(a.V,{version:"0.290"})," (alias ",(0,r.jsx)(n.code,{children:"$ReadOnly<T>"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Readonly<T>"})," is a type that represents the read-only version of a given ",(0,r.jsx)(n.a,{href:"../objects/",children:"object type"}),"\nor ",(0,r.jsx)(n.a,{href:"../tuples",children:"tuple type"})," ",(0,r.jsx)(n.code,{children:"T"})," (support for tuples is for Flow ",(0,r.jsx)(a.V,{version:"0.212"}),").\nA read-only object type is an object type whose keys are all ",(0,r.jsx)(n.a,{href:"../objects/#read-only-object-properties",children:"read-only"}),".\nSimilarly, a read-only tuple is one where each element is ",(0,r.jsx)(n.a,{href:"../tuples/#variance-annotations-and-read-only-tuples",children:"read-only"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"This means that the following are equivalent:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type ReadOnlyObj = {\n  +key: number,  // read-only field, marked by the `+` annotation\n};\ntype ReadOnlyTuple = [+foo: number];\n"})}),"\n",(0,r.jsx)(n.p,{children:"\u2192"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type ReadOnlyObj = Readonly<{\n  key: number,\n}>;\ntype ReadOnlyTuple = Readonly<[number]>;\n"})}),"\n",(0,r.jsx)(n.p,{children:"This is useful when you need to use a read-only version of an object type you've already defined, without manually having to re-define and annotate each key as read-only. For example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":10,"startColumn":9,"endLine":10,"endColumn":11,"description":"Cannot assign `42` to `props.age` because property `age` is not writable. [cannot-write]"}]',children:"type Props = {\n  name: string,\n  age: number,\n};\n\ntype ReadOnlyProps = Readonly<Props>;\n\nfunction render(props: ReadOnlyProps) {\n  const {name, age} = props;  // Works\n  props.age = 42;             // Error!\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Additionally, other utility types, such as ",(0,r.jsx)(n.a,{href:"../objects/#object-type-spread",children:"spread"}),", may strip any read/write annotations, so ",(0,r.jsx)(n.code,{children:"Readonly<T>"})," is a handy way to quickly make the object read-only again after operating on it:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type Obj = {\n  +key: number,\n};\n\ntype MappedObj = Readonly<{...Obj, foo: string}> // Still read-only\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"Readonly"})," utility works on object and tuple types.\nIf you want to make other types read-only, you can use one of the following:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Array<T>"})," -> ",(0,r.jsx)(n.a,{href:"../arrays/#toc-readonlyarray",children:(0,r.jsx)(n.code,{children:"ReadonlyArray<T>"})})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Set<T>"})," -> ",(0,r.jsx)(n.code,{children:"ReadonlySet<T>"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Map<K, V>"})," -> ",(0,r.jsx)(n.code,{children:"ReadonlyMap<K, V>"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"WeakSet<T>"})," -> ",(0,r.jsx)(n.code,{children:"ReadonlyWeakSet<T>"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"WeakMap<K, V>"})," -> ",(0,r.jsx)(n.code,{children:"ReadonlyWeakMap<K, V>"})]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"toc-partial",children:[(0,r.jsx)(n.code,{children:"Partial<T>"}),"  ",(0,r.jsx)(a.V,{version:"0.201"})]}),"\n",(0,r.jsxs)(n.p,{children:["This utility converts all of an object or interface's named fields to be optional,\nwhile maintaining all the object's other properties (e.g. exactness, variance).\nUse this utility instead of ",(0,r.jsx)(n.code,{children:"$Shape"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Since Flow ",(0,r.jsx)(a.V,{version:"0.212"}),", it also converts all of a tuple type's elements to be ",(0,r.jsx)(n.a,{href:"../tuples/#optional-tuple-elements",children:"optional"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Example for objects:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":12,"startColumn":1,"endLine":12,"endColumn":1,"description":"Cannot cast `c` to `Person` because properties `age` and `name` of `{age?: number, name?: string}` [1] are not exactly the same as those of `Person` [2]. [incompatible-type] \\nThe above-mentioned two types must be the same because properties `age` and `name` are invariantly typed. To fix the error,\\n- Either make `{age?: number, name?: string}` [3] and `Person` [3] exactly the same\\n- Or make properties `age` and `name` in `Person` [2] readonly. See https://flow.org/en/docs/faq/#why-cant-i-pass-a-string-to-a-function-that-takes-a-string-number."}]',children:"type Person = {\n  name: string,\n  age: number,\n};\ntype PartialPerson = Partial<Person>;\n// Above equivalent to `{name?: string, age?: number}`\n\nconst a: PartialPerson = {}; // OK\nconst b: PartialPerson = {name: 'George'}; // OK\nconst c: PartialPerson = {name: 'George', age: 123}; // OK\n\nc as Person; // ERROR: `PersonDetails` is not a `Person` (unlike with `$Shape`)\n"})}),"\n",(0,r.jsx)(n.p,{children:"For tuples:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type AllRequired = [number, string];\n[] as Partial<AllRequired>; // OK: like `[a?: number, b?: string]` now\n"})}),"\n",(0,r.jsxs)(n.p,{children:["A object or tuple of type ",(0,r.jsx)(n.code,{children:"T"})," cannot be supplied to ",(0,r.jsx)(n.code,{children:"Partial<T>"}),", due to mutability. You can resolve this by making the object ",(0,r.jsx)(n.a,{href:"#toc-readonly",children:"read-only"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":12,"startColumn":10,"endLine":12,"endColumn":15,"description":"Cannot call `noPerson` with `person` bound to `o` because properties `age` and `name` of `Person` [1] are not exactly the same as those of `{age?: number, name?: string}` [2]. [incompatible-type] \\nThe above-mentioned two types must be the same because properties `age` and `name` are invariantly typed. To fix the error,\\n- Either make `Person` [3] and `{age?: number, name?: string}` [3] exactly the same\\n- Or make properties `age` and `name` in `Person` [2] readonly. See https://flow.org/en/docs/faq/#why-cant-i-pass-a-string-to-a-function-that-takes-a-string-number."}]',children:"type Person = {\n  name: string,\n  age: number,\n};\n\nconst person: Person = {name: 'George', age: 123};\n\nfunction noPerson(o: Partial<Person>) {\n  // Can mutate:\n  o.name = undefined;\n}\nnoPerson(person); // Error!\n\nfunction okPerson(o: Readonly<Partial<Person>>) {\n  // Can't mutate - it's read-only!\n}\nokPerson(person); // Works\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Note: Up until Flow version 0.201, this utility type was named ",(0,r.jsx)(n.code,{children:"$Partial"}),"."]}),"\n",(0,r.jsxs)(n.h2,{id:"toc-required",children:[(0,r.jsx)(n.code,{children:"Required<T>"})," ",(0,r.jsx)(a.V,{version:"0.201"})]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"Required"})," utility type is the opposite of ",(0,r.jsx)(n.a,{href:"#toc-partial",children:(0,r.jsx)(n.code,{children:"Partial"})}),":\nit converts all of an object or interface\u2019s optional fields to be required."]}),"\n",(0,r.jsxs)(n.p,{children:["Since Flow ",(0,r.jsx)(a.V,{version:"0.212"}),", it also converts all of a tuple type's elements to be ",(0,r.jsx)(n.a,{href:"../tuples/#optional-tuple-elements",children:"required"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Example for objects:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":9,"startColumn":19,"endLine":9,"endColumn":28,"description":"Cannot assign object literal to `b` because property `name` is missing in object literal [1] but exists in `PartialPerson` [2]. [incompatible-type]"}]',children:"type PartialPerson = {\n  name?: string,\n  age?: number,\n};\ntype Person = Required<PartialPerson>;\n// Above equivalent to `{name: string, age: number}`\n\nconst a: Person = {name: 'George', age: 123}; // OK\nconst b: Person = {age: 123}; // ERROR: missing `name` property\n"})}),"\n",(0,r.jsx)(n.p,{children:"For tuples:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":2,"startColumn":1,"endLine":2,"endColumn":2,"description":"Cannot cast array literal to required of `AllOptional` because empty array literal [1] has 0 elements but `AllOptional` [2] has 2 elements. [invalid-tuple-arity]"}]',children:"type AllOptional = [a?: number, b?: string];\n[] as Required<AllOptional>; // ERROR: like `[a: number, b: string]` now\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"toc-return-type",children:[(0,r.jsx)(n.code,{children:"ReturnType<F>"})," ",(0,r.jsx)(a.V,{version:"0.209"})]}),"\n",(0,r.jsx)(n.p,{children:"This utility type extracts the return type from a given function type."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":4,"startColumn":1,"endLine":4,"endColumn":1,"description":"Cannot cast `1` to `Bool` because number [1] is incompatible with boolean [2]. [incompatible-type]"}]',children:"declare function f(s: string, n: number): boolean;\ntype Bool = ReturnType<typeof f>;\ntrue as Bool;\n1 as Bool; // Error: number is not boolean\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"toc-parameters",children:[(0,r.jsx)(n.code,{children:"Parameters<F>"})," ",(0,r.jsx)(a.V,{version:"0.209"})]}),"\n",(0,r.jsxs)(n.p,{children:["This utility type extracts the parameter types from a given function type into a ",(0,r.jsx)(n.a,{href:"../tuples/",children:"tuple type"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":5,"startColumn":16,"endLine":5,"endColumn":16,"description":"Cannot access number literal `2` on `Tuple` because tuple type [1] only has 2 elements, so index 2 is out of bounds. [invalid-tuple-index]"}]',children:"declare function f(s: string, n: number): boolean;\ntype Tuple = Parameters<typeof f>; // Evaluates to [string, number]\n's' as Tuple[0];\n1 as Tuple[1];\nfalse as Tuple[2]; // Error: tuple type only has two elements\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"toc-exclude",children:[(0,r.jsx)(n.code,{children:"Exclude<T, U>"})," ",(0,r.jsx)(a.V,{version:"0.209"})]}),"\n",(0,r.jsxs)(n.p,{children:["This utility type excludes all subtypes of ",(0,r.jsx)(n.code,{children:"U"})," from ",(0,r.jsx)(n.code,{children:"T"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":2,"startColumn":1,"endLine":2,"endColumn":1,"description":"Cannot cast `1` to `T` because number [1] is incompatible with `Exclude` [2]. [incompatible-type]"},{"startLine":4,"startColumn":1,"endLine":4,"endColumn":1,"description":"Cannot cast `3` to `T` because number [1] is incompatible with `Exclude` [2]. [incompatible-type]"}]',children:"type T = Exclude<1 | 2 | 3 | 4, 1 | 3>; // evaluates to 2 | 4\n1 as T; // error\n2 as T; // ok\n3 as T; // error\n4 as T; // ok\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"toc-extract",children:[(0,r.jsx)(n.code,{children:"Extract<T, U>"})," ",(0,r.jsx)(a.V,{version:"0.209"})]}),"\n",(0,r.jsxs)(n.p,{children:["This utility type retains only subtypes of ",(0,r.jsx)(n.code,{children:"U"})," from ",(0,r.jsx)(n.code,{children:"T"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":6,"startColumn":1,"endLine":6,"endColumn":9,"description":"Cannot cast `new Car()` to `T` because: [incompatible-type] Either `Car` [1] is incompatible with `Dog` [2]. Or `Car` [1] is incompatible with `Cat` [3]."}]',children:"declare class Car {}\ndeclare class Animal {}\ndeclare class Dog extends Animal {}\ndeclare class Cat extends Animal {}\ntype T = Extract<Car | Dog | Cat, Animal>; // evaluates to Dog | Cat\nnew Car() as T; // error\nnew Dog() as T; // ok\nnew Cat() as T; // ok\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"toc-this-parameter-type",children:[(0,r.jsx)(n.code,{children:"ThisParameterType<F>"})," ",(0,r.jsx)(a.V,{version:"0.209"})]}),"\n",(0,r.jsxs)(n.p,{children:["This utility type extracts the type of the ",(0,r.jsx)(n.code,{children:"this"})," parameter of a given function type."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":2,"startColumn":1,"endLine":2,"endColumn":3,"description":"Cannot cast `\'1\'` to `T` because string [1] is incompatible with number [2]. [incompatible-type]"}]',children:"type T = ThisParameterType<(this: number, bar: string) => void>; // Evaluates to number\n'1' as T; // error\n2 as T; // ok\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"toc-omit-this-parameter-type",children:[(0,r.jsx)(n.code,{children:"OmitThisParameter<F>"})," ",(0,r.jsx)(a.V,{version:"0.209"})]}),"\n",(0,r.jsxs)(n.p,{children:["This utility type removes the ",(0,r.jsx)(n.code,{children:"this"})," parameter from a given function type."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":6,"startColumn":1,"endLine":6,"endColumn":12,"description":"Cannot call `hasThisParam` because global object [1] is incompatible with number [2]. [incompatible-type]"}]',children:"type HasThisParamFun = (this: number, bar: string) => void;\ntype NoThisParamFun = OmitThisParameter<HasThisParamFun> // Evaluates to (bar: string) => void\ndeclare const hasThisParam: HasThisParamFun;\ndeclare const noThisParam: NoThisParamFun;\n\nhasThisParam(''); // error: global object is not number\nnoThisParam(''); // ok: no this type requirement\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"toc-pick",children:[(0,r.jsx)(n.code,{children:"Pick<O, Keys>"})," ",(0,r.jsx)(a.V,{version:"0.211"})]}),"\n",(0,r.jsx)(n.p,{children:"This utility type allows you to generate an object type using a subset of the fields from\nanother object type."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":5,"startColumn":11,"endLine":5,"endColumn":13,"description":"Cannot get `fooAndBar.baz` because property `baz` (did you mean `bar`?) is missing in `Pick` [1]. [prop-missing]"}]',children:"type O = {foo: number, bar: string, baz: boolean};\ntype FooAndBar = Pick<O, 'foo' | 'bar'>;\n\ndeclare const fooAndBar: FooAndBar;\nfooAndBar.baz; // error: baz is missing\nfooAndBar.foo as number; // ok\nfooAndBar.bar as string; // ok\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"toc-omit",children:[(0,r.jsx)(n.code,{children:"Omit<O, Keys>"})," ",(0,r.jsx)(a.V,{version:"0.211"})]}),"\n",(0,r.jsx)(n.p,{children:"This utility type allows you to generate an object type by omitting the specified fields from\nanother object type."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":6,"startColumn":9,"endLine":6,"endColumn":11,"description":"Cannot get `justBaz.foo` because property `foo` is missing in `Omit` [1]. [prop-missing]"},{"startLine":7,"startColumn":9,"endLine":7,"endColumn":11,"description":"Cannot get `justBaz.bar` because property `bar` (did you mean `baz`?) is missing in `Omit` [1]. [prop-missing]"}]',children:"type O = {foo: number, bar: string, baz: boolean};\ntype JustBaz= Omit<O, 'foo' | 'bar'>;\n\ndeclare const justBaz: JustBaz;\njustBaz.baz as boolean; // ok\njustBaz.foo; // error: missing foo\njustBaz.bar; // error: missing bar\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"toc-record",children:[(0,r.jsx)(n.code,{children:"Record<Keys, Type>"})," ",(0,r.jsx)(a.V,{version:"0.211"})]}),"\n",(0,r.jsxs)(n.p,{children:["This utility type allows you to generate an object type from a union of keys with the given\n",(0,r.jsx)(n.code,{children:"Type"})," for each field."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":5,"startColumn":14,"endLine":5,"endColumn":16,"description":"Cannot get `numberRecord.baz` because property `baz` (did you mean `bar`?) is missing in `Record` [1]. [prop-missing]"}]',children:"type NumberRecord = Record<'foo' | 'bar', number>;\ndeclare const numberRecord: NumberRecord;\nnumberRecord.foo as number; // ok\nnumberRecord.bar as number; // ok\nnumberRecord.baz; // error\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Note that ",(0,r.jsx)(n.code,{children:"Record"})," is different than using an indexer:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":5,"startColumn":27,"endLine":5,"endColumn":28,"description":"Cannot assign object literal to `rec` because properties `bar` and `foo` are missing in object literal [1] but exist in `Record` [2]. [incompatible-type]"}]',children:"type NumberRecord = Record<'foo' | 'bar', number>;\ntype IndexedObject = {['foo' | 'bar']: number};\n\n// Record uses explicit fields, which means they are all required\nconst rec: NumberRecord = {}; // error\n// Indexers do not have this same requirement\nconst idx: IndexedObject = {}; // no error\n"})}),"\n",(0,r.jsx)(n.h2,{id:"toc-exact",children:(0,r.jsx)(n.code,{children:"$Exact<T>"})}),"\n",(0,r.jsxs)(n.p,{children:["You can use ",(0,r.jsx)(n.code,{children:"$Exact"})," to make an ",(0,r.jsx)(n.a,{href:"../objects/#exact-and-inexact-object-types",children:"inexact object type"})," exact:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type InexactUser = {name: string, ...};\ntype ExactUser = $Exact<InexactUser>;\n\nconst user = {name: 'John Wilkes Booth'};\n// These will both be satisfied because they are equivalent:\nconst a: ExactUser = user;\nconst b: {name: string} = user;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This is an utility type to avoid, as it's clearer and more concinse to start off with an exact object type and make it inexact using ",(0,r.jsx)(n.a,{href:"../objects/#object-type-spread",children:"object type spread"}),"\n(if you wish to have both inexact and exact variants of one object type):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type ExactUser = {name: string};\ntype InexactUser = {...ExactUser, ...};\n\nconst user = {name: 'John Wilkes Booth'};\nconst a: ExactUser = user;\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"toc-nonmaybe",children:[(0,r.jsx)(n.code,{children:"NonNullable<T>"})," ",(0,r.jsx)(a.V,{version:"0.290"})," (alias ",(0,r.jsx)(n.code,{children:"$NonMaybeType<T>"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"NonNullable<T>"})," converts a type ",(0,r.jsx)(n.code,{children:"T"})," to a non-",(0,r.jsx)(n.a,{href:"../maybe",children:"maybe type"}),".\nIn other words, the values of ",(0,r.jsx)(n.code,{children:"NonNullable<T>"})," are the values of ",(0,r.jsx)(n.code,{children:"T"})," except for ",(0,r.jsx)(n.code,{children:"null"})," and ",(0,r.jsx)(n.code,{children:"undefined"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":7,"startColumn":1,"endLine":7,"endColumn":4,"description":"Cannot cast `null` to `Name` because null [1] is incompatible with string [2]. [incompatible-type]"}]',children:"type MaybeName = ?string;\ntype Name = NonNullable<MaybeName>;\n\n'Gabriel' as MaybeName; // Works\nnull as MaybeName; // Works\n'Gabriel' as Name; // Works\nnull as Name; // Error! `null` can't be annotated as Name because Name is not a maybe type\n"})}),"\n",(0,r.jsx)(n.h2,{id:"toc-keymirror",children:(0,r.jsx)(n.code,{children:"$KeyMirror<O>"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"$KeyMirror<Obj>"})," is a special case of ",(0,r.jsx)(n.code,{children:"$ObjMapi<Obj, F>"}),", when ",(0,r.jsx)(n.code,{children:"F"})," is the identity\nfunction type, ie. ",(0,r.jsx)(n.code,{children:"<K>(K) => K"}),". In other words, it maps each property of an object\nto the type of the property key. Instead of writing ",(0,r.jsx)(n.code,{children:"$ObjMapi<Obj, <K>(K) => K>"}),",\nyou can write ",(0,r.jsx)(n.code,{children:"$KeyMirror<Obj>"}),". For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":12,"startColumn":1,"endLine":12,"endColumn":8,"description":"Cannot cast `newObj.b` to string literal `a` because string literal `b` [1] is incompatible with string literal `a` [2]. [incompatible-type]"}]',children:"const obj = {\n  a: true,\n  b: 'foo'\n};\n\ndeclare function run<O: {...}>(o: O): $KeyMirror<O>;\n\n// newObj is of type {a: 'a', b: 'b'}\nconst newObj = run(obj);\n\nnewObj.a as 'a'; // Works\nnewObj.b as 'a'; // Error! String 'b' is incompatible with 'a'\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Tip: Prefer using ",(0,r.jsx)(n.code,{children:"$KeyMirror"})," instead of ",(0,r.jsx)(n.code,{children:"$ObjMapi"})," (if possible) to fix certain\nkinds of ",(0,r.jsx)(n.code,{children:"[invalid-exported-annotation]"})," errors."]}),"\n",(0,r.jsx)(n.h2,{id:"toc-class",children:(0,r.jsx)(n.code,{children:"Class<T>"})}),"\n",(0,r.jsxs)(n.p,{children:["Given a type ",(0,r.jsx)(n.code,{children:"T"})," representing instances of a class ",(0,r.jsx)(n.code,{children:"C"}),", the type ",(0,r.jsx)(n.code,{children:"Class<T>"})," is the type of the class ",(0,r.jsx)(n.code,{children:"C"}),".\nFor example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":11,"startColumn":1,"endLine":11,"endColumn":16,"description":"Cannot cast `makeStore(...)` to `Model` because `Store` [1] is incompatible with `Model` [2]. [incompatible-type]"},{"startLine":11,"startColumn":11,"endLine":11,"endColumn":15,"description":"Cannot call `makeStore` with `Model` bound to `storeClass` because `Model` [1] is incompatible with `Store` [2]. [incompatible-type]"}]',children:"class Store {}\nclass ExtendedStore extends Store {}\nclass Model {}\n\nfunction makeStore(storeClass: Class<Store>) {\n  return new storeClass();\n}\n\nmakeStore(Store) as Store;\nmakeStore(ExtendedStore) as Store;\nmakeStore(Model) as Model; // Error!\n"})}),"\n",(0,r.jsx)(n.p,{children:"For classes that take type parameters, you must also provide the parameter. For example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":9,"startColumn":28,"endLine":9,"endColumn":28,"description":"Cannot call `makeParamStore` with `1` bound to `data` because number [1] is incompatible with boolean [2]. [incompatible-type]"}]',children:"class ParamStore<T> {\n  constructor(data: T) {}\n}\n\nfunction makeParamStore<T>(storeClass: Class<ParamStore<T>>, data: T): ParamStore<T> {\n  return new storeClass(data);\n}\nmakeParamStore(ParamStore, 1) as ParamStore<number>;\nmakeParamStore(ParamStore, 1) as ParamStore<boolean>; // Error!\n"})}),"\n",(0,r.jsx)(n.h2,{id:"toc-exports",children:(0,r.jsx)(n.code,{children:"$Exports<T>"})}),"\n",(0,r.jsx)(n.p,{children:"The following are functionally equivalent"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import typeof * as T from 'my-module';\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"type T = $Exports<'my-module'>;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The advantage of the ",(0,r.jsx)(n.code,{children:"$Exports"})," syntax is that you can ",(0,r.jsx)(n.code,{children:"export"})," the type on the same line"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export type T = $Exports<'my-module'>;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["where as you would otherwise need to export an alias in the ",(0,r.jsx)(n.code,{children:"import typeof"})," case"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import typeof * as T from 'my-module';\nexport type MyModuleType = T;\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"stringprefix-and-stringsuffix-",children:[(0,r.jsx)(n.code,{children:"StringPrefix"})," and ",(0,r.jsx)(n.code,{children:"StringSuffix"})," ",(0,r.jsx)(a.V,{version:"0.242"})]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"StringPrefix"})," and ",(0,r.jsx)(n.code,{children:"StringSuffix"})," types represent strings with the specified prefix or suffix, respectively.\nTheir first type argument must be a string literal type, representing the prefix or suffix."]}),"\n",(0,r.jsxs)(n.p,{children:["You could use ",(0,r.jsx)(n.code,{children:"StringPrefix"})," to define a type that accepts strings which start with ",(0,r.jsx)(n.code,{children:"data-"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":4,"startColumn":1,"endLine":4,"endColumn":15,"description":"Cannot cast `\'random string\'` to `DataProp` because string [1] is incompatible with string prefixed with `data-` [2]. [incompatible-type]"}]',children:"type DataProp = StringPrefix<'data-'>;\n'data-foo' as DataProp; // OK\n'data-bar' as DataProp; // OK\n'random string' as DataProp; // ERROR\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You could use ",(0,r.jsx)(n.code,{children:"StringSuffix"})," to define a type that accepts strings which end with ",(0,r.jsx)(n.code,{children:"!"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":4,"startColumn":1,"endLine":4,"endColumn":15,"description":"Cannot cast `\'random string\'` to `Exclaim` because string [1] is incompatible with string suffixed with `!` [2]. [incompatible-type]"}]',children:"type Exclaim = StringSuffix<'!'>;\n'yay!' as Exclaim; // OK\n'woo!' as Exclaim; // OK\n'random string' as Exclaim; // ERROR\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You can combine these with ",(0,r.jsx)(n.a,{href:"../intersections",children:"intersection types"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":1,"endLine":3,"endColumn":15,"description":"Cannot cast `\'random string\'` to `CSSVar` because string [1] is incompatible with string prefixed with `var(--` [2]. [incompatible-type]"},{"startLine":3,"startColumn":1,"endLine":3,"endColumn":15,"description":"Cannot cast `\'random string\'` to `CSSVar` because string [1] is incompatible with string suffixed with `)` [2]. [incompatible-type]"}]',children:"type CSSVar = StringPrefix<'var(--'> & StringSuffix<')'>;\n'var(--color)' as CSSVar; // OK\n'random string' as CSSVar; // ERROR\n"})}),"\n",(0,r.jsx)(n.p,{children:"Both utilities accept an optional second type argument, which is the type of the remainder:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":4,"startColumn":1,"endLine":4,"endColumn":6,"description":"Cannot cast `\'$999\'` to `Price` because string with prefix `$` removed [1] is incompatible with union type [2]. [incompatible-type]"}]',children:"type Price = StringPrefix<'$', '1' | '2'>;\n'$1' as Price; // OK\n'$2' as Price; // OK\n'$999' as Price; // ERROR\n"})}),"\n",(0,r.jsxs)(n.p,{children:["When not specified, the type of the remainder is just ",(0,r.jsx)(n.code,{children:"string"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"removed-utility-types",children:"Removed utility types"}),"\n",(0,r.jsx)(n.p,{children:"These utility types used to exist, but no longer exist in latest versions of Flow."}),"\n",(0,r.jsxs)(n.h3,{id:"toc-diff",children:[(0,r.jsx)(n.code,{children:"$Diff<A, B>"})," ",(0,r.jsx)(a.v,{version:"0.267"})]}),"\n",(0,r.jsxs)(n.p,{children:["NOTE: Please use ",(0,r.jsx)(n.code,{children:"Omit"})," type instead."]}),"\n",(0,r.jsxs)(n.p,{children:["As the name hints, ",(0,r.jsx)(n.code,{children:"$Diff<A, B>"})," is the type representing the set difference of ",(0,r.jsx)(n.code,{children:"A"})," and ",(0,r.jsx)(n.code,{children:"B"}),", i.e. ",(0,r.jsx)(n.code,{children:"A \\ B"}),", where ",(0,r.jsx)(n.code,{children:"A"})," and ",(0,r.jsx)(n.code,{children:"B"})," are both ",(0,r.jsx)(n.a,{href:"../objects/",children:"object types"}),". Here's an example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":22,"endLine":3,"endColumn":26,"description":"Cannot resolve name `$Diff`. [cannot-resolve-name]"}]',children:"type Props = {name: string, age: number, ...};\ntype DefaultProps = {age: number};\ntype RequiredProps = $Diff<Props, DefaultProps>;\n\nfunction setProps(props: RequiredProps) {\n  // ...\n}\n\nsetProps({name: 'foo'}); // Works\nsetProps({name: 'foo', age: 42, baz: false}); // Works, you can pass extra props too\nsetProps({age: 42}); // Error! `name` is required\n"})}),"\n",(0,r.jsxs)(n.p,{children:["As you may have noticed, the example is not a random one.\n",(0,r.jsx)(n.code,{children:"$Diff"})," is exactly what the React definition file uses to define the type of the props accepted by a React Component."]}),"\n",(0,r.jsxs)(n.p,{children:["Note that ",(0,r.jsx)(n.code,{children:"$Diff<A, B>"})," will error if the object you are removing properties from does not have the property being removed, i.e. if ",(0,r.jsx)(n.code,{children:"B"})," has a key that doesn't exist in ",(0,r.jsx)(n.code,{children:"A"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"type Props = {name: string, age: number};\ntype DefaultProps = {age: number, other: string};\ntype RequiredProps = $Diff<Props, DefaultProps>; // Error!\n\nfunction setProps(props: RequiredProps) {\n  props.name;\n  // ...\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["As a workaround, you can specify the property not present in ",(0,r.jsx)(n.code,{children:"A"})," as optional. For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"type A = $Diff<{}, {nope: number}>; // Error!\ntype B = $Diff<{}, {nope: number | void}>; // Works\n\nconst a: A = {};\nconst b: B = {};\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"toc-rest",children:[(0,r.jsx)(n.code,{children:"$Rest<A, B>"})," ",(0,r.jsx)(a.v,{version:"0.266"})]}),"\n",(0,r.jsxs)(n.p,{children:["NOTE: Please use ",(0,r.jsx)(n.code,{children:"Omit"})," type instead."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"$Rest<A, B>"})," is the type that represents the runtime object rest operation, e.g.: ",(0,r.jsx)(n.code,{children:"const {foo, ...rest} = obj"}),", where ",(0,r.jsx)(n.code,{children:"A"})," and ",(0,r.jsx)(n.code,{children:"B"})," are both ",(0,r.jsx)(n.a,{href:"../objects/",children:"object types"}),".\nThe resulting type from this operation will be an object type containing ",(0,r.jsx)(n.code,{children:"A"}),"'s ",(0,r.jsx)(n.em,{children:"own"})," properties that are not ",(0,r.jsx)(n.em,{children:"own"})," properties in ",(0,r.jsx)(n.code,{children:"B"}),".\nIn flow, we treat all properties on ",(0,r.jsx)(n.a,{href:"../objects/#exact-and-inexact-object-types",children:"exact object types"})," as ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty",children:"own"}),".\nFor inexact objects, a property may or may not be own."]}),"\n",(0,r.jsx)(n.p,{children:"For example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"type Props = {name: string, age: number};\n\nconst props: Props = {name: 'Jon', age: 42};\nconst {age, ...otherProps} = props;\notherProps as $Rest<Props, {age: number}>;\notherProps.age;  // Error!\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The main difference with ",(0,r.jsx)(n.a,{href:"#toc-diff",children:(0,r.jsx)(n.code,{children:"$Diff<A, B>"})}),", is that ",(0,r.jsx)(n.code,{children:"$Rest<A, B>"})," aims to represent the true runtime rest operation,\nwhich implies that exact object types are treated differently in ",(0,r.jsx)(n.code,{children:"$Rest<A, B>"}),".\nFor example, ",(0,r.jsx)(n.code,{children:"$Rest<{n: number}, {...}>"})," will result in ",(0,r.jsx)(n.code,{children:"{n?: number}"})," because an in-exact empty object may have an ",(0,r.jsx)(n.code,{children:"n"})," property,\nwhile ",(0,r.jsx)(n.code,{children:"$Diff<{n: number}, {...}>"})," will result in ",(0,r.jsx)(n.code,{children:"{n: number}"}),"."]}),"\n",(0,r.jsxs)(n.h3,{id:"toc-propertytype",children:[(0,r.jsx)(n.code,{children:"$PropertyType<T, k>"})," ",(0,r.jsx)(a.v,{version:"0.265"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"$PropertyType<T, 'k'>"})," is equivalent to the ",(0,r.jsx)(n.code,{children:"T['k']"})," ",(0,r.jsx)(n.a,{href:"../indexed-access",children:"indexed access type"}),"."]}),"\n",(0,r.jsxs)(n.h3,{id:"toc-elementtype",children:[(0,r.jsx)(n.code,{children:"$ElementType<T, K>"})," ",(0,r.jsx)(a.v,{version:"0.265"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"$ElementType<T, K>"})," is equivalent to the ",(0,r.jsx)(n.code,{children:"T[K]"})," ",(0,r.jsx)(n.a,{href:"../indexed-access",children:"indexed access type"}),"."]}),"\n",(0,r.jsxs)(n.h3,{id:"toc-tuplemap",children:[(0,r.jsx)(n.code,{children:"$TupleMap<T, F>"})," ",(0,r.jsx)(a.v,{version:"0.247"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"$TupleMap<T, F>"})," takes an iterable type ",(0,r.jsx)(n.code,{children:"T"})," (e.g.: ",(0,r.jsx)(n.a,{href:"../tuples",children:(0,r.jsx)(n.code,{children:"Tuple"})})," or ",(0,r.jsx)(n.a,{href:"../arrays",children:(0,r.jsx)(n.code,{children:"Array"})}),"), and a ",(0,r.jsx)(n.a,{href:"../functions",children:"function type"})," ",(0,r.jsx)(n.code,{children:"F"}),",\nand returns the iterable type obtained by mapping the type of each value in the iterable with the provided function type ",(0,r.jsx)(n.code,{children:"F"}),".\nThis is analogous to the JavaScript function ",(0,r.jsx)(n.code,{children:"map"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Following our example from ",(0,r.jsx)(n.a,{href:"#toc-objmap",children:(0,r.jsx)(n.code,{children:"$ObjMap<T>"})}),", let's assume that ",(0,r.jsx)(n.code,{children:"run"})," takes an array of functions, instead of an object, and maps over them returning an array of the function call results. We could annotate its return type like this:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// Function type that takes a `() => V` and returns a `V` (its return type)\ntype ExtractReturnType = <V>(() => V) => V\n\nfunction run<A, I: Array<() => A>>(iter: I): $TupleMap<I, ExtractReturnType> {\n  return iter.map(fn => fn());\n}\n\nconst arr = [() => 'foo', () => 'bar'];\nrun(arr)[0] as string; // Works\nrun(arr)[1] as string; // Works\nrun(arr)[1] as boolean; // Error!\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"toc-call",children:[(0,r.jsx)(n.code,{children:"$Call<F, T...>"})," ",(0,r.jsx)(a.v,{version:"0.247"})]}),"\n",(0,r.jsxs)(n.p,{children:["NOTE: Please use ",(0,r.jsx)(n.a,{href:"../conditional",children:"Conditional Types"})," or ",(0,r.jsx)(n.a,{href:"../indexed-access",children:"Indexed Access Types"})," to extract types instead."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"$Call<F, T...>"})," is a type that represents the result of calling the given ",(0,r.jsx)(n.a,{href:"../functions",children:"function type"})," ",(0,r.jsx)(n.code,{children:"F"})," with 0 or more arguments ",(0,r.jsx)(n.code,{children:"T..."}),".\nThis is analogous to calling a function at runtime (or more specifically, it's analogous to calling ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call",children:(0,r.jsx)(n.code,{children:"Function.prototype.call"})}),"), but at the type level; this means that function type calls happens statically, i.e. not at runtime."]}),"\n",(0,r.jsx)(n.p,{children:"Let's see a couple of examples:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// Takes an object type, returns the type of its `prop` key\ntype ExtractPropType = <T>({prop: T, ...}) => T;\ntype Obj = {prop: number};\ntype PropType = $Call<ExtractPropType, Obj>;  // Call `ExtractPropType` with `Obj` as an argument\ntype Nope = $Call<ExtractPropType, {nope: number}>;  // Error! Argument doesn't match `Obj`.\n\n5 as PropType; // Works\ntrue as PropType;  // Error! PropType is a number\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// Takes a function type, and returns its return type\ntype ExtractReturnType = <R>(() => R) => R;\ntype Fn = () => number;\ntype ReturnType = $Call<ExtractReturnType, Fn>;\n\n5 as ReturnType;  // Works\ntrue as ReturnType;  // Error! ReturnType is a number\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"$Call"})," can be very powerful because it allows you to make calls in type-land that you would otherwise have to do at runtime.\nThe type-land calls happen statically and will be erased at runtime."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// Getting return types:\nfunction getFirstValue<V>(map: Map<string, V>): ?V {\n  for (const [key, value] of map.entries()) {\n    return value;\n  }\n  return null;\n}\n\n// Using $Call, we can get the actual return type of the function above:\ntype Value = $Call<typeof getFirstValue, Map<string, number>>;\n\n5 as Value;\ntrue as Value;  // Error! Value is a `number`\n\n// We could generalize it further:\ntype GetMapValue<M> =\n  $Call<typeof getFirstValue, M>;\n\n5 as GetMapValue<Map<string, number>>;\ntrue as GetMapValue<Map<string, boolean>>;\ntrue as GetMapValue<Map<string, number>>;  // Error! value is a `number`\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"toc-objmap",children:[(0,r.jsx)(n.code,{children:"$ObjMap<T, F>"})," ",(0,r.jsx)(a.v,{version:"0.246"})]}),"\n",(0,r.jsxs)(n.p,{children:["NOTE: Please use ",(0,r.jsx)(n.a,{href:"../mapped-types",children:"Mapped Types"})," instead."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"ObjMap<T, F>"})," takes an ",(0,r.jsx)(n.a,{href:"../objects",children:"object type"})," ",(0,r.jsx)(n.code,{children:"T"}),", and a ",(0,r.jsx)(n.a,{href:"../functions",children:"function type"})," ",(0,r.jsx)(n.code,{children:"F"}),", and returns the object type obtained by mapping the type of each value in the object with the provided function type ",(0,r.jsx)(n.code,{children:"F"}),". In other words, ",(0,r.jsx)(n.code,{children:"$ObjMap"})," will ",(0,r.jsx)(n.a,{href:"#toc-call",children:"call"})," (at the type level) the given function type ",(0,r.jsx)(n.code,{children:"F"})," for every property value type in ",(0,r.jsx)(n.code,{children:"T"}),", and return the resulting object type from those calls."]}),"\n",(0,r.jsxs)(n.p,{children:["Let's see an example. Suppose you have a function called ",(0,r.jsx)(n.code,{children:"run"})," that takes an object of thunks (functions in the form ",(0,r.jsx)(n.code,{children:"() => A"}),") as input:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function run<O: {[key: string]: (...ReadonlyArray<unknown>) => unknown}>(o: O): $FlowFixMe {\n  return Object.keys(o).reduce<{[string]: (...ReadonlyArray<unknown>) => unknown}>(\n    (acc, k) => ({...acc, [(k: string)]: o[k]()}),\n    {},\n  );\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"The function's purpose is to run all the thunks and return an object made of values. What's the return type of this function?"}),"\n",(0,r.jsx)(n.p,{children:"The keys are the same, but the values have a different type, namely the return type of each function.\nAt a value level (the implementation of the function) we're essentially mapping over the object to produce new values for the keys.\nHow to express this at a type level?"}),"\n",(0,r.jsxs)(n.p,{children:["This is where ",(0,r.jsx)(n.code,{children:"ObjMap<T, F>"})," comes in handy"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// let's write a function type that takes a `() => V` and returns a `V` (its return type)\ntype ExtractReturnType = <V>(() => V) => V;\n\ndeclare function run<O: {[key: string]: (...ReadonlyArray<unknown>) => unknown}>(o: O): $ObjMap<O, ExtractReturnType>;\n\nconst o = {\n  a: () => true,\n  b: () => 'foo'\n};\n\nrun(o).a as boolean; // Works\nrun(o).b as string;  // Works\nrun(o).b as boolean; // Error! `b` is a string\nrun(o).c;            // Error! `c` was not in the original object\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This is extremely useful for expressing the return type of functions that manipulate objects values.\nYou could use a similar approach (for instance) to provide the return type of bluebird's ",(0,r.jsx)(n.a,{href:"http://bluebirdjs.com/docs/api/promise.props.html",children:(0,r.jsx)(n.code,{children:"Promise.props"})})," function,\nwhich is like ",(0,r.jsx)(n.code,{children:"Promise.all"})," but takes an object as input."]}),"\n",(0,r.jsx)(n.p,{children:"Here's a possible declaration of this function, which is very similar to our first example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"declare function props<A, O: {[key: string]: A}>(promises: O): Promise<$ObjMap<O, <T>(p: Promise<T> | T) => T>>>;\n\nconst promises = {a: Promise.resolve(42)};\nprops(promises).then(o => {\n  o.a as 42; // Works\n  o.a as 43; // Error! Flow knows it's 42\n});\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"toc-objmapi",children:[(0,r.jsx)(n.code,{children:"$ObjMapi<T, F>"})," ",(0,r.jsx)(a.v,{version:"0.246"})]}),"\n",(0,r.jsxs)(n.p,{children:["NOTE: Please use ",(0,r.jsx)(n.a,{href:"../mapped-types",children:"Mapped Types"})," instead."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"ObjMapi<T, F>"})," is similar to ",(0,r.jsx)(n.a,{href:"#toc-objmap",children:(0,r.jsx)(n.code,{children:"ObjMap<T, F>"})}),". The difference is that function\ntype ",(0,r.jsx)(n.code,{children:"F"})," will be ",(0,r.jsx)(n.a,{href:"#toc-call",children:"called"})," with both the key and value types of the elements of\nthe object type ",(0,r.jsx)(n.code,{children:"T"}),", instead of just the value types. For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const o = {\n  a: () => true,\n  b: () => 'foo'\n};\n\ntype ExtractReturnObjectType = <K, V>(K, () => V) => { k: K, v: V };\n\ndeclare function run<O: {...}>(o: O): $ObjMapi<O, ExtractReturnObjectType>;\n\nrun(o).a as {k: 'a', v: boolean}; // Works\nrun(o).b as {k: 'b', v: string};  // Works\nrun(o).a as {k: 'b', v: boolean}; // Error! `a.k` is \"a\"\nrun(o).b as {k: 'b', v: number};  // Error! `b.v` is a string\nrun(o).c;                         // Error! `c` was not in the original object\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"toc-objmapconst",children:[(0,r.jsx)(n.code,{children:"$ObjMapConst<O, T>"})," ",(0,r.jsx)(a.v,{version:"0.246"})]}),"\n",(0,r.jsxs)(n.p,{children:["NOTE: Please use ",(0,r.jsx)(n.a,{href:"../mapped-types",children:"Mapped Types"})," instead."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"$ObjMapConst<Obj, T>"})," is a special case of ",(0,r.jsx)(n.code,{children:"$ObjMap<Obj, F>"}),", when ",(0,r.jsx)(n.code,{children:"F"})," is a constant\nfunction type, e.g. ",(0,r.jsx)(n.code,{children:"() => T"}),". Instead of writing ",(0,r.jsx)(n.code,{children:"$ObjMap<Obj, () => T>"}),", you\ncan write ",(0,r.jsx)(n.code,{children:"$ObjMapConst<Obj, T>"}),". For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const obj = {\n  a: true,\n  b: 'foo'\n};\n\ndeclare function run<O: {...}>(o: O): $ObjMapConst<O, number>;\n\n// newObj is of type {a: number, b: number}\nconst newObj = run(obj);\n\nnewObj.a as number; // Works\nnewObj.b as string; // Error! Property `b` is a number\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Tip: Prefer using ",(0,r.jsx)(n.code,{children:"$ObjMapConst"})," instead of ",(0,r.jsx)(n.code,{children:"$ObjMap"})," (if possible) to fix certain\nkinds of ",(0,r.jsx)(n.code,{children:"[invalid-exported-annotation]"})," errors."]}),"\n",(0,r.jsxs)(n.h3,{id:"partial-",children:[(0,r.jsx)(n.code,{children:"$Partial"})," ",(0,r.jsx)(a.v,{version:"0.202"})]}),"\n",(0,r.jsxs)(n.p,{children:["A former alias of ",(0,r.jsx)(n.a,{href:"#toc-partial",children:"Partial"}),". Support was removed in version 0.203."]}),"\n",(0,r.jsxs)(n.h3,{id:"toc-shape",children:[(0,r.jsx)(n.code,{children:"$Shape<T>"})," ",(0,r.jsx)(a.v,{version:"0.206"})]}),"\n",(0,r.jsxs)(n.p,{children:["NOTE: This utility is unsafe - please use ",(0,r.jsx)(n.a,{href:"#toc-partial",children:(0,r.jsx)(n.code,{children:"Partial"})})," documented above to make all of an object's fields optional."]}),"\n",(0,r.jsxs)(n.p,{children:["A variable of type ",(0,r.jsx)(n.code,{children:"$Shape<T>"}),", where ",(0,r.jsx)(n.code,{children:"T"})," is some object type, can be assigned objects ",(0,r.jsx)(n.code,{children:"o"}),"\nthat contain a subset of the properties included in ",(0,r.jsx)(n.code,{children:"T"}),". For each property ",(0,r.jsx)(n.code,{children:"p: S"})," of ",(0,r.jsx)(n.code,{children:"T"}),",\nthe type of a potential binding of ",(0,r.jsx)(n.code,{children:"p"})," in ",(0,r.jsx)(n.code,{children:"o"})," must be compatible with ",(0,r.jsx)(n.code,{children:"S"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"For example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"type Person = {\n  age: number,\n  name: string,\n};\n// $FlowIgnore[deprecated-utility]\ntype PersonDetails = $Shape<Person>;\n\nconst person1: Person = {age: 28};  // ERROR: missing `name`\nconst person2: Person = {name: 'a'};  // ERROR: missing `age`\nconst person3: PersonDetails = {age: 28};  // OK\nconst person4: PersonDetails = {name: 'a'};  // OK\nconst person5: PersonDetails = {age: 28, name: 'a'};  // OK\nconst person6: PersonDetails = {age: '28'};  // ERROR: string is incompatible with number\n"})}),"\n",(0,r.jsxs)(n.p,{children:["NOTE: ",(0,r.jsx)(n.code,{children:"$Shape<T>"})," is ",(0,r.jsx)(n.strong,{children:"not"})," equivalent to ",(0,r.jsx)(n.code,{children:"T"})," with all its fields marked as optional.\nIn particular, Flow unsoundly allows ",(0,r.jsx)(n.code,{children:"$Shape<T>"})," to be used as a ",(0,r.jsx)(n.code,{children:"T"})," in several\ncontexts. For example in"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const personShape: PersonDetails = {age: 28};\npersonShape as Person;\n"})}),"\n",(0,r.jsx)(n.p,{children:"Flow will unsoundly allow this last cast to succeed."}),"\n",(0,r.jsx)(n.p,{children:"It is also not equivalent to itself in some contexts:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function f<T>(input: $Shape<T>): $Shape<T> {\n  return input; // ERROR: `T` is incompatible with `$Shape` of `T`\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This utility type is deprecated and will be deleted in the future -\nuse ",(0,r.jsx)(n.a,{href:"#toc-partial",children:(0,r.jsx)(n.code,{children:"Partial"})})," instead."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},86543(e,n,t){t.d(n,{V:()=>r,v:()=>o});t(96540);var s=t(74848);function r(e){let{version:n}=e;return(0,s.jsxs)("span",{class:"version added",title:`Added in ${n}`,children:["\u2265",n]})}function o(e){let{version:n}=e;return(0,s.jsxs)("span",{class:"version removed",title:`Removed after ${n}`,children:["\u2264",n]})}},28453(e,n,t){t.d(n,{R:()=>a,x:()=>i});var s=t(96540);const r={},o=s.createContext(r);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);