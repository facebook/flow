"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[693],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var s=t(96540);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}},70693:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"linting/rule-reference","title":"Lint Rule Reference","description":"all","source":"@site/docs/linting/rule-reference.md","sourceDirName":"linting","slug":"/linting/rule-reference","permalink":"/en/docs/linting/rule-reference","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/linting/rule-reference.md","tags":[],"version":"current","frontMatter":{"title":"Lint Rule Reference","slug":"/linting/rule-reference"},"sidebar":"docsSidebar","previous":{"title":"Flowlint Comments","permalink":"/en/docs/linting/flowlint-comments"},"next":{"title":"Flow Strict","permalink":"/en/docs/strict"}}');var i=t(74848),o=t(28453);const r={title:"Lint Rule Reference",slug:"/linting/rule-reference"},c=void 0,l={},a=[{value:"<code>all</code>",id:"toc-all",level:3},{value:"<code>ambiguous-object-type</code>",id:"toc-ambiguous-object-type",level:3},{value:"<code>deprecated-type</code>",id:"toc-deprecated-type",level:3},{value:"<code>implicit-inexact-object</code>",id:"toc-implicit-inexact-object",level:3},{value:"<code>nonstrict-import</code>",id:"toc-nonstrict-import",level:3},{value:"<code>sketchy-null</code>",id:"toc-sketchy-null",level:3},{value:"<code>sketchy-number</code>",id:"toc-sketchy-number",level:3},{value:"<code>unclear-type</code>",id:"toc-unclear-type",level:3},{value:"<code>unnecessary-invariant</code>",id:"toc-unnecessary-invariant",level:3},{value:"<code>unnecessary-optional-chain</code>",id:"toc-unnecessary-optional-chain",level:3},{value:"<code>unsafe-getters-setters</code>",id:"toc-unsafe-getters-setters",level:3},{value:"<code>untyped-import</code>",id:"toc-untyped-import",level:3},{value:"<code>untyped-type-import</code>",id:"toc-untyped-type-import",level:3},{value:"<code>unused-promise</code>",id:"toc-unused-promise",level:3}];function d(e){const n={a:"a",code:"code",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h3,{id:"toc-all",children:(0,i.jsx)(n.code,{children:"all"})}),"\n",(0,i.jsxs)(n.p,{children:["While ",(0,i.jsx)(n.code,{children:"all"})," isn't technically a lint rule, it's worth mentioning here. ",(0,i.jsx)(n.code,{children:"all"})," sets the default\nlevel for lint rules that don't have a level set explicitly. ",(0,i.jsx)(n.code,{children:"all"})," can only\noccur as the first entry in a ",(0,i.jsx)(n.code,{children:".flowconfig"})," or as the first rule in a ",(0,i.jsx)(n.code,{children:"--lints"}),"\nflag. It's not allowed in comments at all because it would have different\nsemantics than would be expected."]}),"\n",(0,i.jsx)(n.h3,{id:"toc-ambiguous-object-type",children:(0,i.jsx)(n.code,{children:"ambiguous-object-type"})}),"\n",(0,i.jsx)(n.p,{children:"Triggers when you use object type syntax without explicitly specifying exactness or inexactness."}),"\n",(0,i.jsxs)(n.p,{children:["This lint setting is ignored when ",(0,i.jsx)(n.a,{href:"../../config/options/#toc-exact-by-default",children:(0,i.jsx)(n.code,{children:"exact_by_default"})})," is set to ",(0,i.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":10,"endLine":3,"endColumn":20,"description":"Please write this object type as explicitly exact (use `{|` and `|}` instead of `{` and `}`) or as explicitly inexact (add `...` to the end of the list of properties). [ambiguous-object-type]"}]',children:"// flowlint ambiguous-object-type:error\n\ntype A = {x: number}; // Error\ntype B = {x: number, ...} // Ok\ntype C = {| x: number |} // Ok\n"})}),"\n",(0,i.jsx)(n.h3,{id:"toc-deprecated-type",children:(0,i.jsx)(n.code,{children:"deprecated-type"})}),"\n",(0,i.jsxs)(n.p,{children:["Triggered on the ",(0,i.jsx)(n.code,{children:"bool"})," type, which is just an alias for ",(0,i.jsx)(n.code,{children:"boolean"}),". Just use ",(0,i.jsx)(n.code,{children:"boolean"})," instead."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":1,"startColumn":13,"endLine":1,"endColumn":33,"description":"Redundant argument. This argument doesn\'t change any lint settings. [lint-setting]"},{"startLine":3,"startColumn":16,"endLine":3,"endColumn":19,"description":"Deprecated type. Use `boolean` instead. [deprecated-type]"}]',children:"// flowlint deprecated-type:error\n\ntype A = Array<bool>; // Error\n"})}),"\n",(0,i.jsx)(n.h3,{id:"toc-implicit-inexact-object",children:(0,i.jsx)(n.code,{children:"implicit-inexact-object"})}),"\n",(0,i.jsxs)(n.p,{children:["Like ",(0,i.jsx)(n.a,{href:"#toc-ambiguous-object-type",children:(0,i.jsx)(n.code,{children:"ambiguous-object-type"})}),", except triggers even when the ",(0,i.jsx)(n.code,{children:"exact_by_default"})," option is set to ",(0,i.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"toc-nonstrict-import",children:(0,i.jsx)(n.code,{children:"nonstrict-import"})}),"\n",(0,i.jsxs)(n.p,{children:["Used in conjunction with ",(0,i.jsx)(n.a,{href:"../../strict/",children:"Flow Strict"}),". Triggers when importing a non ",(0,i.jsx)(n.code,{children:"@flow strict"})," module. When enabled, dependencies of a ",(0,i.jsx)(n.code,{children:"@flow strict"})," module must also be ",(0,i.jsx)(n.code,{children:"@flow strict"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"toc-sketchy-null",children:(0,i.jsx)(n.code,{children:"sketchy-null"})}),"\n",(0,i.jsx)(n.p,{children:"Triggers when you do an existence check on a value that can be either null/undefined or falsey."}),"\n",(0,i.jsx)(n.p,{children:"For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":4,"startColumn":5,"endLine":4,"endColumn":5,"description":"Sketchy null check on number [1] which is potentially 0. Perhaps you meant to check for null or undefined [2]? [sketchy-null-number]"}]',children:"// flowlint sketchy-null:error\n\nconst x: ?number = 5;\nif (x) {} // sketchy because x could be either null or 0.\n\nconst y: number = 5;\nif (y) {} // not sketchy because y can't be null, only 0.\n\nconst z: ?{foo: number} = {foo: 5};\nif (z) {} // not sketchy, because z can't be falsey, only null/undefined.\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Setting ",(0,i.jsx)(n.code,{children:"sketchy-null"})," sets the level for all sketchy null checks, but there are more granular rules for particular types. These are:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"sketchy-null-bool"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"sketchy-null-number"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"sketchy-null-string"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"sketchy-null-mixed"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"sketchy-null-bigint"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The type-specific variants are useful for specifying that some types of sketchy null checks are acceptable while others should be errors/warnings. For example, if you want to allow boolean sketchy null checks (for the pattern of treating undefined optional booleans as false) but forbid other types of sketchy null checks, you can do so with this ",(0,i.jsx)(n.code,{children:".flowconfig"})," ",(0,i.jsx)(n.code,{children:"[lints]"})," section:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"[lints]\nsketchy-null=warn\nsketchy-null-bool=off\n"})}),"\n",(0,i.jsx)(n.p,{children:"and now"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function foo (bar: ?bool): void {\n  if (bar) {\n    ...\n  } else {\n    ...\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"doesn't report a warning."}),"\n",(0,i.jsx)(n.p,{children:"Suppressing one type of sketchy null check only suppresses that type, so, for example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":2,"startColumn":21,"endLine":2,"endColumn":24,"description":"Deprecated type. Use `boolean` instead. [deprecated-type]"},{"startLine":3,"startColumn":5,"endLine":3,"endColumn":5,"description":"Sketchy null check on number [1] which is potentially 0. Perhaps you meant to check for null or undefined [2]? [sketchy-null-number]"}]',children:"// flowlint sketchy-null:error, sketchy-null-bool:off\nconst x: ?(number | bool) = 0;\nif (x) {}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["would still have a ",(0,i.jsx)(n.code,{children:"sketchy-null-number"})," error on line 3."]}),"\n",(0,i.jsx)(n.h3,{id:"toc-sketchy-number",children:(0,i.jsx)(n.code,{children:"sketchy-number"})}),"\n",(0,i.jsxs)(n.p,{children:["Triggers when a ",(0,i.jsx)(n.code,{children:"number"})," is used in a manner which may lead to unexpected results if the value is falsy.\nCurrently, this lint triggers if a ",(0,i.jsx)(n.code,{children:"number"})," appears in:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["the left-hand side of an ",(0,i.jsx)(n.code,{children:"&&"})," expression."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"As a motivating example, consider this common idiom in React:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"{showFoo && <Foo />}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here, ",(0,i.jsx)(n.code,{children:"showFoo"})," is a boolean which controls whether or not to display the ",(0,i.jsx)(n.code,{children:"<Foo />"})," element. If ",(0,i.jsx)(n.code,{children:"showFoo"})," is true, then this evaluates to ",(0,i.jsx)(n.code,{children:"{<Foo />}"}),". If ",(0,i.jsx)(n.code,{children:"showFoo"})," is false, then this evaluates to ",(0,i.jsx)(n.code,{children:"{false}"}),", which doesn't display anything."]}),"\n",(0,i.jsx)(n.p,{children:"Now suppose that instead of a boolean, we have a numerical value representing, say, the number of comments on a post. We want to display a count of the comments, unless there are no comments. We might naively try to do something similar to the boolean case:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"{count && <>[{count} comments]</>}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.code,{children:"count"})," is, say, ",(0,i.jsx)(n.code,{children:"5"}),', then this displays "[5 comments]". However, if ',(0,i.jsx)(n.code,{children:"count"})," is ",(0,i.jsx)(n.code,{children:"0"}),', then this displays "0" instead of displaying nothing. (This problem is unique to ',(0,i.jsx)(n.code,{children:"number"})," because ",(0,i.jsx)(n.code,{children:"0"})," and ",(0,i.jsx)(n.code,{children:"NaN"})," are the only falsy values which React renders with a visible result.) This could be subtly dangerous: if this immediately follows another numerical value, it might appear to the user that we have multiplied that value by 10! Instead, we should do a proper conditional check:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"{count ? <>[{count} comments]</> : null}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"toc-unclear-type",children:(0,i.jsx)(n.code,{children:"unclear-type"})}),"\n",(0,i.jsxs)(n.p,{children:["Triggers when you use ",(0,i.jsx)(n.code,{children:"any"}),", ",(0,i.jsx)(n.code,{children:"Object"}),", or ",(0,i.jsx)(n.code,{children:"Function"})," as type annotations. These\ntypes are unsafe."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":18,"endLine":3,"endColumn":20,"description":"Unclear type. Using `any`, `Object`, or `Function` types is not safe! [unclear-type]"},{"startLine":4,"startColumn":18,"endLine":4,"endColumn":23,"description":"Unclear type. Using `any`, `Object`, or `Function` types is not safe! [unclear-type]"},{"startLine":5,"startColumn":18,"endLine":5,"endColumn":25,"description":"Unclear type. Using `any`, `Object`, or `Function` types is not safe! [unclear-type]"}]',children:"// flowlint unclear-type:error\n\ndeclare const a: any; // Error\ndeclare const c: Object; // Error\ndeclare const d: Function; // Error\n"})}),"\n",(0,i.jsx)(n.h3,{id:"toc-unnecessary-invariant",children:(0,i.jsx)(n.code,{children:"unnecessary-invariant"})}),"\n",(0,i.jsxs)(n.p,{children:["Triggers when you use ",(0,i.jsx)(n.code,{children:"invariant"})," to check a condition which we know must be truthy based on the available type information. This is quite conservative: for example, if all we know about the condition is that it is a ",(0,i.jsx)(n.code,{children:"boolean"}),", then the lint will not fire even if the condition must be ",(0,i.jsx)(n.code,{children:"true"})," at runtime."]}),"\n",(0,i.jsxs)(n.p,{children:["Note that this lint does not trigger when we know a condition is always ",(0,i.jsx)(n.code,{children:"false"}),". It is a common idiom to use ",(0,i.jsx)(n.code,{children:"invariant()"})," or ",(0,i.jsx)(n.code,{children:"invariant(false, ...)"})," to throw in code that should be unreachable."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":5,"startColumn":1,"endLine":5,"endColumn":12,"description":"This use of `invariant` is unnecessary because array type [1] is always truthy. [unnecessary-invariant]"}]',children:"// flowlint unnecessary-invariant:error\ndeclare function invariant(boolean): void;\n\ndeclare const x: Array<string>; // Array is truthy\ninvariant(x);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"toc-unnecessary-optional-chain",children:(0,i.jsx)(n.code,{children:"unnecessary-optional-chain"})}),"\n",(0,i.jsxs)(n.p,{children:["Triggers when you use ",(0,i.jsx)(n.code,{children:"?."})," where it isn't needed. This comes in two main flavors. The first is when the left-hand-side cannot be nullish:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":7,"startColumn":1,"endLine":7,"endColumn":8,"description":"This use of optional chaining (`?.`) is unnecessary because `foo` [1] cannot be nullish or because an earlier `?.` will short-circuit the nullish case. [unnecessary-optional-chain]"}]',children:"// flowlint unnecessary-optional-chain:error\ntype Foo = {\n  bar: number\n}\n\ndeclare const foo: Foo;\nfoo?.bar; // Error\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The second is when the left-hand-side could be nullish, but the short-circuiting behavior of ",(0,i.jsx)(n.code,{children:"?."})," is sufficient to handle it anyway:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":9,"startColumn":1,"endLine":9,"endColumn":13,"description":"This use of optional chaining (`?.`) is unnecessary because `foo?.bar` [1] cannot be nullish or because an earlier `?.` will short-circuit the nullish case. [unnecessary-optional-chain]"}]',children:"// flowlint unnecessary-optional-chain:error\ntype Foo = {\n  bar: {\n    baz: number\n  }\n}\n\ndeclare const foo: ?Foo;\nfoo?.bar?.baz; // Error\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the second example, the first use of ",(0,i.jsx)(n.code,{children:"?."})," is valid, since ",(0,i.jsx)(n.code,{children:"foo"})," is potentially nullish, but the second use of ",(0,i.jsx)(n.code,{children:"?."})," is unnecessary. The left-hand-side of the second ",(0,i.jsx)(n.code,{children:"?."})," (",(0,i.jsx)(n.code,{children:"foo?.bar"}),") can only be nullish as a result of ",(0,i.jsx)(n.code,{children:"foo"})," being nullish, and when ",(0,i.jsx)(n.code,{children:"foo"})," is nullish, short-circuiting lets us avoid the second ",(0,i.jsx)(n.code,{children:"?."})," altogether!"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"foo?.bar.baz;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This makes it clear to the reader that ",(0,i.jsx)(n.code,{children:"bar"})," is not a potentially nullish property."]}),"\n",(0,i.jsx)(n.h3,{id:"toc-unsafe-getters-setters",children:(0,i.jsx)(n.code,{children:"unsafe-getters-setters"})}),"\n",(0,i.jsx)(n.p,{children:"Triggers when you use getters or setters. Getters and setters can have side\neffects and are unsafe."}),"\n",(0,i.jsx)(n.p,{children:"For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":4,"startColumn":3,"endLine":4,"endColumn":23,"description":"Getters and setters can have side effects and are unsafe. [unsafe-getters-setters]"},{"startLine":5,"startColumn":3,"endLine":5,"endColumn":29,"description":"Getters and setters can have side effects and are unsafe. [unsafe-getters-setters]"}]',children:"// flowlint unsafe-getters-setters:error\nlet a = 1;\nconst o = {\n  get a() { return a; }, // Error: unsafe-getters-setters\n  set b(x: number) { a = x; }, // Error: unsafe-getters-setters\n  c: 10,\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"toc-untyped-import",children:(0,i.jsx)(n.code,{children:"untyped-import"})}),"\n",(0,i.jsxs)(n.p,{children:["Triggers when you import from an untyped file. Importing from an untyped file\nresults in those imports being typed as ",(0,i.jsx)(n.code,{children:"any"}),", which is unsafe."]}),"\n",(0,i.jsx)(n.h3,{id:"toc-untyped-type-import",children:(0,i.jsx)(n.code,{children:"untyped-type-import"})}),"\n",(0,i.jsxs)(n.p,{children:["Triggers when you import a type from an untyped file. Importing a type from an\nuntyped file results in an ",(0,i.jsx)(n.code,{children:"any"})," alias, which is typically not the intended behavior.\nEnabling this lint brings extra attention to this case and can help improve Flow\ncoverage of typed files by limiting the spread of implicit ",(0,i.jsx)(n.code,{children:"any"})," types."]}),"\n",(0,i.jsx)(n.h3,{id:"toc-unused-promise",children:(0,i.jsx)(n.code,{children:"unused-promise"})}),"\n",(0,i.jsxs)(n.p,{children:["Triggers when a ",(0,i.jsx)(n.code,{children:"Promise"})," is unused. This can be dangerous, because errors are potentially unhandled, and the code may not execute in the desired order."]}),"\n",(0,i.jsx)(n.p,{children:'A promise can be "used" by...'}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"await"}),"ing it"]}),"\n",(0,i.jsxs)(n.li,{children:["Calling ",(0,i.jsx)(n.code,{children:".then"})," with a rejection handler (i.e., with two arguments)"]}),"\n",(0,i.jsxs)(n.li,{children:["Calling ",(0,i.jsx)(n.code,{children:".catch"})]}),"\n",(0,i.jsxs)(n.li,{children:["Calling ",(0,i.jsx)(n.code,{children:".finally"})]}),"\n",(0,i.jsx)(n.li,{children:"Storing it in a variable, passing it to a function, etc."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":6,"startColumn":3,"endLine":6,"endColumn":8,"description":"`Promise` in async scope is unused. Did you mean to `await` it? [unused-promise]"},{"startLine":11,"startColumn":3,"endLine":11,"endColumn":8,"description":"`Promise` in sync scope is unused. Promises must be handled by calling .then with a rejection handler, .catch, or .finally. [unused-promise]"}]',children:"// flowlint unused-promise:error\ndeclare function foo(): Promise<void>;\n\nasync function bar() {\n  await foo(); // ok\n  foo(); // error, we forgot to await!\n}\n\nfunction baz() {\n  foo().catch(err => {console.log(err)}); // ok\n  foo(); // error\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can explicitly ignore the promise with the ",(0,i.jsx)(n.code,{children:"void"})," operator (e.g., ",(0,i.jsx)(n.code,{children:"void foo();"}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["Note: As of v0.201.0, this rule subsumed the ",(0,i.jsx)(n.code,{children:"unused-promise-in-async-scope"})," and ",(0,i.jsx)(n.code,{children:"unused-promise-in-sync-scope"})," rules."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);