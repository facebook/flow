"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[9389],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>s});var o=n(96540);const r={},a=o.createContext(r);function i(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(a.Provider,{value:t},e.children)}},44743:e=>{e.exports=JSON.parse('{"permalink":"/blog/2015/02/18/Import-Types","source":"@site/blog/2015-02-18-Import-Types.md","title":"Announcing Import Type","description":"As of Flow 0.3.0, it\'s now possible to import types from another module. So, for example, if you\'re only importing a class for purposes of referencing it in a type annotation, you can now use the new import type syntax to do this.","date":"2015-02-18T00:00:00.000Z","tags":[],"hasTruncateMarker":true,"authors":[{"name":"Jeff Morrison","key":null,"page":null}],"frontMatter":{"title":"Announcing Import Type","short-title":"Import Type","author":"Jeff Morrison","hide_table_of_contents":true},"unlisted":false,"prevItem":{"title":"Announcing Flow Comments","permalink":"/blog/2015/02/20/Flow-Comments"},"nextItem":{"title":"Announcing Typecasts","permalink":"/blog/2015/02/18/Typecasts"}}')},79389:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var o=n(44743),r=n(74848),a=n(28453);const i={title:"Announcing Import Type","short-title":"Import Type",author:"Jeff Morrison",hide_table_of_contents:!0},s=void 0,l={authorsImageUrls:[void 0]},p=[{value:"Motivation",id:"motivation",level:2},{value:"Enter Import Type",id:"enter-import-type",level:2},{value:"Transformations",id:"transformations",level:2},{value:"Anticipatory Q&amp;A",id:"anticipatory-qa",level:2},{value:"Wait, but what happens at runtime after I&#39;ve added an <code>import type</code> declaration?",id:"wait-but-what-happens-at-runtime-after-ive-added-an-import-type-declaration",level:3},{value:"Can I use <code>import type</code> to pull in type aliases from another module, too?",id:"can-i-use-import-type-to-pull-in-type-aliases-from-another-module-too",level:3}];function c(e){const t={code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["As of Flow 0.3.0, it's now possible to import types from another module. So, for example, if you're only importing a class for purposes of referencing it in a type annotation, you can now use the new ",(0,r.jsx)(t.code,{children:"import type"})," syntax to do this."]}),"\n",(0,r.jsx)(t.h2,{id:"motivation",children:"Motivation"}),"\n",(0,r.jsx)(t.p,{children:"Has this ever happened to you:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-JavaScript",children:"// @flow\n\n// Post-transformation lint error: Unused variable 'URI'\nimport URI from \"URI\";\n\n// But if you delete the require you get a Flow error:\n// identifier URI - Unknown global name\nmodule.exports = function(x: URI): URI {\n  return x;\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Now you have an out! To solve this problem (and with an eye toward a near future with ES6 module syntax), we've added the new ",(0,r.jsx)(t.code,{children:"import type"})," syntax.  With ",(0,r.jsx)(t.code,{children:"import type"}),", you can convey what you really mean here \u2014 that you want to import the ",(0,r.jsx)(t.em,{children:"type"})," of the class and not really the class itself."]}),"\n",(0,r.jsx)(t.h2,{id:"enter-import-type",children:"Enter Import Type"}),"\n",(0,r.jsx)(t.p,{children:"So instead of the above code, you can now write this:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-JavaScript",children:"// @flow\n\nimport type URI from 'URI';\nmodule.exports = function(x: URI): URI {\n  return x;\n};\n"})}),"\n",(0,r.jsx)(t.p,{children:"If you have a module that exports multiple classes (like, say, a Crayon and a Marker class), you can import the type for each of them together or separately like this:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-JavaScript",children:"// @flow\n\nimport type {Crayon, Marker} from 'WritingUtensils';\nmodule.exports = function junkDrawer(x: Crayon, y: Marker): void {}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"transformations",children:"Transformations"}),"\n",(0,r.jsxs)(t.p,{children:["Like type annotations and other Flow features, ",(0,r.jsx)(t.code,{children:"import type"})," need to be transformed away before the code can be run. The transforms will be available in react-tools ",(0,r.jsx)(t.code,{children:"0.13.0"})," when it is published soon, but for now they're available in ",(0,r.jsx)(t.code,{children:"0.13.0-beta.2"}),", which you can install with"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"npm install react-tools@0.13.0-beta.2\n"})}),"\n",(0,r.jsx)(t.h2,{id:"anticipatory-qa",children:"Anticipatory Q&A"}),"\n",(0,r.jsxs)(t.h3,{id:"wait-but-what-happens-at-runtime-after-ive-added-an-import-type-declaration",children:["Wait, but what happens at runtime after I've added an ",(0,r.jsx)(t.code,{children:"import type"})," declaration?"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsxs)(t.em,{children:["Nothing! All ",(0,r.jsx)(t.code,{children:"import type"})," declarations get stripped away just like other flow syntax."]})}),"\n",(0,r.jsxs)(t.h3,{id:"can-i-use-import-type-to-pull-in-type-aliases-from-another-module-too",children:["Can I use ",(0,r.jsx)(t.code,{children:"import type"})," to pull in type aliases from another module, too?"]}),"\n",(0,r.jsx)("del",{children:"Not quite yet...but soon! There are a few other moving parts that we need to build first, but we're working on it."}),"\n",(0,r.jsxs)(t.p,{children:["EDIT: Yes! As of Flow 0.10 you can use the ",(0,r.jsx)(t.code,{children:"export type MyType = ... ;"})," syntax to compliment the ",(0,r.jsx)(t.code,{children:"import type"})," syntax. Here's a trivial example:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"// @flow\n\n// MyTypes.js\nexport type UserID = number;\nexport type User = {\n  id: UserID,\n  firstName: string,\n  lastName: string\n};\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:'// @flow\n\n// User.js\nimport type {UserID, User} from "MyTypes";\n\nfunction getUserID(user: User): UserID {\n  return user.id;\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["Note that we only support the explicit named-export statements for now (i.e. ",(0,r.jsx)(t.code,{children:"export type UserID = number;"}),"). In a future version we can add support for latent named-export statements (i.e. ",(0,r.jsx)(t.code,{children:"type UserID = number; export {UserID};"}),") and default type exports (i.e.  ",(0,r.jsx)(t.code,{children:"export default type MyType = ... ;"}),")...but for now these forms aren't yet supported for type exports."]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);