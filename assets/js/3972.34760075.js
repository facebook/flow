"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[3972],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>i});var a=t(96540);const s={},l=a.createContext(s);function r(e){const n=a.useContext(l);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(l.Provider,{value:n},e.children)}},33972:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>u});const a=JSON.parse('{"id":"types/tuples","title":"Tuples","description":"Tuple types represent a fixed length list, where the elements can have different types.","source":"@site/docs/types/tuples.md","sourceDirName":"types","slug":"/types/tuples","permalink":"/en/docs/types/tuples","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/types/tuples.md","tags":[],"version":"current","frontMatter":{"title":"Tuples","slug":"/types/tuples"},"sidebar":"docsSidebar","previous":{"title":"Arrays","permalink":"/en/docs/types/arrays"},"next":{"title":"Classes","permalink":"/en/docs/types/classes"}}');var s=t(74848),l=t(28453);const r={title:"Tuples",slug:"/types/tuples"},i=void 0,o={},u=[{value:"Tuple Basics",id:"tuple-basics",level:2},{value:"Strictly enforced tuple length (arity)",id:"toc-strictly-enforced-tuple-length-arity",level:2},{value:"Tuples don&#39;t match array types",id:"toc-tuples-don-t-match-array-types",level:2},{value:"Cannot use mutating array methods on tuples",id:"toc-cannot-use-mutating-array-methods-on-tuples",level:2},{value:"Length refinement",id:"length-refinement",level:2},{value:"Tuple element labels",id:"tuple-element-labels",level:2},{value:"Variance annotations and read-only tuples",id:"variance-annotations-and-read-only-tuples",level:2},{value:"Optional tuple elements",id:"optional-tuple-elements",level:2},{value:"Tuple spread",id:"tuple-spread",level:2},{value:"Inexact tuples",id:"inexact-tuples",level:2},{value:"Adoption",id:"adoption",level:2}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Tuple types represent a ",(0,s.jsx)(n.strong,{children:"fixed length"})," list, where the elements can have ",(0,s.jsx)(n.strong,{children:"different types"}),".\nThis is in contrast to ",(0,s.jsx)(n.a,{href:"../arrays",children:"array types"}),", which have an unknown length and all elements have the same type."]}),"\n",(0,s.jsx)(n.h2,{id:"tuple-basics",children:"Tuple Basics"}),"\n",(0,s.jsx)(n.p,{children:"JavaScript array literal values can be used to create both tuple and array types:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"const arr: Array<number> = [1, 2, 3]; // As an array type\nconst tup: [number, number, number] = [1, 2, 3]; // As a tuple type\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In Flow you can create tuple types using the ",(0,s.jsx)(n.code,{children:"[type1, type2, type3]"})," syntax:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'const tuple1: [number] = [1];\nconst tuple2: [number, boolean] = [1, true];\nconst tuple3: [number, boolean, string] = [1, true, "three"];\n'})}),"\n",(0,s.jsx)(n.p,{children:"When you get a value from a tuple at a specific index, it will return the\ntype at that index:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'const tuple: [number, boolean, string] = [1, true, "three"];\n\nconst num: number = tuple[0]; // Works!\nconst bool: boolean = tuple[1]; // Works!\nconst str: string  = tuple[2]; // Works!\n'})}),"\n",(0,s.jsx)(n.p,{children:"Trying to access an index that does not exist results in an index-out-of-bounds error:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":14,"endLine":3,"endColumn":21,"description":"Cannot get `tuple[3]` because tuple type [1] only has 3 elements, so index 3 is out of bounds. [invalid-tuple-index]"}]',children:'const tuple: [number, boolean, string] = [1, true, "three"];\n\nconst none = tuple[3]; // Error!\n'})}),"\n",(0,s.jsx)(n.p,{children:"If Flow doesn't know which index you are trying to access it will return all\npossible types:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'const tuple: [number, boolean, string] = [1, true, "three"];\n\nfunction getItem(n: number) {\n  const val: number | boolean | string = tuple[n];\n  // ...\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"When setting a new value inside a tuple, the new value must match the type at\nthat index:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":7,"startColumn":12,"endLine":7,"endColumn":16,"description":"Cannot assign `\\"bar\\"` to `tuple[0]` because string [1] is incompatible with number [2]. [incompatible-type]"},{"startLine":8,"startColumn":12,"endLine":8,"endColumn":13,"description":"Cannot assign `42` to `tuple[1]` because number [1] is incompatible with boolean [2]. [incompatible-type]"},{"startLine":9,"startColumn":12,"endLine":9,"endColumn":16,"description":"Cannot assign `false` to `tuple[2]` because boolean [1] is incompatible with string [2]. [incompatible-type]"}]',children:'const tuple: [number, boolean, string] = [1, true, "three"];\n\ntuple[0] = 2;     // Works!\ntuple[1] = false; // Works!\ntuple[2] = "foo"; // Works!\n\ntuple[0] = "bar"; // Error!\ntuple[1] = 42;    // Error!\ntuple[2] = false; // Error!\n'})}),"\n",(0,s.jsx)(n.h2,{id:"toc-strictly-enforced-tuple-length-arity",children:"Strictly enforced tuple length (arity)"}),"\n",(0,s.jsx)(n.p,{children:'The length of the tuple is known as the "arity". The length of a tuple is\nstrictly enforced in Flow.'}),"\n",(0,s.jsx)(n.p,{children:"This means that a shorter tuple can't be used in place of a longer one:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":41,"endLine":3,"endColumn":46,"description":"Cannot assign `tuple1` to `tuple2` because tuple type [1] has 2 elements but tuple type [2] has 3 elements. [invalid-tuple-arity]"}]',children:"const tuple1: [number, boolean] = [1, true];\n\nconst tuple2: [number, boolean, void] = tuple1; // Error!\n"})}),"\n",(0,s.jsx)(n.p,{children:"Also, a longer tuple can't be used in place of a shorter one:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":35,"endLine":3,"endColumn":40,"description":"Cannot assign `tuple1` to `tuple2` because tuple type [1] has 3 elements but tuple type [2] has 2 elements. [invalid-tuple-arity]"}]',children:"const tuple1: [number, boolean, void] = [1, true, undefined];\n\nconst tuple2: [number, boolean] = tuple1; // Error!\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"#optional-tuple-elements",children:"Optional elements"})," make the arity into a range."]}),"\n",(0,s.jsx)(n.h2,{id:"toc-tuples-don-t-match-array-types",children:"Tuples don't match array types"}),"\n",(0,s.jsxs)(n.p,{children:["Since Flow does not know the length of an array, an ",(0,s.jsx)(n.code,{children:"Array<T>"})," type cannot be\npassed into a tuple:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":33,"endLine":3,"endColumn":37,"description":"Cannot assign `array` to `tuple` because array type [1] has an unknown number of elements, so is incompatible with tuple type [2]. [invalid-tuple-arity]"}]',children:"const array: Array<number> = [1, 2];\n\nconst tuple: [number, number] = array; // Error!\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Also a tuple type cannot be passed into to an ",(0,s.jsx)(n.code,{children:"Array<T>"})," type, since then you\ncould mutate the tuple in an unsafe way (for example, ",(0,s.jsx)(n.code,{children:"push"}),"ing a third item onto it):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":30,"endLine":3,"endColumn":34,"description":"Cannot assign `tuple` to `array` because tuple type [1] is incompatible with array type [2]. [incompatible-type]"}]',children:"const tuple: [number, number] = [1, 2];\n\nconst array: Array<number> = tuple; // Error!\n"})}),"\n",(0,s.jsxs)(n.p,{children:["However, you can pass it to a ",(0,s.jsx)(n.a,{href:"../arrays/#toc-readonlyarray",children:(0,s.jsx)(n.code,{children:"$ReadOnlyArray"})})," type, since mutation is disallowed:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"const tuple: [number, number] = [1, 2];\n\nconst array: $ReadOnlyArray<number> = tuple; // Works!\n"})}),"\n",(0,s.jsx)(n.h2,{id:"toc-cannot-use-mutating-array-methods-on-tuples",children:"Cannot use mutating array methods on tuples"}),"\n",(0,s.jsxs)(n.p,{children:["You cannot use ",(0,s.jsx)(n.code,{children:"Array.prototype"})," methods that mutate the tuple, only ones that do not:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":4,"startColumn":7,"endLine":4,"endColumn":10,"description":"Cannot call `tuple.push` because property `push` is missing in `$ReadOnlyArray` [1]. [prop-missing]"}]',children:"const tuple: [number, number] = [1, 2];\ntuple.join(', '); // Works!\n\ntuple.push(3); // Error!\n"})}),"\n",(0,s.jsx)(n.h2,{id:"length-refinement",children:"Length refinement"}),"\n",(0,s.jsxs)(n.p,{children:["You can refine a ",(0,s.jsx)(n.a,{href:"../unions",children:"union"})," of tuples by their length:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type Union = [number, string] | [boolean];\nfunction f(x: Union) {\n  if (x.length === 2) {\n    // `x` is `[number, string]`\n    const n: number = x[0]; // OK\n    const s: string = x[1]; // OK\n  } else {\n    // `x` is `[boolean]`\n    const b: boolean = x[0];\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"tuple-element-labels",children:"Tuple element labels"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:'NOTE: This and the following sections require your tooling to be updated as described in the "Adoption" section at the end of this page.'}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"You can add a label to tuple elements. This label does not affect the type of the tuple element,\nbut is useful in self-documenting the purpose of the tuple elements, especially when multiple elements have the same type."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type Range = [x: number, y: number];\n"})}),"\n",(0,s.jsx)(n.p,{children:"The label is also necessary to add a variance annotation or optionality modifier to an element (as without the label we would have parsing ambiguities)."}),"\n",(0,s.jsx)(n.h2,{id:"variance-annotations-and-read-only-tuples",children:"Variance annotations and read-only tuples"}),"\n",(0,s.jsxs)(n.p,{children:["You can add ",(0,s.jsx)(n.a,{href:"../../lang/variance",children:"variance"}),"  annotations (to denote read-only/write-only) on labeled tuple elements, just like on object properties:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type T = [+foo: number, -bar: string];\n"})}),"\n",(0,s.jsx)(n.p,{children:"This allows you to mark elements as read-only or write-only. For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":3,"endLine":3,"endColumn":18,"description":"Cannot assign `1` to `readOnlyTuple[1]` because tuple element at index `1` [1] labeled `bar` is not writable. [cannot-write]"},{"startLine":3,"startColumn":22,"endLine":3,"endColumn":22,"description":"Cannot assign `1` to `readOnlyTuple[1]` because number [1] is incompatible with string [2]. [incompatible-type]"}]',children:"function f(readOnlyTuple: [+foo: number, +bar: string]) {\n  const n: number = readOnlyTuple[0]; // OK to read\n  readOnlyTuple[1] = 1; // ERROR! Cannot write\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You can also use the ",(0,s.jsx)(n.a,{href:"../utilities/#toc-readonly",children:(0,s.jsx)(n.code,{children:"$ReadOnly"})}),"  on tuple types as a shorthand for marking each property as read-only:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type T = $ReadOnly<[number, string]>; // Same as `[+a: number, +b: string]`\n"})}),"\n",(0,s.jsx)(n.h2,{id:"optional-tuple-elements",children:"Optional tuple elements"}),"\n",(0,s.jsxs)(n.p,{children:["You can mark tuple elements as optional with ",(0,s.jsx)(n.code,{children:"?"})," after an element\u2019s label. This allows you to omit the optional elements.\nOptional elements must be at the end of the tuple type, after all required elements."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'type T = [foo: number, bar?: string];\n[1, "s"] as T; // OK: has all elements\n[1] as T; // OK: skipping optional element\n'})}),"\n",(0,s.jsxs)(n.p,{children:["You cannot write ",(0,s.jsx)(n.code,{children:"undefined"})," to the optional element - add ",(0,s.jsx)(n.code,{children:"| void"})," to the element type if you want to do so:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":8,"endLine":3,"endColumn":16,"description":"Cannot assign `undefined` to `x[0]` because you cannot assign undefined [1] to optional tuple element [2] (to do so, add `| void` to the tuple element type). [incompatible-type]"},{"startLine":4,"startColumn":2,"endLine":4,"endColumn":10,"description":"Cannot cast array literal to `T` because you cannot assign undefined [1] to optional tuple element [2] (to do so, add `| void` to the tuple element type) in index 0. [incompatible-type]"}]',children:"type T = [foo?: number, bar?: number | void];\ndeclare const x: T;\nx[0] = undefined; // ERROR\n[undefined] as T; // ERROR\n\nx[1] = undefined; // OK: we've added `| void` to the element type\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You can also use the ",(0,s.jsx)(n.a,{href:"../utilities/#toc-partial",children:(0,s.jsx)(n.code,{children:"Partial"})})," and ",(0,s.jsx)(n.a,{href:"../utilities/#toc-required",children:(0,s.jsx)(n.code,{children:"Required"})})," utility types to make all elements optional or required respectively:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":5,"startColumn":1,"endLine":5,"endColumn":2,"description":"Cannot cast array literal to required of `AllOptional` because empty array literal [1] has 0 elements but `AllOptional` [2] has 2 elements. [invalid-tuple-arity]"}]',children:"type AllRequired = [number, string];\n[] as Partial<AllRequired>; // OK: like `[a?: number, b?: string]` now\n\ntype AllOptional = [a?: number, b?: string];\n[] as Required<AllOptional>; // ERROR: like `[a: number, b: string]` now\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Tuples with optional elements have an arity (length) that is a range rather than a single number. For example, ",(0,s.jsx)(n.code,{children:"[number, b?: string]"})," has an length of 1-2."]}),"\n",(0,s.jsx)(n.h2,{id:"tuple-spread",children:"Tuple spread"}),"\n",(0,s.jsx)(n.p,{children:"You can spread a tuple type into another tuple type to make a longer tuple type:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'type A = [number, string];\ntype T = [...A, boolean]; // Same as `[number, string, boolean]`\n[1, "s", true] as T; // OK\n'})}),"\n",(0,s.jsx)(n.p,{children:"Tuple spreads preserve labels, variance, and optionality. You cannot spread arrays into tuples, only other tuples."}),"\n",(0,s.jsxs)(n.p,{children:["At the value level, if you spread a tuple with optional elements into an array literal, then you cannot have anything after that spread and retain the tuple view of the array value.\nThat is because a tuple with optional elements has a length that's a range, so we don't know at what index any subsequent values would be at.\nYou can still type this value as the appropriate ",(0,s.jsx)(n.code,{children:"Array<T>"})," type - only the tuple view of the value is affected."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":1,"endLine":3,"endColumn":1,"description":"Cannot cast `b` to tuple type because array literal [1] has an unknown number of elements, so is incompatible with tuple type [2]. [invalid-tuple-arity]"},{"startLine":9,"startColumn":1,"endLine":9,"endColumn":1,"description":"Cannot cast `e` to tuple type because array literal [1] has an unknown number of elements, so is incompatible with tuple type [2]. [invalid-tuple-arity]"},{"startLine":10,"startColumn":1,"endLine":10,"endColumn":1,"description":"Cannot cast `e` to array type because `void | 0 | 1 | 2` [1] is not exactly the same as `number | void` [2] in array element. \\n\\nThe above-mentioned two types must be the same because arrays are invariantly typed. To fix the error,\\n- Either annotate array literal [1] with `Array<number | void>` [3]\\n- Or make array type [3] a `$ReadOnlyArray`.\\nSee https://flow.org/en/docs/faq/#why-cant-i-pass-an-arraystring-to-a-function-that-takes-an-arraystring-number. [incompatible-type]"}]',children:"const a: [foo?: 1] = [];\nconst b = [0, ...a, 2]; // At runtime this is `[0, 2]`\nb as [0, 1 | void, 2]; // ERROR\nb as Array<number | void>; // OK\n\nconst c: [0, foo?: 1] = [0];\nconst d: [bar?: 2] = [2];\nconst e = [...c, ...d]; // At runtime this is `[0, 2]`\ne as [0, foo?: 1, bar?: 2]; // ERROR\ne as Array<number | void>; // OK\n"})}),"\n",(0,s.jsx)(n.h2,{id:"inexact-tuples",children:"Inexact tuples"}),"\n",(0,s.jsxs)(n.p,{children:["Inexact tuple types work like ",(0,s.jsx)(n.a,{href:"../objects#exact-and-inexact-object-types",children:"inexact objects"}),": they allow for unknown members at the end of the tuple."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"[] as [...]; // OK\n[1] as [...]; // OK\n[1] as [number, ...]; // OK\n"})}),"\n",(0,s.jsxs)(n.p,{children:["All tuples are subtypes of the inexact empty tuple ",(0,s.jsx)(n.code,{children:"[...]"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"If you spread an inexact tuple, the result is also inexact.\nYou cannot define elements after the spread of an inexact tuple, since we wouldn't know at what index they should be."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":1,"endLine":3,"endColumn":1,"description":"Cannot cast `y` to tuple type because array literal [1] has 2 or more elements (inexact tuple) but tuple type [2] has 2 elements. [invalid-tuple-arity]"},{"startLine":4,"startColumn":1,"endLine":4,"endColumn":1,"description":"Cannot cast `y` to tuple type because number [1] is incompatible with number literal `0` [2] in index 0. [incompatible-type]"},{"startLine":6,"startColumn":8,"endLine":6,"endColumn":8,"description":"Cannot have element after spread of inexact tuple. [element-after-inexact-tuple-spread]"}]',children:"declare const x: [1, ...];\nconst y = [0, ...x];\ny as [0, 1]; // ERROR: it's inexact\ny as [0, 1, ...]; // OK\n\n[...x, 2]; // ERROR: can't have element after inexact spread\n"})}),"\n",(0,s.jsx)(n.p,{children:"Inexact tuples allow you to require that a generic is a tuple, e.g."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":13,"startColumn":1,"endLine":13,"endColumn":13,"description":"Cannot call `mapTupleArray` because array type [1] has an unknown number of elements, so is incompatible with tuple type [2] in type argument `T`. [invalid-tuple-arity]"}]',children:"function mapTupleArray<T: [...], R>(\n  tuples: Array<T>, // An array of tuples\n  f: (...T) => R, // Function args match the tuple's types\n): Array<R> {\n  return tuples.map(args => f(...args));\n}\nmapTupleArray(\n  [[1, 'hi'], [3, 'bye']],\n  (x: number, y: string) => y.length === x,\n); // OK\n\ndeclare const arrays: Array<Array<number>>;\nmapTupleArray(arrays, (x: number, y: number) => x + y); // ERROR: array is not a tuple\n"})}),"\n",(0,s.jsx)(n.h2,{id:"adoption",children:"Adoption"}),"\n",(0,s.jsx)(n.p,{children:"To use labeled tuple elements (including optional elements and variance annotations on elements) and tuple spread elements,\nyou need to upgrade your infrastructure so that it supports the syntax:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"flow"})," and ",(0,s.jsx)(n.code,{children:"flow-parser"}),": 0.212"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"prettier"}),": 3"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"babel"})," with ",(0,s.jsx)(n.code,{children:"babel-plugin-syntax-hermes-parser"})," (v0.15). See ",(0,s.jsx)(n.a,{href:"../../tools/babel/",children:"our Babel guide"})," for setup instructions."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"eslint"})," with ",(0,s.jsx)(n.code,{children:"hermes-eslint"})," (v0.15). See ",(0,s.jsx)(n.a,{href:"../../tools/eslint/",children:"our ESLint guide"})," for setup instructions."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"To use inexact tuples, upgrade to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"flow"})," and ",(0,s.jsx)(n.code,{children:"flow-parser"}),": 0.243"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"prettier"}),": 3.3"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"babel"})," with ",(0,s.jsx)(n.code,{children:"babel-plugin-syntax-hermes-parser"})," (v0.23). See ",(0,s.jsx)(n.a,{href:"../../tools/babel/",children:"our Babel guide"})," for setup instructions."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"eslint"})," with ",(0,s.jsx)(n.code,{children:"hermes-eslint"})," (v0.23). See ",(0,s.jsx)(n.a,{href:"../../tools/eslint/",children:"our ESLint guide"})," for setup instructions."]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);