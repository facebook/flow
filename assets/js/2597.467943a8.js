"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[2597],{28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var t=s(96540);const i={},r=t.createContext(i);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(r.Provider,{value:n},e.children)}},52597:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>u});const t=JSON.parse('{"id":"types/unions","title":"Unions","description":"Sometimes it\'s useful to create a type which is one of a set of other","source":"@site/docs/types/unions.md","sourceDirName":"types","slug":"/types/unions","permalink":"/en/docs/types/unions","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/types/unions.md","tags":[],"version":"current","frontMatter":{"title":"Unions","slug":"/types/unions"},"sidebar":"docsSidebar","previous":{"title":"Generics","permalink":"/en/docs/types/generics"},"next":{"title":"Intersections","permalink":"/en/docs/types/intersections"}}');var i=s(74848),r=s(28453),o=s(86543);const a={title:"Unions",slug:"/types/unions"},l=void 0,c={},u=[{value:"Union type syntax",id:"toc-union-type-syntax",level:2},{value:"Union shorthands",id:"union-shorthands",level:2},{value:"Unions &amp; Refinements",id:"toc-unions-refinements",level:2},{value:"Union types requires one in, but all out",id:"toc-union-types-requires-one-in-but-all-out",level:2},{value:"Disjoint Object Unions",id:"toc-disjoint-object-unions",level:2},{value:"Disjoint object unions with exact types",id:"toc-disjoint-unions-with-exact-types",level:3},{value:"Disjoint tuple unions",id:"disjoint-tuple-unions",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Sometimes it's useful to create a type which is ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"one of"})})," a set of other\ntypes. For example, you might want to write a function which accepts a set of\nprimitive value types. For this Flow supports ",(0,i.jsx)(n.strong,{children:"union types"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":9,"startColumn":20,"endLine":9,"endColumn":32,"description":"Cannot call `toStringPrimitives` with object literal bound to `value` because: [incompatible-type] Either object literal [1] is incompatible with number [2]. Or object literal [1] is incompatible with boolean [3]. Or object literal [1] is incompatible with string [4]."},{"startLine":10,"startColumn":20,"endLine":10,"endColumn":34,"description":"Cannot call `toStringPrimitives` with array literal bound to `value` because: [incompatible-type] Either array literal [1] is incompatible with number [2]. Or array literal [1] is incompatible with boolean [3]. Or array literal [1] is incompatible with string [4]."}]',children:"function toStringPrimitives(value: number | boolean | string): string {\n  return String(value);\n}\n\ntoStringPrimitives(1);       // Works!\ntoStringPrimitives(true);    // Works!\ntoStringPrimitives('three'); // Works!\n\ntoStringPrimitives({prop: 'val'}); // Error!\ntoStringPrimitives([1, 2, 3, 4, 5]); // Error!\n"})}),"\n",(0,i.jsx)(n.h2,{id:"toc-union-type-syntax",children:"Union type syntax"}),"\n",(0,i.jsxs)(n.p,{children:["Union types are any number of types which are joined by a vertical bar ",(0,i.jsx)(n.code,{children:"|"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"Type1 | Type2 | ... | TypeN\n"})}),"\n",(0,i.jsx)(n.p,{children:"You may also add a leading vertical bar which is useful when breaking union\ntypes onto multiple lines."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"type Foo =\n  | Type1\n  | Type2\n  | ...\n  | TypeN\n"})}),"\n",(0,i.jsx)(n.p,{children:"Each of the members of a union type can be any type, even another union type."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type Numbers = 1 | 2;\ntype Colors = 'red' | 'blue'\n\ntype Fish = Numbers | Colors;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If you have enabled ",(0,i.jsx)(n.a,{href:"../../enums/",children:"Flow Enums"}),", they may be an alternative to unions of ",(0,i.jsx)(n.a,{href:"../literals",children:"literal types"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"union-shorthands",children:"Union shorthands"}),"\n",(0,i.jsxs)(n.p,{children:["The union of some type ",(0,i.jsx)(n.code,{children:"T"})," with ",(0,i.jsx)(n.code,{children:"null"})," or ",(0,i.jsx)(n.code,{children:"void"})," is common, so we provide a shorthand called ",(0,i.jsx)(n.a,{href:"../maybe",children:"maybe types"}),", by using the ",(0,i.jsx)(n.code,{children:"?"})," prefix. The type ",(0,i.jsx)(n.code,{children:"?T"})," is equivalent to ",(0,i.jsx)(n.code,{children:"T | null | void"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function maybeString(x: ?string) { /* ... */ }\nmaybeString('hi'); // Works!\nmaybeString(null); // Works!\nmaybeString(undefined); // Works!\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The union of every single type that exists is the ",(0,i.jsx)(n.a,{href:"../mixed",children:(0,i.jsx)(n.code,{children:"mixed"})})," type:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function everything(x: mixed) { /* ... */ }\neverything(1); // Works!\neverything(true); // Works!\neverything(null); // Works!\neverything({foo: 1}); // Works!\neverything(new Error()); // Works!\n"})}),"\n",(0,i.jsx)(n.h2,{id:"toc-unions-refinements",children:"Unions & Refinements"}),"\n",(0,i.jsxs)(n.p,{children:["When you have a value which is a union type it's often useful to break it apart\nand handle each individual type separately. With union types in Flow you can\n",(0,i.jsx)(n.a,{href:"../../lang/refinements",children:"refine"})," the value down to a single type."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, if we have a value with a union type that is a ",(0,i.jsx)(n.code,{children:"number"}),", a\n",(0,i.jsx)(n.code,{children:"boolean"}),", or a ",(0,i.jsx)(n.code,{children:"string"}),", we can treat the number case separately by using\nJavaScript's ",(0,i.jsx)(n.code,{children:"typeof"})," operator."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function toStringPrimitives(value: number | boolean | string) {\n  if (typeof value === 'number') {\n    return value.toLocaleString([], {maximumSignificantDigits: 3}); // Works!\n  }\n  // ...\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["By checking the ",(0,i.jsx)(n.code,{children:"typeof"})," our value and testing to see if it is a ",(0,i.jsx)(n.code,{children:"number"}),", Flow\nknows that inside of that block it is only a number. We can then write code\nwhich treats our value as a number inside of that block."]}),"\n",(0,i.jsx)(n.h2,{id:"toc-union-types-requires-one-in-but-all-out",children:"Union types requires one in, but all out"}),"\n",(0,i.jsxs)(n.p,{children:["When calling a function that accepts a union type we must pass in ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"one of\nthose types"})}),". But inside of the function we are required to handle ",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"all of\nthe possible types"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Let's rewrite the function to handle each type individually using ",(0,i.jsx)(n.a,{href:"../../lang/refinements",children:"refinements"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function toStringPrimitives(value: number | boolean | string): string {\n  if (typeof value === 'number') {\n    return String(value);\n  } else if (typeof value === 'boolean') {\n    return String(value);\n  }\n  return value; // If we got here, it's a `string`!\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"If we do not handle each possible type of our value, Flow will give us an error:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":5,"startColumn":10,"endLine":5,"endColumn":14,"description":"Cannot return `value` because boolean [1] is incompatible with string [2]. [incompatible-type]"}]',children:"function toStringPrimitives(value: number | boolean | string): string {\n  if (typeof value === 'number') {\n    return String(value);\n  }\n  return value; // Error!\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"toc-disjoint-object-unions",children:"Disjoint Object Unions"}),"\n",(0,i.jsxs)(n.p,{children:['There\'s a special type of union in Flow known as a "disjoint object union" which can\nbe used with ',(0,i.jsx)(n.a,{href:"../../lang/refinements/",children:"refinements"}),". These disjoint object unions are\nmade up of any number of object types which are each tagged by a single property."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, imagine we have a function for handling a response from a server\nafter we've sent it a request. When the request is successful, we'll get back\nan object with a ",(0,i.jsx)(n.code,{children:"type"})," property set to ",(0,i.jsx)(n.code,{children:"'success'"})," and a ",(0,i.jsx)(n.code,{children:"value"})," that we've\nupdated."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"{type: 'success', value: 23}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When the request fails, we'll get back an object with ",(0,i.jsx)(n.code,{children:"type"})," set to ",(0,i.jsx)(n.code,{children:"'error'"}),"\nand an ",(0,i.jsx)(n.code,{children:"error"})," property describing the error."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"{type: 'error', error: 'Bad request'}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We can try to express both of these objects in a single object type. However,\nwe'll quickly run into issues where we know a property exists based on the\n",(0,i.jsx)(n.code,{children:"type"})," property but Flow does not."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":9,"startColumn":27,"endLine":9,"endColumn":40,"description":"Cannot assign `response.value` to `value` because undefined [1] is incompatible with number [2]. [incompatible-type]"},{"startLine":11,"startColumn":27,"endLine":11,"endColumn":40,"description":"Cannot assign `response.error` to `error` because undefined [1] is incompatible with string [2]. [incompatible-type]"}]',children:"type Response = {\n  type: 'success' | 'error',\n  value?: number,\n  error?: string\n};\n\nfunction handleResponse(response: Response) {\n  if (response.type === 'success') {\n    const value: number = response.value; // Error!\n  } else {\n    const error: string = response.error; // Error!\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Trying to combine these two separate types into a single one will only cause us\ntrouble."}),"\n",(0,i.jsxs)(n.p,{children:["Instead, if we create a union type of both object types, Flow will be able to\nknow which object we're using based on the ",(0,i.jsx)(n.code,{children:"type"})," property."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type Response =\n  | {type: 'success', value: number}\n  | {type: 'error', error: string};\n\nfunction handleResponse(response: Response) {\n  if (response.type === 'success') {\n    const value: number = response.value; // Works!\n  } else {\n    const error: string = response.error; // Works!\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In order to use this pattern, there must be a key that is in every object in your union (in our example above, ",(0,i.jsx)(n.code,{children:"type"}),"),\nand every object must set a different ",(0,i.jsx)(n.a,{href:"../literals",children:"literal type"})," for that key (in our example, the string ",(0,i.jsx)(n.code,{children:"'success'"}),", and the string ",(0,i.jsx)(n.code,{children:"'error'"}),").\nYou can use any kind of literal type, including numbers and booleans."]}),"\n",(0,i.jsx)(n.h3,{id:"toc-disjoint-unions-with-exact-types",children:"Disjoint object unions with exact types"}),"\n",(0,i.jsxs)(n.p,{children:["Disjoint unions require you to use a single property to distinguish each object\ntype. You cannot distinguish two different ",(0,i.jsx)(n.a,{href:"../objects/#exact-and-inexact-object-types",children:"inexact objects"})," by different properties."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":6,"startColumn":37,"endLine":6,"endColumn":41,"description":"Cannot get `response.value` because property `value` is missing in `Failed` [1]. [prop-missing]"}]',children:"type Success = {success: true, value: boolean, ...};\ntype Failed  = {error: true, message: string, ...};\n\nfunction handleResponse(response:  Success | Failed) {\n  if (response.success) {\n    const value: boolean = response.value; // Error!\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This is because in Flow it is okay to pass an object value with more properties\nthan the inexact object type expects (because of ",(0,i.jsx)(n.a,{href:"../../lang/width-subtyping/",children:"width subtyping"}),")."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type Success = {success: true, value: boolean, ...};\ntype Failed  = {error: true, message: string, ...};\n\nfunction handleResponse(response:  Success | Failed) {\n  // ...\n}\n\nhandleResponse({\n  success: true,\n  error: true,\n  value: true,\n  message: 'hi'\n});\n"})}),"\n",(0,i.jsx)(n.p,{children:"Unless the objects somehow conflict with one another there is no way to\ndistinguish them."}),"\n",(0,i.jsxs)(n.p,{children:["However, to get around this you could use ",(0,i.jsx)(n.strong,{children:"exact object types"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type Success = {success: true, value: boolean};\ntype Failed  = {error: true, message: string};\n\ntype Response = Success | Failed;\n\nfunction handleResponse(response: Response) {\n  if (response.success) {\n    const value: boolean = response.value;\n  } else {\n    const message: string = response.message;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"With exact object types, we cannot have additional properties, so the objects\nconflict with one another and we are able to distinguish which is which."}),"\n",(0,i.jsx)(n.h2,{id:"disjoint-tuple-unions",children:"Disjoint tuple unions"}),"\n",(0,i.jsxs)(n.p,{children:["Like disjoint object unions explained above, you can also define disjoint tuple unions (support in Flow version ",(0,i.jsx)(o.V,{version:"0.240"}),").\nThese are unions of tuple types, where each tuple is tagged by a particular element. For example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type Response =\n  | ['success', number]\n  | ['error', string];\n\nfunction handleResponse(response: Response) {\n  if (response[0] === 'success') {\n    const value: number = response[1]; // Works!\n  } else {\n    const error: string = response[1]; // Works!\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This feature is particularly useful for function arguments, which are tuples.\nNote the use of ",(0,i.jsx)(n.a,{href:"../tuples/#tuple-element-labels",children:"tuple element labels"})," to make the code more clear."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":16,"startColumn":1,"endLine":16,"endColumn":11,"description":"Cannot call `prettyPrint` because: [incompatible-type] Either string literal `currency` [1] is incompatible with string literal `choice` [2] in index 0. Or rest array [3] has 2 elements but tuple type [4] has 3 elements."},{"startLine":17,"startColumn":1,"endLine":17,"endColumn":11,"description":"Cannot call `prettyPrint` because: [incompatible-type] Either string literal `currency` [1] is incompatible with string literal `choice` [2] in index 0. Or rest array [3] has 2 elements but tuple type [4] has 3 elements."}]',children:"function prettyPrint(\n  ...args: ['currency', dollars: number, cents: number]\n         | ['choice', boolean]\n): string {\n  switch (args[0]) {\n    case 'currency':\n      return args[1] + '.' + args[2];\n    case 'choice':\n      return args[1] ? 'yes' : 'no';\n  }\n}\n// Argument types based on the first arg\nprettyPrint(\"currency\", 1, 50); // OK\nprettyPrint(\"choice\", true); // OK\n\nprettyPrint(\"currency\", 1); // ERROR - missing arg\nprettyPrint(\"currency\", true); // ERROR - wrong type arg\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},86543:(e,n,s)=>{s.d(n,{V:()=>i,v:()=>r});s(96540);var t=s(74848);function i(e){let{version:n}=e;return(0,t.jsxs)("span",{class:"version added",title:`Added in ${n}`,children:["\u2265",n]})}function r(e){let{version:n}=e;return(0,t.jsxs)("span",{class:"version removed",title:`Removed after ${n}`,children:["\u2264",n]})}}}]);