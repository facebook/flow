"use strict";(globalThis.webpackChunknew_website=globalThis.webpackChunknew_website||[]).push([[3],{80003(e,n,s){s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>d,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"lang/lazy-modes","title":"Lazy Mode","description":"By default, the Flow server will typecheck all your code. This way it can answer","source":"@site/docs/lang/lazy-modes.md","sourceDirName":"lang","slug":"/lang/lazy-modes","permalink":"/en/docs/lang/lazy-modes","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/lang/lazy-modes.md","tags":[],"version":"current","frontMatter":{"title":"Lazy Mode","slug":"/lang/lazy-modes"},"sidebar":"docsSidebar","previous":{"title":"Type Refinements","permalink":"/en/docs/lang/refinements"},"next":{"title":"File Signatures (Types-First)","permalink":"/en/docs/lang/types-first"}}');var t=s(74848),i=s(28453);const l={title:"Lazy Mode",slug:"/lang/lazy-modes"},r=void 0,a={},c=[{value:"Classifying Files",id:"toc-classifying-files",level:2},{value:"Choosing Focused Files",id:"toc-choosing-focused-files",level:2},{value:"Using Lazy Mode",id:"toc-using-lazy-mode",level:2},{value:"Forcing Flow to Treat a File as Focused",id:"toc-forcing-flow-to-treat-a-file-as-focused",level:2}];function h(e){const n={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:'By default, the Flow server will typecheck all your code. This way it can answer\nquestions like "are there any Flow errors anywhere in my code". This is very\nuseful for tooling, like a continuous integration hook which prevents code\nchanges which introduce Flow errors.'}),"\n",(0,t.jsxs)(n.p,{children:["However, sometimes a Flow user might not care about all the code. If they are\nediting a file ",(0,t.jsx)(n.code,{children:"foo.js"}),", they might only want Flow to typecheck the subset of\nthe repository needed to answer questions about ",(0,t.jsx)(n.code,{children:"foo.js"}),". Since Flow would only\ncheck a smaller number of files, this would be faster. This is the motivation\nbehind Flow's lazy mode."]}),"\n",(0,t.jsx)(n.h2,{id:"toc-classifying-files",children:"Classifying Files"}),"\n",(0,t.jsx)(n.p,{children:"Lazy mode classifes your code into four categories:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Focused files"}),". These are the files which the user cares about."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dependent files"}),". These are the files which depend on the focused files.\nChanges to the focused files might cause type errors in the dependent files."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dependency files"}),". These are the files which are needed in order to\ntypecheck the focused or dependent files."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unchecked files"}),". All other files."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Lazy mode will still find all the JavaScript files and parse them. But it won't\ntypecheck the unchecked files."}),"\n",(0,t.jsx)(n.h2,{id:"toc-choosing-focused-files",children:"Choosing Focused Files"}),"\n",(0,t.jsx)(n.p,{children:'Flow will focus files when they change on disk, using Flow\'s built-in file watcher\n("dfind") or Watchman.'}),"\n",(0,t.jsx)(n.p,{children:'So, all files that change while Flow is running will be focused. But what about\nfiles that change when Flow is not running? If you\'re using Git or Mercurial,\nFlow will ask it for all of the files that have changed since the mergebase\nwith "master" (the common ancestor of the current commit and the master branch).'}),"\n",(0,t.jsxs)(n.p,{children:['If you\'re not using "master" (e.g. "main" instead), you can change this with\nthe ',(0,t.jsx)(n.code,{children:"file_watcher.mergebase_with"}),' config. If you\'re working from a clone, you\nmight want to set this to "origin/master" (for Git), which will focus all files\nthat have changed locally, even if you commit to your local "master" branch.']}),"\n",(0,t.jsx)(n.p,{children:"The net result is that Flow will find the same errors in lazy mode as in a full\ncheck, so long as there are no errors upstream. For example, if your CI ensures\nthat there are no errors in \"master,\" then it's redundant for Flow to check all\nof the unchanged files for errors that can't exist."}),"\n",(0,t.jsx)(n.h2,{id:"toc-using-lazy-mode",children:"Using Lazy Mode"}),"\n",(0,t.jsxs)(n.p,{children:["To enable lazy mode, set ",(0,t.jsx)(n.code,{children:"lazy_mode=true"})," in the ",(0,t.jsx)(n.code,{children:".flowconfig"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"To start Flow in lazy mode manually, run"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"flow start --lazy-mode true\n"})}),"\n",(0,t.jsx)(n.h2,{id:"toc-forcing-flow-to-treat-a-file-as-focused",children:"Forcing Flow to Treat a File as Focused"}),"\n",(0,t.jsx)(n.p,{children:"You can force Flow to treat one or more files as focused from the CLI."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"flow force-recheck --focus path/to/A.js path/to/B.js\n"})})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},28453(e,n,s){s.d(n,{R:()=>l,x:()=>r});var o=s(96540);const t={},i=o.createContext(t);function l(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);