"use strict";(globalThis.webpackChunknew_website=globalThis.webpackChunknew_website||[]).push([[3664],{3664(e,n,s){s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>p});const t=JSON.parse('{"id":"types/opaque-types","title":"Opaque Type Aliases","description":"Opaque type aliases are type aliases that do not allow access to their","source":"@site/docs/types/opaque-types.md","sourceDirName":"types","slug":"/types/opaque-types","permalink":"/en/docs/types/opaque-types","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/types/opaque-types.md","tags":[],"version":"current","frontMatter":{"title":"Opaque Type Aliases","slug":"/types/opaque-types"},"sidebar":"docsSidebar","previous":{"title":"Type Aliases","permalink":"/en/docs/types/aliases"},"next":{"title":"Interfaces","permalink":"/en/docs/types/interfaces"}}');var i=s(74848),a=s(28453);const r={title:"Opaque Type Aliases",slug:"/types/opaque-types"},l=void 0,o={},p=[{value:"Opaque Type Alias Syntax",id:"toc-opaque-type-alias-syntax",level:2},{value:"Opaque Type Alias Type Checking",id:"toc-opaque-type-alias-type-checking",level:2},{value:"Within the Defining File",id:"toc-within-the-defining-file",level:3},{value:"Outside the Defining File",id:"toc-outside-the-defining-file",level:3},{value:"Subtyping Constraints",id:"toc-subtyping-constraints",level:3},{value:"Generics",id:"toc-generics",level:3},{value:"Library Definitions",id:"toc-library-definitions",level:3}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Opaque type aliases are type aliases that do not allow access to their\nunderlying type outside of the file in which they are defined."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"opaque type ID = string;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Opaque type aliases, like regular type aliases, may be used anywhere a type can\nbe used."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"opaque type ID = string;\n\nfunction identity(x: ID): ID {\n  return x;\n}\nexport type {ID};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"toc-opaque-type-alias-syntax",children:"Opaque Type Alias Syntax"}),"\n",(0,i.jsxs)(n.p,{children:["Opaque type aliases are created using the words ",(0,i.jsx)(n.code,{children:"opaque type"})," followed by its\nname, an equals sign ",(0,i.jsx)(n.code,{children:"="}),", and a type definition."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"opaque type Alias = Type;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can optionally add a subtyping constraint to an opaque type alias by adding\na colon ",(0,i.jsx)(n.code,{children:":"})," and a type after the name."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"opaque type Alias: SuperType = Type;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Any type can appear as the super type or type of an opaque type alias."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"opaque type StringAlias = string;\nopaque type ObjectAlias = {\n  property: string,\n  method(): number,\n};\nopaque type UnionAlias = 1 | 2 | 3;\nopaque type AliasAlias: ObjectAlias = ObjectAlias;\nopaque type VeryOpaque: AliasAlias = ObjectAlias;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"toc-opaque-type-alias-type-checking",children:"Opaque Type Alias Type Checking"}),"\n",(0,i.jsx)(n.h3,{id:"toc-within-the-defining-file",children:"Within the Defining File"}),"\n",(0,i.jsxs)(n.p,{children:["When in the same file the alias is defined, opaque type aliases behave exactly\nas regular ",(0,i.jsx)(n.a,{href:"../aliases/",children:"type aliases"})," do."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"opaque type NumberAlias = number;\n\n0 as NumberAlias;\n\nfunction add(x: NumberAlias, y: NumberAlias): NumberAlias {\n    return x + y;\n}\nfunction toNumberAlias(x: number): NumberAlias { return x; }\nfunction toNumber(x: NumberAlias): number { return x; }\n"})}),"\n",(0,i.jsx)(n.h3,{id:"toc-outside-the-defining-file",children:"Outside the Defining File"}),"\n",(0,i.jsxs)(n.p,{children:["When importing an opaque type alias, it behaves like a\n",(0,i.jsx)(n.a,{href:"../../lang/nominal-structural/#toc-nominal-typing",children:"nominal type"}),", hiding its\nunderlying type."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"exports.js"})})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"export opaque type NumberAlias = number;\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"imports.js"})})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import type {NumberAlias} from './exports';\n\n0 as NumberAlias; // Error: 0 is not a NumberAlias!\n\nfunction convert(x: NumberAlias): number {\n  return x; // Error: x is not a number!\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"toc-subtyping-constraints",children:"Subtyping Constraints"}),"\n",(0,i.jsx)(n.p,{children:"When you add a subtyping constraint to an opaque type alias, we allow the opaque\ntype to be used as the super type when outside of the defining file."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"exports.js"})})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"export opaque type ID: string = string;\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"imports.js"})})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import type {ID} from './exports';\n\nfunction formatID(x: ID): string {\n    return \"ID: \" + x; // Ok! IDs are strings.\n}\n\nfunction toID(x: string): ID {\n    return x; // Error: strings are not IDs.\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"When you create an opaque type alias with a subtyping constraint, the type in\nthe type position must be a subtype of the type in the super type position."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":1,"startColumn":27,"endLine":1,"endColumn":32,"description":"number [1] is incompatible with string [2]. [incompatible-type]"}]',children:"opaque type Bad: string = number; // Error: number is not a subtype of string\nopaque type Good: {x: string, ...} = {x: string, y: number};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"toc-generics",children:"Generics"}),"\n",(0,i.jsxs)(n.p,{children:["Opaque type aliases can also have their own ",(0,i.jsx)(n.a,{href:"../generics/",children:"generics"}),",\nand they work exactly as generics do in regular ",(0,i.jsx)(n.a,{href:"../aliases#toc-type-alias-generics",children:"type aliases"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"opaque type MyObject<A, B, C>: {foo: A, bar: B, ...} = {\n  foo: A,\n  bar: B,\n  baz: C,\n};\n\nvar val: MyObject<number, boolean, string> = {\n  foo: 1,\n  bar: true,\n  baz: 'three',\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"toc-library-definitions",children:"Library Definitions"}),"\n",(0,i.jsxs)(n.p,{children:["You can also declare opaque type aliases in\n",(0,i.jsx)(n.a,{href:"../../libdefs",children:"libdefs"}),". There, you omit the underlying\ntype, but may still optionally include a super type."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"declare opaque type Foo;\ndeclare opaque type PositiveNumber: number;\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453(e,n,s){s.d(n,{R:()=>r,x:()=>l});var t=s(96540);const i={},a=t.createContext(i);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);