"use strict";(globalThis.webpackChunknew_website=globalThis.webpackChunknew_website||[]).push([[7800],{7800(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var r=t(43755),s=t(74848),o=t(28453);const a={title:"Typing Generators with Flow","short-title":"Generators",author:"Sam Goldman",hide_table_of_contents:!0},i=void 0,l={authorsImageUrls:[void 0]},c=[];function d(e){const n={a:"a",code:"code",em:"em",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Flow 0.14.0 included support for generator functions. Generator functions provide a unique ability to JavaScript programs: the ability to suspend and resume execution. This kind of control paves the way for async/await, an ",(0,s.jsx)(n.a,{href:"https://github.com/tc39/ecmascript-asyncawait",children:"upcoming feature"})," already supported by Flow."]}),"\n",(0,s.jsx)(n.p,{children:"So much wonderful material has already been produced describing generators. I am going to focus on the interaction of static typing with generators. Please refer to the following materials for information about generators:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Jafar Husain gave an ",(0,s.jsx)(n.a,{href:"https://www.youtube.com/watch?v=DqMFX91ToLw#t=970",children:"incredibly lucid and well-illustrated talk"})," that covers generators. I have linked to the point where he gets into generators, but I highly recommend the entire talk."]}),"\n",(0,s.jsxs)(n.li,{children:["Exploring ES6, a comprehensive book by Axel Rauschmayer, who has generously made the contents available for free online, has a ",(0,s.jsx)(n.a,{href:"http://exploringjs.com/es6/ch_generators.html",children:"chapter on generators"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The venerable MDN has a ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators",children:"useful page"})," describing the ",(0,s.jsx)(n.code,{children:"Iterator"})," interface and generators."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["In Flow, the ",(0,s.jsx)(n.code,{children:"Generator"})," interface has three type parameters: ",(0,s.jsx)(n.code,{children:"Yield"}),", ",(0,s.jsx)(n.code,{children:"Return"}),", and ",(0,s.jsx)(n.code,{children:"Next"}),". ",(0,s.jsx)(n.code,{children:"Yield"})," is the type of values which are yielded from the generator function. ",(0,s.jsx)(n.code,{children:"Return"})," is the type of the value which is returned from the generator function. ",(0,s.jsx)(n.code,{children:"Next"})," is the type of values which are passed into the generator via the ",(0,s.jsx)(n.code,{children:"next"})," method on the ",(0,s.jsx)(n.code,{children:"Generator"})," itself. For example, a generator value of type ",(0,s.jsx)(n.code,{children:"Generator<string,number,boolean>"})," will yield ",(0,s.jsx)(n.code,{children:"string"}),"s, return a ",(0,s.jsx)(n.code,{children:"number"}),", and will receive ",(0,s.jsx)(n.code,{children:"boolean"}),"s from its caller."]}),"\n",(0,s.jsxs)(n.p,{children:["For any type ",(0,s.jsx)(n.code,{children:"T"}),", a ",(0,s.jsx)(n.code,{children:"Generator<T,void,void>"})," is both an ",(0,s.jsx)(n.code,{children:"Iterable<T>"})," and an ",(0,s.jsx)(n.code,{children:"Iterator<T>"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The unique nature of generators allows us to represent infinite sequences naturally. Consider the infinite sequence of natural numbers:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function *nats() {\n  let i = 0;\n  while (true) {\n    yield i++;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Because generators are also iterators, we can manually iterate the generator:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const gen = nats();\nconsole.log(gen.next()); // { done: false, value: 0 }\nconsole.log(gen.next()); // { done: false, value: 1 }\nconsole.log(gen.next()); // { done: false, value: 2 }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"done"})," is false, ",(0,s.jsx)(n.code,{children:"value"})," will have the generator's ",(0,s.jsx)(n.code,{children:"Yield"})," type. When ",(0,s.jsx)(n.code,{children:"done"})," is true, ",(0,s.jsx)(n.code,{children:"value"})," will have the generator's ",(0,s.jsx)(n.code,{children:"Return"})," type or ",(0,s.jsx)(n.code,{children:"void"})," if the consumer iterates past the completion value."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'function *test() {\n  yield 1;\n  return "complete";\n}\nconst gen = test();\nconsole.log(gen.next()); // { done: false, value: 1 }\nconsole.log(gen.next()); // { done: true, value: "complete" }\nconsole.log(gen.next()); // { done: true, value: undefined }\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Because of this behavior, manually iterating poses typing difficulties. Let's try to take the first 10 values from the ",(0,s.jsx)(n.code,{children:"nats"})," generator through manual iteration:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const gen = nats();\nconst take10: number[] = [];\nfor (let i = 0; i < 10; i++) {\n  const { done, value } = gen.next();\n  if (done) {\n    break;\n  } else {\n    take10.push(value); // error!\n  }\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"test.js:13\n 13:   const { done, value } = gen.next();\n                               ^^^^^^^^^^ call of method `next`\n 17:     take10.push(value); // error!\n                     ^^^^^ undefined. This type is incompatible with\n 11: const take10: number[] = [];\n                   ^^^^^^ number\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Flow is complaining that ",(0,s.jsx)(n.code,{children:"value"})," might be ",(0,s.jsx)(n.code,{children:"undefined"}),". This is because the type of ",(0,s.jsx)(n.code,{children:"value"})," is ",(0,s.jsx)(n.code,{children:"Yield | Return | void"}),", which simplifies in the instance of ",(0,s.jsx)(n.code,{children:"nats"})," to ",(0,s.jsx)(n.code,{children:"number | void"}),". We can introduce a dynamic type test to convince Flow of the invariant that ",(0,s.jsx)(n.code,{children:"value"})," will always be ",(0,s.jsx)(n.code,{children:"number"})," when ",(0,s.jsx)(n.code,{children:"done"})," is false."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const gen = nats();\nconst take10: number[] = [];\nfor (let i = 0; i < 10; i++) {\n  const { done, value } = gen.next();\n  if (done) {\n    break;\n  } else {\n    if (typeof value === "undefined") {\n      throw new Error("`value` must be a number.");\n    }\n    take10.push(value); // no error\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["There is an ",(0,s.jsx)(n.a,{href:"https://github.com/facebook/flow/issues/577",children:"open issue"})," which would make the dynamic type test above unnecessary, by using the ",(0,s.jsx)(n.code,{children:"done"})," value as a sentinel to refine a tagged union. That is, when ",(0,s.jsx)(n.code,{children:"done"})," is ",(0,s.jsx)(n.code,{children:"true"}),", Flow would know that ",(0,s.jsx)(n.code,{children:"value"})," is always of type ",(0,s.jsx)(n.code,{children:"Yield"})," and otherwise of type ",(0,s.jsx)(n.code,{children:"Return | void"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Even without the dynamic type test, this code is quite verbose and it's hard to see the intent. Because generators are also iterable, we can also use ",(0,s.jsx)(n.code,{children:"for...of"})," loops:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const take10: number[] = [];\nlet i = 0;\nfor (let nat of nats()) {\n  if (i === 10) break;\n  take10.push(nat);\n  i++;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["That's much better. The ",(0,s.jsx)(n.code,{children:"for...of"})," looping construct ignores completion values, so Flow understands that ",(0,s.jsx)(n.code,{children:"nat"})," will always be ",(0,s.jsx)(n.code,{children:"number"}),". Let's generalize this pattern further using generator functions:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function *take<T>(n: number, xs: Iterable<T>): Iterable<T> {\n  if (n <= 0) return;\n  let i = 0;\n  for (let x of xs) {\n    yield x;\n    if (++i === n) return;\n  }\n}\n\nfor (let n of take(10, nats())) {\n  console.log(n); // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Note that we explicitly annotated the parameters and return type of the ",(0,s.jsx)(n.code,{children:"take"})," generator. This is necessary to ensure Flow understands the fully generic type. This is because Flow does not currently infer a fully generic type, but instead accumulates lower bounds, resulting in a union type."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'function identity(x) { return x }\nvar a: string = identity(""); // error\nvar b: number = identity(0);  // error\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The above code produces errors because Flow adds ",(0,s.jsx)(n.code,{children:"string"})," and ",(0,s.jsx)(n.code,{children:"number"})," as lower bounds to the type variable describing the type of the value bound by ",(0,s.jsx)(n.code,{children:"x"}),". That is, Flow believes the type of ",(0,s.jsx)(n.code,{children:"identity"})," is ",(0,s.jsx)(n.code,{children:"(x: string | number) => string | number"})," because those are the types which actually passed through the function."]}),"\n",(0,s.jsxs)(n.p,{children:["Another important feature of generators is the ability to pass values into the generator from the consumer. Let's consider a generator ",(0,s.jsx)(n.code,{children:"scan"}),", which reduces values passed into the generator using a provided function. Our ",(0,s.jsx)(n.code,{children:"scan"})," is similar to ",(0,s.jsx)(n.code,{children:"Array.prototype.reduce"}),", but it returns each intermediate value and the values are provided imperatively via ",(0,s.jsx)(n.code,{children:"next"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"As a first pass, we might write this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function *scan<T,U>(init: U, f: (acc: U, x: T) => U): Generator<U,void,T> {\n  let acc = init;\n  while (true) {\n    const next = yield acc;\n    acc = f(acc, next);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"We can use this definition to implement an imperative sum procedure:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let sum = scan(0, (a,b) => a + b);\nconsole.log(sum.next());  // { done: false, value: 0 }\nconsole.log(sum.next(1)); // { done: false, value: 1 }\nconsole.log(sum.next(2)); // { done: false, value: 3 }\nconsole.log(sum.next(3)); // { done: false, value: 6 }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["However, when we try to check the above definition of ",(0,s.jsx)(n.code,{children:"scan"}),", Flow complains:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"test.js:7\n  7:     acc = f(acc, next);\n               ^^^^^^^^^^^^ function call\n  7:     acc = f(acc, next);\n                      ^^^^ undefined. This type is incompatible with\n  3: function *scan<T,U>(init: U, f: (acc: U, x: T) => U): Generator<U,void,T> {\n     ^ some incompatible instantiation of T\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Flow is complaining that our value, ",(0,s.jsx)(n.code,{children:"next"}),", may be ",(0,s.jsx)(n.code,{children:"void"})," instead of the expected ",(0,s.jsx)(n.code,{children:"T"}),", which is ",(0,s.jsx)(n.code,{children:"number"})," in the ",(0,s.jsx)(n.code,{children:"sum"})," example. This behavior is necessary to ensure type safety. In order to prime the generator, our consumer must first call ",(0,s.jsx)(n.code,{children:"next"})," without an argument. To accommodate this, Flow understands the argument to ",(0,s.jsx)(n.code,{children:"next"})," to be optional. This means Flow will allow the following code:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let sum = scan(0, (a,b) => a + b);\nconsole.log(sum.next());  // first call primes the generator\nconsole.log(sum.next());  // we should pass a value, but don't need to\n"})}),"\n",(0,s.jsxs)(n.p,{children:['In general, Flow doesn\'t know which invocation is "first." While it should be an error to pass a value to the first ',(0,s.jsx)(n.code,{children:"next"}),", and an error to ",(0,s.jsx)(n.em,{children:"not"})," pass a value to subsequent ",(0,s.jsx)(n.code,{children:"next"}),"s, Flow compromises and forces your generator to deal with a potentially ",(0,s.jsx)(n.code,{children:"void"})," value. In short, given a generator of type ",(0,s.jsx)(n.code,{children:"Generator<Y,R,N>"})," and a value ",(0,s.jsx)(n.code,{children:"x"})," of type ",(0,s.jsx)(n.code,{children:"Y"}),", the type of the expression ",(0,s.jsx)(n.code,{children:"yield x"})," is ",(0,s.jsx)(n.code,{children:"N | void"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["We can update our definition to use a dynamic type test that enforces the non-",(0,s.jsx)(n.code,{children:"void"})," invariant at runtime:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'function *scan<T,U>(init: U, f: (acc: U, x: T) => U): Generator<U,void,T> {\n  let acc = init;\n  while (true) {\n    const next = yield acc;\n    if (typeof next === "undefined") {\n      throw new Error("Caller must provide an argument to `next`.");\n    }\n    acc = f(acc, next);\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["There is one more important caveat when dealing with typed generators. Every value yielded from the generator must be described by a single type. Similarly, every value passed to the generator via ",(0,s.jsx)(n.code,{children:"next"})," must be described by a single type."]}),"\n",(0,s.jsx)(n.p,{children:"Consider the following generator:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'function *foo() {\n  yield 0;\n  yield "";\n}\n\nconst gen = foo();\nconst a: number = gen.next().value; // error\nconst b: string = gen.next().value; // error\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This is perfectly legal JavaScript and the values ",(0,s.jsx)(n.code,{children:"a"})," and ",(0,s.jsx)(n.code,{children:"b"})," do have the correct types at runtime. However, Flow rejects this program. Our generator's ",(0,s.jsx)(n.code,{children:"Yield"})," type parameter has a concrete type of ",(0,s.jsx)(n.code,{children:"number | string"}),". The ",(0,s.jsx)(n.code,{children:"value"})," property of the iterator result object has the type ",(0,s.jsx)(n.code,{children:"number | string | void"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"We can observe similar behavior for values passed into the generator:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'function *bar() {\n  var a = yield;\n  var b = yield;\n  return {a,b};\n}\n\nconst gen = bar();\ngen.next(); // prime the generator\ngen.next(0);\nconst ret: { a: number, b: string } = gen.next("").value; // error\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The value ",(0,s.jsx)(n.code,{children:"ret"})," has the annotated type at runtime, but Flow also rejects this program. Our generator's ",(0,s.jsx)(n.code,{children:"Next"})," type parameter has a concrete type of ",(0,s.jsx)(n.code,{children:"number | string"}),". The ",(0,s.jsx)(n.code,{children:"value"})," property of the iterator result object thus has the type ",(0,s.jsx)(n.code,{children:"void | { a: void | number | string, b: void | number | string }"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["While it may be possible to use dynamic type tests to resolve these issues, another practical option is to use ",(0,s.jsx)(n.code,{children:"any"})," to take on the type safety responsibility yourself."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'function *bar(): Generator {\n  var a = yield;\n  var b = yield;\n  return {a,b};\n}\n\nconst gen = bar();\ngen.next(); // prime the generator\ngen.next(0);\nconst ret: void | { a: number, b: string } = gen.next("").value; // OK\n'})}),"\n",(0,s.jsxs)(n.p,{children:["(Note that the annotation ",(0,s.jsx)(n.code,{children:"Generator"})," is equivalent to ",(0,s.jsx)(n.code,{children:"Generator<any,any,any>"}),".)"]}),"\n",(0,s.jsx)(n.p,{children:"Phew! I hope that this will help you use generators in your own code. I also hope this gave you a little insight into the difficulties of applying static analysis to a highly dynamic language such as JavaScript."}),"\n",(0,s.jsx)(n.p,{children:"To summarize, here are some of the lessons we've learned for using generators in statically typed JS:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use generators to implement custom iterables."}),"\n",(0,s.jsx)(n.li,{children:"Use dynamic type tests to unpack the optional return type of yield expressions."}),"\n",(0,s.jsxs)(n.li,{children:["Avoid generators that yield or receive values of multiple types, or use ",(0,s.jsx)(n.code,{children:"any"}),"."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453(e,n,t){t.d(n,{R:()=>a,x:()=>i});var r=t(96540);const s={},o=r.createContext(s);function a(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(o.Provider,{value:n},e.children)}},43755(e){e.exports=JSON.parse('{"permalink":"/blog/2015/11/09/Generators","source":"@site/blog/2015-11-09-Generators.md","title":"Typing Generators with Flow","description":"Flow 0.14.0 included support for generator functions. Generator functions provide a unique ability to JavaScript programs: the ability to suspend and resume execution. This kind of control paves the way for async/await, an upcoming feature already supported by Flow.","date":"2015-11-09T00:00:00.000Z","tags":[],"hasTruncateMarker":true,"authors":[{"name":"Sam Goldman","key":null,"page":null}],"frontMatter":{"title":"Typing Generators with Flow","short-title":"Generators","author":"Sam Goldman","hide_table_of_contents":true},"unlisted":false,"prevItem":{"title":"Version-0.19.0","permalink":"/blog/2015/12/01/Version-0.19.0"},"nextItem":{"title":"Version-0.17.0","permalink":"/blog/2015/10/07/Version-0.17.0"}}')}}]);