"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[5142],{5142:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"types/indexed-access","title":"Indexed Access Types","description":"Flow\u2019s Indexed Access Types allow you to get the type of a property from an object, array, or tuple type.","source":"@site/docs/types/indexed-access.md","sourceDirName":"types","slug":"/types/indexed-access","permalink":"/en/docs/types/indexed-access","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/types/indexed-access.md","tags":[],"version":"current","frontMatter":{"title":"Indexed Access Types","slug":"/types/indexed-access"},"sidebar":"docsSidebar","previous":{"title":"Intersections","permalink":"/en/docs/types/intersections"},"next":{"title":"Conditional Types","permalink":"/en/docs/types/conditional"}}');var i=s(74848),r=s(28453);const a={title:"Indexed Access Types",slug:"/types/indexed-access"},o=void 0,c={},l=[{value:"Usage",id:"toc-indexed-access-type-usage",level:2},{value:"Optional Indexed Access Types",id:"toc-optional-indexed-access-types",level:2},{value:"Adoption",id:"toc-adoption",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Flow\u2019s Indexed Access Types allow you to get the type of a property from an ",(0,i.jsx)(n.a,{href:"../objects",children:"object"}),", ",(0,i.jsx)(n.a,{href:"../arrays",children:"array"}),", or ",(0,i.jsx)(n.a,{href:"../tuples",children:"tuple"})," type."]}),"\n",(0,i.jsx)(n.h2,{id:"toc-indexed-access-type-usage",children:"Usage"}),"\n",(0,i.jsx)(n.p,{children:"Access an object type's property:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type Cat = {\n  name: string,\n  age: number,\n  hungry: boolean,\n};\n\ntype Hungry = Cat['hungry']; // type Hungry = boolean\nconst isHungry: Hungry = true; // OK - `Hungry` is an alias for `boolean`\n\n// The index can be a type, not just a literal:\ntype AgeProp = 'age';\ntype Age = Cat[AgeProp]; // type Age = number\nconst catAge: Age = 6; // OK - `Age` is an alias for `number`\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Access an array type's element, by getting the type at the array's indices (which are ",(0,i.jsx)(n.code,{children:"number"}),"s):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type CatNames = Array<string>;\n\ntype CatName = CatNames[number]; // type CatName = string\nconst myCatsName: CatName = 'whiskers'; // OK - `CatName` is an alias for `string`\n"})}),"\n",(0,i.jsx)(n.p,{children:"Access a tuple type's elements:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":5,"startColumn":19,"endLine":5,"endColumn":19,"description":"Cannot access number literal `2` on `Pair` because `Pair` [1] only has 2 elements, so index 2 is out of bounds. [invalid-tuple-index]"}]',children:"type Pair = [string, number];\n\nconst name: Pair[0] = 'whiskers'; // OK - `Pair[0]` is an alias for `string`\nconst age: Pair[1] = 6; // OK - `Pair[1]` is an alias for `number`\nconst wrong: Pair[2] = true; // Error - `Pair` only has two elements\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The index can be a union, including the result of calling ",(0,i.jsx)(n.a,{href:"../utilities/#toc-keys",children:(0,i.jsx)(n.code,{children:"$Keys<...>"})}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type Cat = {\n  name: string,\n  age: number,\n  hungry: boolean,\n};\n\ntype Values = Cat[$Keys<Cat>]; // type Values = string | number | boolean\n"})}),"\n",(0,i.jsx)(n.p,{children:"The index can also be a generic:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":6,"startColumn":19,"endLine":6,"endColumn":39,"description":"Cannot assign `getProp(...)` to `y` because number [1] is incompatible with string [2]. [incompatible-type]"},{"startLine":7,"startColumn":18,"endLine":7,"endColumn":20,"description":"Cannot call `getProp` because property `b` is missing in object literal [1]. [prop-missing]"},{"startLine":7,"startColumn":18,"endLine":7,"endColumn":20,"description":"Cannot call `getProp` because property `b` is missing in object literal [1] in type argument `K`. [prop-missing]"}]',children:"function getProp<O: {+[string]: mixed}, K: $Keys<O>>(o: O, k: K): O[K] {\n  return o[k];\n}\n\nconst x: number = getProp({a: 42}, 'a'); // OK\nconst y: string = getProp({a: 42}, 'a'); // Error - `number` is not a `string`\ngetProp({a: 42}, 'b'); // Error - `b` does not exist in object type\n"})}),"\n",(0,i.jsx)(n.p,{children:"You can nest these accesses:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type Cat = {\n  name: string,\n  age: number,\n  hungry: boolean,\n  personality: {\n    friendly: boolean,\n    hungerLevel: number,\n  }\n};\n\ntype Friendly = Cat['personality']['friendly']; // type Friendly = boolean\nconst isFriendly: Friendly = true; // Pet the cat\n"})}),"\n",(0,i.jsx)(n.h2,{id:"toc-optional-indexed-access-types",children:"Optional Indexed Access Types"}),"\n",(0,i.jsx)(n.p,{children:"Optional Indexed Access Types work like optional chaining. They allow you to access properties from nullable object types.\nIf before you did:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"type T = $ElementType<$NonMaybeType<Obj>, 'prop'> | void;\n"})}),"\n",(0,i.jsx)(n.p,{children:"You can now do:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"type T = Obj?.['prop'];\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Like optional chaining, the resulting types of Optional Indexed Access Types include ",(0,i.jsx)(n.code,{children:"void"}),".\nIf you have a long chain of nested optional accesses, you can wrap the entire thing with a ",(0,i.jsx)(n.code,{children:"$NonMaybeType<...>"})," if you don\u2019t want ",(0,i.jsx)(n.code,{children:"void"})," in your resulting type."]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type TasksContent = ?{\n  tasks?: Array<{\n    items?: {\n      metadata?: {\n        title: string,\n        completed: boolean,\n      },\n    },\n  }>,\n};\n\ntype TaskData = TasksContent?.['tasks']?.[number]?.['items']?.['metadata'];\n"})}),"\n",(0,i.jsxs)(n.p,{children:["There is one small difference between optional chaining and Optional Indexed Access Types.\nIf the object type you access is not nullable, the resulting type in optional chaining will not include ",(0,i.jsx)(n.code,{children:"void"}),".\nWith Optional Indexed Access Types, for implementation reasons, the resulting type will always include ",(0,i.jsx)(n.code,{children:"void"}),".\nHowever, if your object type is not nullable then you don\u2019t need to use an Optional Indexed Access Type, but should just use a regular Indexed Access Type."]}),"\n",(0,i.jsx)(n.h2,{id:"toc-adoption",children:"Adoption"}),"\n",(0,i.jsx)(n.p,{children:"To use Indexed Access Types, you need to upgrade your infrastructure so that it supports the syntax:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"flow"})," and ",(0,i.jsx)(n.code,{children:"flow-parser"}),": 0.155"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"prettier"}),": 2.3.2"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"babel"}),": 7.14"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Indexed Access Types are a replacement for the ",(0,i.jsx)(n.a,{href:"../utilities#toc-propertytype",children:(0,i.jsx)(n.code,{children:"$PropertyType"})})," and ",(0,i.jsx)(n.a,{href:"../utilities#toc-elementtype",children:(0,i.jsx)(n.code,{children:"$ElementType"})})," utility types.\nIf you're familiar with those utility types already, here is a quick conversion guide:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"$PropertyType<Obj, 'prop'>"})," \u2192  ",(0,i.jsx)(n.code,{children:"Obj['prop']"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"$ElementType<Obj, T>"})," \u2192 ",(0,i.jsx)(n.code,{children:"Obj[T]"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"$ElementType<$PropertyType<Obj, 'prop'>, T>"})," \u2192 ",(0,i.jsx)(n.code,{children:"Obj['prop'][T]"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["We have created an ESLint rule that warns on ",(0,i.jsx)(n.code,{children:"$ElementType"})," and ",(0,i.jsx)(n.code,{children:"$PropertyType"})," usage and recommends Indexed Access Types instead.\nIt includes an auto-fixer that can handle most cases. You can simply enable this rule on your codebase and autofix all existing issues."]}),"\n",(0,i.jsxs)(n.p,{children:["Install ",(0,i.jsx)(n.a,{href:"https://www.npmjs.com/package/eslint-plugin-fb-flow",children:(0,i.jsx)(n.code,{children:"eslint-plugin-fb-flow"})}),", and add ",(0,i.jsx)(n.code,{children:"fb-flow"})," to your ESLint plugin list.\nThen enable the rule in your ESLint config:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"'fb-flow/use-indexed-access-type': 1,\n"})})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var t=s(96540);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);