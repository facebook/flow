"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[2594],{7119:e=>{e.exports=JSON.parse('{"permalink":"/blog/2015/02/18/Typecasts","source":"@site/blog/2015-02-18-Typecasts.md","title":"Announcing Typecasts","description":"As of version 0.3.0, Flow supports typecast expression.","date":"2015-02-18T00:00:00.000Z","tags":[],"hasTruncateMarker":true,"authors":[{"name":"Basil Hosmer","key":null,"page":null}],"frontMatter":{"title":"Announcing Typecasts","short-title":"Typecasts","author":"Basil Hosmer","hide_table_of_contents":true},"unlisted":false,"prevItem":{"title":"Announcing Import Type","permalink":"/blog/2015/02/18/Import-Types"}}')},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var t=s(96540);const a={},r=t.createContext(a);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(r.Provider,{value:n},e.children)}},32594:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});var t=s(7119),a=s(74848),r=s(28453);const o={title:"Announcing Typecasts","short-title":"Typecasts",author:"Basil Hosmer",hide_table_of_contents:!0},l=void 0,i={authorsImageUrls:[void 0]},c=[{value:"How Typecasts Work",id:"how-typecasts-work",level:2},{value:"Safety",id:"safety",level:2},{value:"More examples",id:"more-examples",level:2},{value:"Transformations",id:"transformations",level:2}];function p(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"As of version 0.3.0, Flow supports typecast expression."}),"\n",(0,a.jsx)(n.p,{children:"A typecast expression is a simple way to type-annotate any JavaScript expression. Here are some examples of typecasts:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-JavaScript",children:"(1 + 1 : number);\nvar a = { name: (null: ?string) };\n([1, 'a', true]: Array<mixed>).map(fn);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["For any JavaScript expression ",(0,a.jsx)(n.code,{children:"<expr>"})," and any Flow type ",(0,a.jsx)(n.code,{children:"<type>"}),", you can write"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-JavaScript",children:"(<expr> : <type>)\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Note:"})," the parentheses are necessary."]}),"\n",(0,a.jsx)(n.h2,{id:"how-typecasts-work",children:"How Typecasts Work"}),"\n",(0,a.jsxs)(n.p,{children:["To evaluate a typecast expression, Flow will first check that ",(0,a.jsx)(n.code,{children:"<expr>"})," is a ",(0,a.jsx)(n.code,{children:"<type>"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-JavaScript",children:"(1+1: number); // this is fine\n(1+1: string); // but this is is an error\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Second, Flow will infer that the typecast expression ",(0,a.jsx)(n.code,{children:"(<expr>: <type>)"})," has the type ",(0,a.jsx)(n.code,{children:"<type>"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-JavaScript",children:"[(0: ?number)]; // Flow will infer the type Array<?number>\n[0];            // Without the typecast, Flow infers the type Array<number>\n"})}),"\n",(0,a.jsx)(n.h2,{id:"safety",children:"Safety"}),"\n",(0,a.jsxs)(n.p,{children:["Typecasts obey the same rules as other type annotations, so they provide the same safety guarantees. This means they are safe unless you explicitly use the ",(0,a.jsx)(n.code,{children:"any"})," type to defeat Flow's typechecking. Here are examples of upcasting (which is allowed), downcasting (which is forbidden), and using ",(0,a.jsx)(n.code,{children:"any"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-JavaScript",children:"class Base {}\nclass Child extends Base {}\nvar child: Child = new Child();\n\n// Upcast from Child to Base, a more general type: OK\nvar base: Base = new Child();\n\n// Upcast from Child to Base, a more general type: OK\n(child: Base);\n\n// Downcast from Base to Child: unsafe, ERROR\n(base: Child);\n\n// Upcast base to any then downcast any to Child.\n// Unsafe downcasting from any is allowed: OK\n((base: any): Child);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"more-examples",children:"More examples"}),"\n",(0,a.jsx)(n.p,{children:"Typecasts are particularly useful to check assumptions and help Flow infer the types you intend. Here are some examples:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-JavaScript",children:"(x: number) // Make Flow check that x is a number\n(0: ?number) // Tells Flow that this expression is actually nullable.\n(null: ?number) // Tells Flow that this expression is a nullable number.\n"})}),"\n",(0,a.jsx)(n.h2,{id:"transformations",children:"Transformations"}),"\n",(0,a.jsxs)(n.p,{children:["Like type annotations and other Flow features, typecasts need to be transformed away before the code can be run. The transforms will be available in react-tools ",(0,a.jsx)(n.code,{children:"0.13.0"})," when it is published soon, but for now they're available in ",(0,a.jsx)(n.code,{children:"0.13.0-beta.2"}),", which you can install with"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"npm install react-tools@0.13.0-beta.2\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}}}]);