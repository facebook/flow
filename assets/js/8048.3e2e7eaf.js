"use strict";(globalThis.webpackChunknew_website=globalThis.webpackChunknew_website||[]).push([[8048],{8048(e,n,r){r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>y,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"types/arrays","title":"Arrays","description":"Array types represent lists of unknown length, where all items have the same type.","source":"@site/docs/types/arrays.md","sourceDirName":"types","slug":"/types/arrays","permalink":"/en/docs/types/arrays","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/types/arrays.md","tags":[],"version":"current","frontMatter":{"title":"Arrays","slug":"/types/arrays"},"sidebar":"docsSidebar","previous":{"title":"Objects","permalink":"/en/docs/types/objects"},"next":{"title":"Tuples","permalink":"/en/docs/types/tuples"}}');var t=r(74848),s=r(28453),i=r(86543);const o={title:"Arrays",slug:"/types/arrays"},l=void 0,c={},d=[{value:"<code>Array</code> Type",id:"toc-array-type",level:2},{value:"<code>ReadonlyArray&lt;T&gt;</code> <SinceVersion></SinceVersion> (alias <code>$ReadOnlyArray</code>) Type",id:"toc-readonlyarray",level:2},{value:"Empty Array Literals",id:"toc-empty-array-literals",level:2},{value:"Contextual Inference",id:"contextual-inference",level:3},{value:"Initializer Inference",id:"initializer-inference",level:3},{value:"Straight-line Code",id:"straight-line-code",level:4},{value:"Conditional Code",id:"conditional-code",level:4},{value:"Nearer Scope Wins",id:"nearer-scope-wins",level:4},{value:"Array access is unsafe",id:"toc-array-access-is-unsafe",level:2},{value:"Discouraged Array Type Shorthand Syntax",id:"toc-array-type-shorthand-syntax",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["Array types represent lists of ",(0,t.jsx)(n.strong,{children:"unknown length"}),", where all items have the ",(0,t.jsx)(n.strong,{children:"same type"}),".\nThis is in contrast to ",(0,t.jsx)(n.a,{href:"../tuples",children:"tuple types"}),", which have a fixed length and where each element can have a different type."]}),"\n",(0,t.jsx)(n.p,{children:"JavaScript array literal values can be used to create both tuple and array types:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"const arr: Array<number> = [1, 2, 3]; // As an array type\nconst tup: [number, number, number] = [1, 2, 3]; // As a tuple type\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"toc-array-type",children:[(0,t.jsx)(n.code,{children:"Array"})," Type"]}),"\n",(0,t.jsxs)(n.p,{children:["The type ",(0,t.jsx)(n.code,{children:"Array<T>"})," represents an array of items of type ",(0,t.jsx)(n.code,{children:"T"}),".\nFor example, an array of numbers would be ",(0,t.jsx)(n.code,{children:"Array<number>"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"const arr: Array<number> = [1, 2, 3];\n"})}),"\n",(0,t.jsxs)(n.p,{children:["You can put any type within ",(0,t.jsx)(n.code,{children:"Array<T>"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'const arr1: Array<boolean> = [true, false, true];\nconst arr2: Array<string> = ["A", "B", "C"];\nconst arr3: Array<unknown> = [1, true, "three"];\n'})}),"\n",(0,t.jsxs)(n.h2,{id:"toc-readonlyarray",children:[(0,t.jsx)(n.code,{children:"ReadonlyArray<T>"})," ",(0,t.jsx)(i.V,{version:"0.290"})," (alias ",(0,t.jsx)(n.code,{children:"$ReadOnlyArray"}),") Type"]}),"\n",(0,t.jsxs)(n.p,{children:["You can use the type ",(0,t.jsx)(n.code,{children:"ReadonlyArray<T>"})," instead of ",(0,t.jsx)(n.code,{children:"Array<T>"})," to represent a ",(0,t.jsx)(n.a,{href:"../../lang/variance",children:"read-only"})," array which cannot be mutated.\nYou can't write to a read-only array directly, and can't use methods which mutate the array like ",(0,t.jsx)(n.code,{children:".push()"}),", ",(0,t.jsx)(n.code,{children:".unshift()"}),", etc."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":4,"startColumn":1,"endLine":4,"endColumn":16,"description":"Cannot assign `20` to `readonlyArray[1]` because read-only arrays cannot be written to. [cannot-write]"},{"startLine":5,"startColumn":15,"endLine":5,"endColumn":18,"description":"Cannot call `readonlyArray.push` because property `push` is missing in `$ReadOnlyArray` [1]. [prop-missing]"},{"startLine":6,"startColumn":15,"endLine":6,"endColumn":21,"description":"Cannot call `readonlyArray.unshift` because property `unshift` is missing in `$ReadOnlyArray` [1]. [prop-missing]"}]',children:"const readonlyArray: ReadonlyArray<number> = [1, 2, 3]\n\nconst first = readonlyArray[0]; // OK to read\nreadonlyArray[1] = 20;          // Error!\nreadonlyArray.push(4);          // Error!\nreadonlyArray.unshift(4);       // Error!\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Note that an array of type ",(0,t.jsx)(n.code,{children:"ReadonlyArray<T>"})," can still have mutable ",(0,t.jsx)(n.em,{children:"elements"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":2,"startColumn":1,"endLine":2,"endColumn":16,"description":"Cannot assign object literal to `readonlyArray[0]` because read-only arrays cannot be written to. [cannot-write]"}]',children:"const readonlyArray: ReadonlyArray<{x: number}> = [{x: 1}];\nreadonlyArray[0] = {x: 42}; // Error!\nreadonlyArray[0].x = 42; // Works\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The main advantage to using ",(0,t.jsx)(n.code,{children:"ReadonlyArray"})," instead of ",(0,t.jsx)(n.code,{children:"Array"})," is that ",(0,t.jsx)(n.code,{children:"ReadonlyArray"}),"'s\ntype parameter is ",(0,t.jsx)(n.a,{href:"../../lang/variance/#toc-covariance",children:(0,t.jsx)(n.em,{children:"covariant"})}),"\nwhile ",(0,t.jsx)(n.code,{children:"Array"}),"'s type parameter is ",(0,t.jsx)(n.a,{href:"../../lang/variance/#toc-invariance",children:(0,t.jsx)(n.em,{children:"invariant"})}),".\nThat means that ",(0,t.jsx)(n.code,{children:"ReadonlyArray<number>"})," is a subtype of ",(0,t.jsx)(n.code,{children:"ReadonlyArray<number | string>"})," while\n",(0,t.jsx)(n.code,{children:"Array<number>"})," is NOT a subtype of ",(0,t.jsx)(n.code,{children:"Array<number | string>"}),". So it's often useful to use\n",(0,t.jsx)(n.code,{children:"ReadonlyArray"})," in type annotations for arrays of various types of elements.\nTake, for instance, the following scenario:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":6,"startColumn":15,"endLine":6,"endColumn":19,"description":"Cannot call `someOperation` with `array` bound to `arr` because in array element: `number` [1] is not exactly the same as `number | string` [2]. [incompatible-type] \\nThe above-mentioned two types must be the same because arrays are invariantly typed. To fix the error,\\n- Either make `Array<number>` [3] and `Array<number | string>` [4] exactly the same\\n- Or make array type [4] a `ReadonlyArray`.\\nSee https://flow.org/en/docs/faq/#why-cant-i-pass-an-arraystring-to-a-function-that-takes-an-arraystring-number."}]',children:"const someOperation = (arr: Array<number | string>) => {\n  // Here we could do `arr.push('a string')`\n}\n\nconst array: Array<number> = [1];\nsomeOperation(array) // Error!\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Since the parameter ",(0,t.jsx)(n.code,{children:"arr"})," of the ",(0,t.jsx)(n.code,{children:"someOperation"})," function is typed as a mutable\n",(0,t.jsx)(n.code,{children:"Array"}),", pushing a string into it would be possible inside that scope, which\nwould then break the type contract of the outside ",(0,t.jsx)(n.code,{children:"array"})," variable. By\nannotating the parameter as ",(0,t.jsx)(n.code,{children:"ReadonlyArray"})," instead in this case, Flow can be\nsure this won't happen and no errors will occur:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"const someOperation = (arr: ReadonlyArray<number | string>) => {\n  // Nothing can be added to `arr`\n}\n\nconst array: Array<number> = [1];\nsomeOperation(array); // Works\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"ReadonlyArray<unknown>"})," represents the supertype of all arrays and all ",(0,t.jsx)(n.a,{href:"../tuples",children:"tuples"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"const tup: [number, string] = [1, 'hi'];\nconst arr: Array<number> = [1, 2];\n\nfunction f(xs: ReadonlyArray<unknown>) { /* ... */ }\n\nf(tup); // Works\nf(arr); // Works\n"})}),"\n",(0,t.jsx)(n.h2,{id:"toc-empty-array-literals",children:"Empty Array Literals"}),"\n",(0,t.jsxs)(n.p,{children:["Empty array literals (",(0,t.jsx)(n.code,{children:"[]"}),") are handled specially in Flow when it comes to their ",(0,t.jsx)(n.a,{href:"../../lang/annotation-requirement",children:"annotation requirements"}),".\nWhat makes them special is that they do not contain enough information to\ndetermine their type, and at the same time they are too common to always\nrequire type annotations in their immediate context."]}),"\n",(0,t.jsx)(n.p,{children:"So, to type empty arrays Flow follows these rules:"}),"\n",(0,t.jsx)(n.h3,{id:"contextual-inference",children:"Contextual Inference"}),"\n",(0,t.jsxs)(n.p,{children:["First, if ",(0,t.jsx)(n.a,{href:"../../lang/annotation-requirement/#toc-contextual-typing",children:"contextual information"})," exists,\nwe'll use it to determine the array element type:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"function takesStringArray(x: Array<string>): void {}\n\nconst arr1: Array<string> = [];\ntakesStringArray([]);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In both cases, the ",(0,t.jsx)(n.code,{children:"[]"})," will be typed as an ",(0,t.jsx)(n.code,{children:"Array<string>"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Note that for the contextual information to work, the type needs to be available\nright at the definition of the array. This means that the last two lines in the following\ncode will error:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":7,"endLine":3,"endColumn":10,"description":"Cannot determine type of empty array literal. Please provide an annotation. [missing-empty-array-annot]"},{"startLine":4,"startColumn":18,"endLine":4,"endColumn":21,"description":"Cannot call `takesStringArray` with `arr2` bound to `x` because in array element: `empty` [1] is not exactly the same as `string` [2]. [incompatible-type] \\nThe above-mentioned two types must be the same because arrays are invariantly typed. To fix the error,\\n- Either make `Array<empty>` [1] and `Array<string>` [3] exactly the same\\n- Or make array type [3] a `ReadonlyArray`.\\nSee https://flow.org/en/docs/faq/#why-cant-i-pass-an-arraystring-to-a-function-that-takes-an-arraystring-number."}]',children:"function takesStringArray(x: Array<string>): void {}\n\nconst arr2 = [];\ntakesStringArray(arr2);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The second error is due to ",(0,t.jsx)(n.code,{children:"arr2"})," being inferred as ",(0,t.jsx)(n.code,{children:"Array<empty>"})," which leads to another error at the call\nto ",(0,t.jsx)(n.code,{children:"takesStringArray"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"initializer-inference",children:"Initializer Inference"}),"\n",(0,t.jsx)(n.p,{children:"Flow allows another way to determine the types of empty arrays when they are immediately assigned to a variable:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const arr3 = [];\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The way it does this is reminiscent of the typing of\n",(0,t.jsx)(n.a,{href:"../../lang/variables/#toc-variables-declared-without-initializers",children:"variables without initializers"}),':\nFlow tries to choose the "first" ',(0,t.jsx)(n.em,{children:"assignment"})," or ",(0,t.jsx)(n.em,{children:"assignments"}),"\nto the variable to define its type. In the case of empty arrays, an assignment is either"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["an indexed write statement ",(0,t.jsx)(n.code,{children:"a[i] = e;"}),", or"]}),"\n",(0,t.jsxs)(n.li,{children:["an array ",(0,t.jsx)(n.code,{children:"push"})," call ",(0,t.jsx)(n.code,{children:"a.push(e)"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["In either case the type of ",(0,t.jsx)(n.code,{children:"e"})," is used as the type of the array element."]}),"\n",(0,t.jsx)(n.p,{children:"Here are some examples:"}),"\n",(0,t.jsx)(n.h4,{id:"straight-line-code",children:"Straight-line Code"}),"\n",(0,t.jsx)(n.p,{children:"Once the first assignment has been found, the type of the array element is pinned to that of the\nassigned expression. Subsequent writes to array with elements of\na different type are errors:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":11,"endLine":3,"endColumn":15,"description":"Cannot call `arr3.push` because in array element: string [1] is incompatible with number [2]. [incompatible-type]"}]',children:'const arr3 = [];\narr3.push(42); // arr3 is inferred as Array<number>\narr3.push("abc"); // Error!\n'})}),"\n",(0,t.jsx)(n.h4,{id:"conditional-code",children:"Conditional Code"}),"\n",(0,t.jsx)(n.p,{children:"If the array is assigned in sibling branches of conditional statements, the type\nof the array element is pinned to the union of the assigned types:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":11,"startColumn":11,"endLine":11,"endColumn":14,"description":"Cannot assign `true` to `arr4[0]` because: [incompatible-type] Either boolean [1] is incompatible with number [2]. Or boolean [1] is incompatible with string [3]."}]',children:'declare const cond: boolean;\n\nconst arr4 = [];\nif (cond) {\n  arr4[0] = 42;\n} else {\n  arr4.push("abc");\n}\n// arr4 is inferred as Array<number | string>\narr4.push("def"); // Works\narr4[0] = true; // Error!\n'})}),"\n",(0,t.jsx)(n.h4,{id:"nearer-scope-wins",children:"Nearer Scope Wins"}),"\n",(0,t.jsx)(n.p,{children:"Shallow scope of assignment is preferred when there are multiple scopes where assignments happen:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":13,"endLine":3,"endColumn":14,"description":"Cannot call `arr5.push` because in array element: number [1] is incompatible with string [2]. [incompatible-type]"},{"startLine":7,"startColumn":11,"endLine":7,"endColumn":11,"description":"Cannot call `arr5.push` because in array element: number [1] is incompatible with string [2]. [incompatible-type]"}]',children:'const arr5 = [];\nfunction f() {\n  arr5.push(42); // Error!\n}\nf();\narr5.push("abc"); // This assignment wins. arr5 is inferred as Array<string>\narr5.push(1); // Error!\n'})}),"\n",(0,t.jsx)(n.h2,{id:"toc-array-access-is-unsafe",children:"Array access is unsafe"}),"\n",(0,t.jsxs)(n.p,{children:["When you retrieve an element from an array there is always a possibility that\nit is ",(0,t.jsx)(n.code,{children:"undefined"}),'. You could have either accessed an index which is out of the\nbounds of the array, or the element could not exist because it is a "sparse\narray".']}),"\n",(0,t.jsx)(n.p,{children:"For example, you could be accessing an element that is out of the bounds of the\narray:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"const array: Array<number> = [0, 1, 2];\nconst value: number = array[3]; // Works\n                         // ^ undefined\n"})}),"\n",(0,t.jsx)(n.p,{children:'Or you could be accessing an element that does not exist if it is a "sparse array":'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"const array: Array<number> = [];\n\narray[0] = 0;\narray[2] = 2;\n\nconst value: number = array[1]; // Works\n                         // ^ undefined\n"})}),"\n",(0,t.jsxs)(n.p,{children:['In order to make this safe, Flow would have to mark every single array access\nas "',(0,t.jsx)(n.em,{children:'possibly undefined"'}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Flow does not do this because it would be extremely inconvenient to use. You\nwould be forced to refine the type of every value you get when accessing an\narray."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"const array: Array<number> = [0, 1, 2];\nconst value: number | void = array[1];\n\nif (value !== undefined) {\n  // number\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"toc-array-type-shorthand-syntax",children:"Discouraged Array Type Shorthand Syntax"}),"\n",(0,t.jsxs)(n.p,{children:["There is an alternative to the ",(0,t.jsx)(n.code,{children:"Array<T>"})," syntax: ",(0,t.jsx)(n.code,{children:"T[]"}),".\nThis syntax is discouraged and may be deprecated in the future."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"const arr: number[] = [0, 1, 2, 3];\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Just note that ",(0,t.jsx)(n.code,{children:"?Type[]"})," is the equivalent of ",(0,t.jsx)(n.code,{children:"?Array<T>"})," and not ",(0,t.jsx)(n.code,{children:"Array<?T>"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":26,"endLine":3,"endColumn":29,"description":"Cannot assign array literal to `arr3` because in array element: null [1] is incompatible with number [2]. [incompatible-type]"}]',children:"const arr1: ?number[] = null;   // Works\nconst arr2: ?number[] = [1, 2]; // Works\nconst arr3: ?number[] = [null]; // Error!\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If you want to make it ",(0,t.jsx)(n.code,{children:"Array<?T>"})," you can use parenthesis like: ",(0,t.jsx)(n.code,{children:"(?Type)[]"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":1,"startColumn":27,"endLine":1,"endColumn":30,"description":"Cannot assign `null` to `arr1` because null [1] is incompatible with array type [2]. [incompatible-type]"}]',children:"const arr1: (?number)[] = null;   // Error!\nconst arr2: (?number)[] = [1, 2]; // Works\nconst arr3: (?number)[] = [null]; // Works\n"})})]})}function y(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},86543(e,n,r){r.d(n,{V:()=>t,v:()=>s});r(96540);var a=r(74848);function t(e){let{version:n}=e;return(0,a.jsxs)("span",{class:"version added",title:`Added in ${n}`,children:["\u2265",n]})}function s(e){let{version:n}=e;return(0,a.jsxs)("span",{class:"version removed",title:`Removed after ${n}`,children:["\u2264",n]})}},28453(e,n,r){r.d(n,{R:()=>i,x:()=>o});var a=r(96540);const t={},s=a.createContext(t);function i(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);