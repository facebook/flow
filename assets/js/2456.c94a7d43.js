"use strict";(globalThis.webpackChunknew_website=globalThis.webpackChunknew_website||[]).push([[2456],{82456(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var o=t(72599),i=t(74848),s=t(28453);const a={title:"New Implementation of Unions and Intersections","short-title":"New Unions and Intersections",author:"Sam Goldman",hide_table_of_contents:!0},r=void 0,c={authorsImageUrls:[void 0]},l=[{value:"Summary",id:"summary",level:3},{value:"New Error Messages",id:"new-error-messages",level:3},{value:"Actions Needed",id:"actions-needed",level:3},{value:"Problem",id:"problem",level:3},{value:"Solution",id:"solution",level:3}];function h(e){const n={a:"a",code:"code",em:"em",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h3,{id:"summary",children:"Summary"}),"\n",(0,i.jsxs)(n.p,{children:["Before Flow 0.28, the implementation of union/intersection types had serious\nbugs and was ",(0,i.jsx)(n.a,{href:"https://github.com/facebook/flow/issues/1759",children:"the"})," ",(0,i.jsx)(n.a,{href:"https://github.com/facebook/flow/issues/1664",children:"root"})," ",(0,i.jsx)(n.a,{href:"https://github.com/facebook/flow/issues/1663",children:"cause"})," ",(0,i.jsx)(n.a,{href:"https://github.com/facebook/flow/issues/1462",children:"of"}),"\n",(0,i.jsx)(n.a,{href:"https://github.com/facebook/flow/issues/1455",children:"a"})," ",(0,i.jsx)(n.a,{href:"https://github.com/facebook/flow/issues/1371",children:"lot"})," ",(0,i.jsx)(n.a,{href:"https://github.com/facebook/flow/issues/1349",children:"of"})," ",(0,i.jsx)(n.a,{href:"https://github.com/facebook/flow/issues/824",children:"weird"})," ",(0,i.jsx)(n.a,{href:"https://github.com/facebook/flow/issues/815",children:"behaviors"})," you\nmay have run into with Flow in the past. These bugs have now been addressed in\n",(0,i.jsx)(n.a,{href:"https://github.com/facebook/flow/commit/2df7671e7bda770b95e6b1eaede96d7a8ab1f2ac",children:"a diff landing in 0.28"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"As you might expect after a major rewrite of a tricky part of the type system\nimplementation, there will be a short period of adjustment: you may run into\nkinks that we will try to iron out promptly, and you may run into some\nunfamiliar error messages."}),"\n",(0,i.jsx)(n.h3,{id:"new-error-messages",children:"New Error Messages"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"<error location> Could not decide which case to select\n<location of union/intersection type>\n\n  Case 1 may work:\n  <location of 1st case of union/intersection type>\n\n  But if it doesn't, case 2 looks promising too:\n  <location of 2nd case of union/intersection type>\n\n  Please provide additional annotation(s) to determine whether case 1 works\n  (or consider merging it with case 2):\n  <location to annotate>\n  <location to annotate>\n  ...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["What this means is that at ",(0,i.jsx)(n.code,{children:"<error location>"}),", Flow needs to make a choice: one\nof the members of the union/intersection type at\n",(0,i.jsx)(n.code,{children:"<location of union/intersection type>"})," must be applied, but Flow can't choose\nsafely based on available information. In particular, it cannot decide between\ncase ",(0,i.jsx)(n.code,{children:"1"})," and ",(0,i.jsx)(n.code,{children:"2"}),", so Flow lists a bunch of annotations that can help it\ndisambiguate the two cases."]}),"\n",(0,i.jsx)(n.h3,{id:"actions-needed",children:"Actions Needed"}),"\n",(0,i.jsx)(n.p,{children:"You can fix the errors in two ways:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Actually go and annotate the listed locations. This should be by far the most\ncommon fix."}),"\n",(0,i.jsx)(n.li,{children:"Discover that there is real, unintentional ambiguity between case 1 and 2,\nand rewrite the two cases in the union type to remove the ambiguity. When\nthis happens, typically it will fix a large number of errors."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"There are two more possibilities, however:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"There's no real ambiguity and Flow is being too conservative / dumb. In this\ncase, go ahead and do the annotations anyway and file an issue on GitHub. We\nplan to do a lot of short-term follow-up work to disambiguate more cases\nautomatically, so over time you should see less of (3)."}),"\n",(0,i.jsxs)(n.li,{children:["You have no idea what's going on. The cases being pointed to don't make sense.\nThey don't correspond to what you have at ",(0,i.jsx)(n.code,{children:"<error location>"}),". Hopefully you\nwon't run into (4) too often, but if you do ",(0,i.jsx)(n.strong,{children:"please file an issue"}),", since\nthis means there are still latent bugs in the implementation."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["If you file an issue on GitHub, please include code to reproduce the issue. You\ncan use ",(0,i.jsx)(n.a,{href:"https://flowtype.org/try/",children:"Try Flow"})," to share your repro case easily."]}),"\n",(0,i.jsx)(n.p,{children:"If you're curious about the whys and hows of these new error messages, here's\nan excerpt from the commit message of the \"fate of the union\" diff:"}),"\n",(0,i.jsx)(n.h3,{id:"problem",children:"Problem"}),"\n",(0,i.jsx)(n.p,{children:"Flow's inference engine is designed to find more errors over time as\nconstraints are added...but it is not designed to backtrack. Unfortunately,\nchecking the type of an expression against a union type does need backtracking:\nif some branch of the union doesn't work out, the next branch must be tried,\nand so on. (The same is true for checks that involve intersection types.)"}),"\n",(0,i.jsx)(n.p,{children:"The situation is further complicated by the fact that the type of the\nexpression may not be completely known at the point of checking, so that a\nbranch that looks promising now might turn out to be incorrect later."}),"\n",(0,i.jsx)(n.h3,{id:"solution",children:"Solution"}),"\n",(0,i.jsxs)(n.p,{children:["The basic idea is to delay trying a branch until a point where we can decide\nwhether the branch will definitely fail or succeed, without further\ninformation. If trying a branch results in failure, we can move on to the next\nbranch without needing to backtrack. If a branch succeeds, we are done. The\nfinal case is where the branch looks promising, but we cannot be sure without\nadding constraints: in this case we try other branches, and ",(0,i.jsx)(n.em,{children:"bail"})," when we run\ninto ambiguities...requesting additional annotations to decide which branch to\nselect. Overall, this means that (1) we never commit to a branch that might\nturn out to be incorrect and (2) can always select a correct branch (if such\nexists) given enough annotations."]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453(e,n,t){t.d(n,{R:()=>a,x:()=>r});var o=t(96540);const i={},s=o.createContext(i);function a(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(s.Provider,{value:n},e.children)}},72599(e){e.exports=JSON.parse('{"permalink":"/blog/2016/07/01/New-Unions-Intersections","source":"@site/blog/2016-07-01-New-Unions-Intersections.md","title":"New Implementation of Unions and Intersections","description":"Summary","date":"2016-07-01T00:00:00.000Z","tags":[],"hasTruncateMarker":true,"authors":[{"name":"Sam Goldman","key":null,"page":null}],"frontMatter":{"title":"New Implementation of Unions and Intersections","short-title":"New Unions and Intersections","author":"Sam Goldman","hide_table_of_contents":true},"unlisted":false,"prevItem":{"title":"Windows Support is Here!","permalink":"/blog/2016/08/01/Windows-Support"},"nextItem":{"title":"Version 0.21.0","permalink":"/blog/2016/02/02/Version-0.21.0"}}')}}]);