"use strict";(globalThis.webpackChunknew_website=globalThis.webpackChunknew_website||[]).push([[3879],{33879(e,n,t){t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"lang/subtypes","title":"Subsets & Subtypes","description":"What is a subtype?","source":"@site/docs/lang/subtypes.md","sourceDirName":"lang","slug":"/lang/subtypes","permalink":"/en/docs/lang/subtypes","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/lang/subtypes.md","tags":[],"version":"current","frontMatter":{"title":"Subsets & Subtypes","slug":"/lang/subtypes"},"sidebar":"docsSidebar","previous":{"title":"Variable Declarations","permalink":"/en/docs/lang/variables"},"next":{"title":"Type Hierarchy","permalink":"/en/docs/lang/type-hierarchy"}}');var o=t(74848),c=t(28453);const i={title:"Subsets & Subtypes",slug:"/lang/subtypes"},a=void 0,r={},l=[{value:"What is a subtype?",id:"toc-what-is-a-subtype",level:2},{value:"When are subtypes used?",id:"toc-when-are-subtypes-used",level:2},{value:"Subtypes of complex types",id:"toc-subtypes-of-complex-types",level:2},{value:"Subtypes of objects",id:"toc-subtypes-of-objects",level:3},{value:"Subtypes of functions",id:"toc-subtypes-of-functions",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,c.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"toc-what-is-a-subtype",children:"What is a subtype?"}),"\n",(0,o.jsxs)(n.p,{children:["A type like ",(0,o.jsx)(n.code,{children:"number"}),", ",(0,o.jsx)(n.code,{children:"boolean"}),", or ",(0,o.jsx)(n.code,{children:"string"})," describes a set of possible\nvalues. A ",(0,o.jsx)(n.code,{children:"number"})," describes every possible number, so a single number\n(such as ",(0,o.jsx)(n.code,{children:"42"}),") would be a ",(0,o.jsx)(n.em,{children:"subtype"})," of the ",(0,o.jsx)(n.code,{children:"number"})," type. Conversely, ",(0,o.jsx)(n.code,{children:"number"}),"\nwould be a ",(0,o.jsx)(n.em,{children:"supertype"})," of the type ",(0,o.jsx)(n.code,{children:"42"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["If we want to know whether one type is the subtype of another, we need to look at\nall the possible values for both types and figure out if the other has a\n",(0,o.jsx)(n.em,{children:"subset"})," of the values."]}),"\n",(0,o.jsxs)(n.p,{children:["For example, if we had a ",(0,o.jsx)(n.code,{children:"TypeA"})," which described the numbers 1 through 3\n(a ",(0,o.jsx)(n.a,{href:"../../types/unions",children:"union"})," of ",(0,o.jsx)(n.a,{href:"../../types/literals",children:"literal types"}),"), and\na ",(0,o.jsx)(n.code,{children:"TypeB"})," which described the numbers 1 through 5: ",(0,o.jsx)(n.code,{children:"TypeA"})," would be considered\na ",(0,o.jsx)(n.em,{children:"subtype"})," of ",(0,o.jsx)(n.code,{children:"TypeB"}),", because ",(0,o.jsx)(n.code,{children:"TypeA"})," is a subset of ",(0,o.jsx)(n.code,{children:"TypeB"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type TypeA = 1 | 2 | 3;\ntype TypeB = 1 | 2 | 3 | 4 | 5;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Consider a ",(0,o.jsx)(n.code,{children:"TypeLetters"}),' which described the strings: "A", "B", "C", and a\n',(0,o.jsx)(n.code,{children:"TypeNumbers"})," which described the numbers: 1, 2, 3. Neither of them would\nbe a subtype of the other, as they each contain a completely different set of\nvalues."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'type TypeLetters = "A" | "B" | "C";\ntype TypeNumbers =  1  |  2  |  3;\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Finally, if we had a ",(0,o.jsx)(n.code,{children:"TypeA"})," which described the numbers 1 through 3, and a\n",(0,o.jsx)(n.code,{children:"TypeB"})," which described the numbers 3 through 5. Neither of them would be a\nsubtype of the other. Even though they both have 3 and describe numbers, they\neach have some unique items."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type TypeA = 1 | 2 | 3;\ntype TypeB = 3 | 4 | 5;\n"})}),"\n",(0,o.jsx)(n.h2,{id:"toc-when-are-subtypes-used",children:"When are subtypes used?"}),"\n",(0,o.jsx)(n.p,{children:"Most of the work that Flow does is comparing types against one another."}),"\n",(0,o.jsx)(n.p,{children:"For example, in order to know if you are calling a function correctly, Flow\nneeds to compare the arguments you are passing with the parameters the\nfunction expects."}),"\n",(0,o.jsx)(n.p,{children:"This often means figuring out if the value you are passing in is a subtype of\nthe value you are expecting."}),"\n",(0,o.jsx)(n.p,{children:"So if you write a function that expects the numbers 1 through 5, any subtype of\nthat set will be acceptable."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":9,"startColumn":3,"endLine":9,"endColumn":11,"description":"Cannot call `f` with `fiveOrSix` bound to `param` because union type [1] is incompatible with union type [2]. [incompatible-type] \\nType union type [1] includes members `6` that are not included in type union type [2]."}]',children:"function f(param: 1 | 2 | 3 | 4 | 5) {\n  // ...\n}\n\ndeclare const oneOrTwo: 1 |  2; // Subset of the input parameters type.\ndeclare const fiveOrSix: 5 | 6; // Not a subset of the input parameters type.\n\nf(oneOrTwo); // Works!\nf(fiveOrSix); // Error!\n"})}),"\n",(0,o.jsx)(n.h2,{id:"toc-subtypes-of-complex-types",children:"Subtypes of complex types"}),"\n",(0,o.jsx)(n.p,{children:"Flow needs to compare more than just sets of primitive values, it also needs to\nbe able to compare objects, functions, and every other type that appears in the\nlanguage."}),"\n",(0,o.jsx)(n.h3,{id:"toc-subtypes-of-objects",children:"Subtypes of objects"}),"\n",(0,o.jsx)(n.p,{children:"You can start to compare two objects by their keys. If one object contains all\nthe keys of another object, then it may be a subtype."}),"\n",(0,o.jsxs)(n.p,{children:["For example, if we had an ",(0,o.jsx)(n.code,{children:"ObjectA"})," which contained the key ",(0,o.jsx)(n.code,{children:"foo"}),", and an\n",(0,o.jsx)(n.code,{children:"ObjectB"})," which contained the keys ",(0,o.jsx)(n.code,{children:"foo"})," and ",(0,o.jsx)(n.code,{children:"bar"}),". Then it's possible that\n",(0,o.jsx)(n.code,{children:"ObjectB"})," is a subtype of ",(0,o.jsx)(n.code,{children:"ObjectA"}),", if ",(0,o.jsx)(n.code,{children:"ObjectA"})," is inexact."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type ObjectA = {foo: string, ...};\ntype ObjectB = {foo: string, bar: number};\n\nlet objectB: ObjectB = {foo: 'test', bar: 42};\nlet objectA: ObjectA = objectB; // Works!\n"})}),"\n",(0,o.jsxs)(n.p,{children:["But we also need to compare the types of the values. If both objects had a key\n",(0,o.jsx)(n.code,{children:"foo"})," but one was a ",(0,o.jsx)(n.code,{children:"number"})," and the other was a ",(0,o.jsx)(n.code,{children:"string"}),", then one would not\nbe the subtype of the other."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":5,"startColumn":24,"endLine":5,"endColumn":30,"description":"Cannot assign `objectB` to `objectA` because in property `foo`: `number` [1] is not exactly the same as `string` [2]. [incompatible-type] \\nThe above-mentioned two types must be the same because property `foo` is invariantly typed. To fix the error,\\n- Either make `ObjectB` [3] and `ObjectA` [4] exactly the same\\n- Or make property `foo` in `ObjectA` [5] readonly. See https://flow.org/en/docs/faq/#why-cant-i-pass-a-string-to-a-function-that-takes-a-string-number."}]',children:"type ObjectA = {foo: string, ...};\ntype ObjectB = {foo: number, bar: number};\n\nlet objectB: ObjectB = { foo: 1, bar: 2 };\nlet objectA: ObjectA = objectB; // Error!\n"})}),"\n",(0,o.jsx)(n.p,{children:"If these values on the object happen to be other objects, we would have to\ncompare those against one another. We need to compare every value\nrecursively until we can decide if we have a subtype or not."}),"\n",(0,o.jsx)(n.h3,{id:"toc-subtypes-of-functions",children:"Subtypes of functions"}),"\n",(0,o.jsxs)(n.p,{children:["Subtyping rules for functions are more complicated. So far, we've seen that ",(0,o.jsx)(n.code,{children:"A"}),"\nis a subtype of ",(0,o.jsx)(n.code,{children:"B"})," if ",(0,o.jsx)(n.code,{children:"B"})," contains all possible values for ",(0,o.jsx)(n.code,{children:"A"}),". For functions,\nit's not clear how this relationship would apply. To simplify things, you can think\nof a function type ",(0,o.jsx)(n.code,{children:"A"})," as being a subtype of a function type ",(0,o.jsx)(n.code,{children:"B"})," if functions of type\n",(0,o.jsx)(n.code,{children:"A"})," can be used wherever a function of type ",(0,o.jsx)(n.code,{children:"B"})," is expected."]}),"\n",(0,o.jsx)(n.p,{children:"Let's say we have a function type and a few functions. Which of the functions can\nbe used safely in code that expects the given function type?"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":7,"startColumn":1,"endLine":7,"endColumn":2,"description":"Cannot cast `f1` to `FuncType` because in the return value: union type [1] is incompatible with union type [2]. [incompatible-type] \\nType union type [1] includes members `C` that are not included in type union type [2]."},{"startLine":8,"startColumn":1,"endLine":8,"endColumn":2,"description":"Cannot cast `f2` to `FuncType` because in the first parameter: union type [1] is incompatible with number literal `2` [2]. [incompatible-type]"}]',children:'type FuncType = (1 | 2) => "A" | "B";\n\ndeclare function f1(1 | 2): "A" | "B" | "C";\ndeclare function f2(1 | null): "A" | "B";\ndeclare function f3(1 | 2 | 3): "A";\n\nf1 as FuncType; // Error\nf2 as FuncType; // Error\nf3 as FuncType; // Works!\n'})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"f1"})," can return a value that ",(0,o.jsx)(n.code,{children:"FuncType"})," never does, so code that relies on ",(0,o.jsx)(n.code,{children:"FuncType"}),"\nmight not be safe if ",(0,o.jsx)(n.code,{children:"f1"})," is used. Its type is not a subtype of ",(0,o.jsx)(n.code,{children:"FuncType"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"f2"})," can't handle all the argument values that ",(0,o.jsx)(n.code,{children:"FuncType"})," does, so code that relies on\n",(0,o.jsx)(n.code,{children:"FuncType"})," can't safely use ",(0,o.jsx)(n.code,{children:"f2"}),". Its type is also not a subtype of ",(0,o.jsx)(n.code,{children:"FuncType"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"f3"})," can accept all the argument values that ",(0,o.jsx)(n.code,{children:"FuncType"})," does, and only returns\nvalues that ",(0,o.jsx)(n.code,{children:"FuncType"})," does, so its type is a subtype of ",(0,o.jsx)(n.code,{children:"FuncType"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["In general, the function subtyping rule is this: a function type ",(0,o.jsx)(n.code,{children:"B"})," is a subtype\nof a function type ",(0,o.jsx)(n.code,{children:"A"})," if and only if ",(0,o.jsx)(n.code,{children:"B"}),"'s inputs are a superset of ",(0,o.jsx)(n.code,{children:"A"}),"'s, and ",(0,o.jsx)(n.code,{children:"B"}),"'s outputs\nare a subset of ",(0,o.jsx)(n.code,{children:"A"}),"'s. The subtype must accept ",(0,o.jsx)(n.em,{children:"at least"})," the same inputs as its parent,\nand must return ",(0,o.jsx)(n.em,{children:"at most"})," the same outputs."]}),"\n",(0,o.jsxs)(n.p,{children:["The decision of which direction to apply the subtyping rule on inputs and outputs is\ngoverned by ",(0,o.jsx)(n.a,{href:"../variance",children:"variance"}),", which is the topic of the next section."]})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453(e,n,t){t.d(n,{R:()=>i,x:()=>a});var s=t(96540);const o={},c=s.createContext(o);function i(e){const n=s.useContext(c);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(c.Provider,{value:n},e.children)}}}]);