"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[2767],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(96540);const a={},r=s.createContext(a);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:n},e.children)}},42767:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"lang/nominal-structural","title":"Nominal & Structural Typing","description":"A static type checker can use either the name (nominal typing) or the structure (structural typing)","source":"@site/docs/lang/nominal-structural.md","sourceDirName":"lang","slug":"/lang/nominal-structural","permalink":"/en/docs/lang/nominal-structural","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/lang/nominal-structural.md","tags":[],"version":"current","frontMatter":{"title":"Nominal & Structural Typing","slug":"/lang/nominal-structural"},"sidebar":"docsSidebar","previous":{"title":"Type Variance","permalink":"/en/docs/lang/variance"},"next":{"title":"Depth Subtyping","permalink":"/en/docs/lang/depth-subtyping"}}');var a=t(74848),r=t(28453);const i={title:"Nominal & Structural Typing",slug:"/lang/nominal-structural"},o=void 0,l={},c=[{value:"Nominal typing",id:"toc-nominal-typing",level:2},{value:"Structural typing",id:"toc-structural-typing",level:2},{value:"In Flow",id:"in-flow",level:2},{value:"Functions are structurally typed",id:"toc-functions-are-structurally-typed",level:3},{value:"Objects are structurally typed",id:"toc-objects-are-structurally-typed",level:3},{value:"Classes are nominally typed",id:"toc-classes-are-nominally-typed",level:3},{value:"Opaque types",id:"opaque-types",level:3},{value:"Flow Enums",id:"flow-enums",level:3}];function u(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["A static type checker can use either the name (nominal typing) or the structure (structural typing)\nof types when comparing them against other types (like when checking if one is a ",(0,a.jsx)(n.a,{href:"../subtypes",children:"subtype"})," of another)."]}),"\n",(0,a.jsx)(n.h2,{id:"toc-nominal-typing",children:"Nominal typing"}),"\n",(0,a.jsx)(n.p,{children:"Languages like C++, Java, and Swift have primarily nominal type systems."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// Pseudo code: nominal system\nclass Foo { method(input: string) { /* ... */ } }\nclass Bar { method(input: string) { /* ... */ } }\n\nlet foo: Foo = new Bar(); // Error!\n"})}),"\n",(0,a.jsx)(n.p,{children:"In this pseudo-code example, the nominal type system errors even though both classes have a method of the same name and type.\nThis is because the name (and declaration location) of the classes is different."}),"\n",(0,a.jsx)(n.h2,{id:"toc-structural-typing",children:"Structural typing"}),"\n",(0,a.jsx)(n.p,{children:"Languages like Go and Elm have primarily structural type systems."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// Pseudo code: structural system\nclass Foo { method(input: string) { /* ... */ } }\nclass Bar { method(input: string) { /* ... */ } }\n\nlet foo: Foo = new Bar(); // Works!\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In this pseudo-code example, the structural type system allows a ",(0,a.jsx)(n.code,{children:"Bar"})," to be used as a ",(0,a.jsx)(n.code,{children:"Foo"}),",\nsince both classes have methods and fields of the same name and type."]}),"\n",(0,a.jsx)(n.p,{children:"If the shape of the classes differ however, then a structural system would produce an error:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// Pseudo code\nclass Foo { method(input: string) { /* ... */ } }\nclass Bar { method(input: number) { /* ... */ } }\n\nlet foo: Foo = new Bar(); // Error!\n"})}),"\n",(0,a.jsx)(n.p,{children:"We've demonstrated both nominal and structural typing of classes, but there are\nalso other complex types like objects and functions which can also be either\nnominally or structurally compared.\nAdditionally, a type system may have aspects of both structural and nominal systems."}),"\n",(0,a.jsx)(n.h2,{id:"in-flow",children:"In Flow"}),"\n",(0,a.jsx)(n.p,{children:"Flow uses structural typing for objects and functions, but nominal typing for classes."}),"\n",(0,a.jsx)(n.h3,{id:"toc-functions-are-structurally-typed",children:"Functions are structurally typed"}),"\n",(0,a.jsxs)(n.p,{children:["When comparing a ",(0,a.jsx)(n.a,{href:"../../types/functions",children:"function type"})," with a function it must have the same structure\nin order to be considered valid."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"type FuncType = (input: string) => void;\nfunction func(input: string) { /* ... */ }\nlet test: FuncType = func; // Works!\n"})}),"\n",(0,a.jsx)(n.h3,{id:"toc-objects-are-structurally-typed",children:"Objects are structurally typed"}),"\n",(0,a.jsxs)(n.p,{children:["When comparing an ",(0,a.jsx)(n.a,{href:"../../types/objects",children:"object type"})," with an object it must have the same structure\nin order to be considered valid."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'type ObjType = {property: string};\nlet obj = {property: "value"};\nlet test: ObjType = obj; // Works\n'})}),"\n",(0,a.jsx)(n.h3,{id:"toc-classes-are-nominally-typed",children:"Classes are nominally typed"}),"\n",(0,a.jsxs)(n.p,{children:["When you have two ",(0,a.jsx)(n.a,{href:"../../types/classes",children:"classes"})," with the same structure, they still are not\nconsidered equivalent because Flow uses nominal typing for classes."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":3,"startColumn":17,"endLine":3,"endColumn":25,"description":"Cannot assign `new Bar()` to `test` because `Bar` [1] is incompatible with `Foo` [2]. [incompatible-type]"}]',children:"class Foo { method(input: string) { /* ... */ } }\nclass Bar { method(input: string) { /* ... */ } }\nlet test: Foo = new Bar(); // Error!\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If you wanted to use a class structurally you could do that using an ",(0,a.jsx)(n.a,{href:"../../types/interfaces",children:"interface"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"interface Interface {\n  method(value: string): void;\n};\n\nclass Foo { method(input: string) { /* ... */ } }\nclass Bar { method(input: string) { /* ... */ } }\n\nlet test1: Interface = new Foo(); // Works\nlet test2: Interface = new Bar(); // Works\n"})}),"\n",(0,a.jsx)(n.h3,{id:"opaque-types",children:"Opaque types"}),"\n",(0,a.jsxs)(n.p,{children:["You can use ",(0,a.jsx)(n.a,{href:"../../types/opaque-types",children:"opaque types"})," to turn a previously structurally typed alias into a nominal one (outside of the file that it is defined)."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:"[]",children:'// A.js\nexport type MyTypeAlias = string;\nexport opaque type MyOpaqueType = string;\n\nconst x: MyTypeAlias = "hi"; // Works\nconst y: MyOpaqueType = "hi"; // Works\n'})}),"\n",(0,a.jsx)(n.p,{children:"In a different file:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'// B.js\nimport type {MyTypeAlias, MyOpaqueType} from "A.js";\n\nconst x: MyTypeAlias = "hi"; // Works\nconst y: MyOpaqueType = "hi"; // Error! `MyOpaqueType` is not interchangeable with `string`\n//                      ^^^^ Cannot assign "hi" to y because string is incompatible with MyOpaqueType\n'})}),"\n",(0,a.jsx)(n.h3,{id:"flow-enums",children:"Flow Enums"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"../../enums",children:"Flow Enums"})," do not allow enum members with the same value, but which belong to different enums, to be used interchangeably."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-flow",metastring:'[{"startLine":8,"startColumn":14,"endLine":8,"endColumn":16,"description":"Cannot assign `B.X` to `a` because `B` [1] is incompatible with `A` [2]. [incompatible-type]"}]',children:'enum A {\n  X = "x",\n}\nenum B {\n  X = "x",\n}\n\nconst a: A = B.X; // Error!\n'})})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}}}]);