(*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *)

open Utils_js
open Reason
open Type
open TypeUtil
module ImplicitTypeArgument = Instantiation_utils.ImplicitTypeArgument

(* Cache that remembers pairs of types that are passed to __flow. *)
module FlowConstraint = struct
  let rec toplevel_use_op = function
    | Frame (_frame, use_op) -> toplevel_use_op use_op
    | Op (Speculation use_op) -> toplevel_use_op use_op
    | use_op -> use_op

  (* attempt to read LB/UB pair from cache, add if absent *)
  let get cx (l, u) =
    match (l, u) with
    (* Don't cache constraints involving type variables, since the
       corresponding typing rules are already sufficiently robust. *)
    | (OpenT _, _)
    | (_, UseT (_, OpenT _))
    | (_, ReposUseT _) ->
      false
    | _ ->
      (* Use ops are purely for better error messages: they should have no
         effect on type checking. However, recursively nested use ops can pose
         non-termination problems. To ensure proper caching, we hash use ops
         to just their toplevel structure. *)
      let u = mod_use_op_of_use_t toplevel_use_op u in
      let cache = Context.constraint_cache cx in
      let cache' = FlowSet.add (l, u) !cache in
      let found = cache' == !cache in
      if not found then
        cache := cache'
      else if Context.is_verbose cx then
        prerr_endlinef
          "%sFlowConstraint cache hit on (%s, %s)"
          (Context.pid_prefix cx)
          (string_of_ctor l)
          (string_of_use_ctor u);
      found
end

(* Cache that limits instantiation of polymorphic definitions. Intuitively,
   for each operation on a polymorphic definition, we remember the type
   arguments we use to specialize the type parameters. An operation is
   identified by its reason, and possibly the reasons of its arguments. We
   don't use the entire operation for caching since it may contain the very
   type variables we are trying to limit the creation of with the cache (e.g.,
   those representing the result): the cache would be useless if we considered
   those type variables as part of the identity of the operation. *)
module PolyInstantiation = struct
  let find cx reason_tapp typeparam op_reason =
    let cache = Context.instantiation_cache cx in
    try Hashtbl.find cache (reason_tapp, typeparam.reason, op_reason)
    with _ ->
      let t = ImplicitTypeArgument.mk_targ cx typeparam (Nel.hd op_reason) reason_tapp in
      Hashtbl.add cache (reason_tapp, typeparam.reason, op_reason) t;
      t
end

module Eval = struct
  let id cx t defer_use =
    let (eval_id_cache, id_cache) = Context.eval_id_cache cx in
    match t with
    | EvalT (_, d, i) when d = defer_use ->
      (match Hashtbl.find_opt eval_id_cache i with
      | Some t -> t
      | None ->
        let i = Type.Eval.generate_id () in
        Hashtbl.add eval_id_cache i t;
        EvalT (t, defer_use, i))
    | _ ->
      let cache_key = (t, defer_use) in
      let id =
        match Hashtbl.find_opt id_cache cache_key with
        | Some i -> i
        | None ->
          let i = Type.Eval.generate_id () in
          Hashtbl.add id_cache cache_key i;
          i
      in
      EvalT (t, defer_use, id)

  let find_repos cx t defer_use id =
    let repos_cache = Context.eval_repos_cache cx in
    let cache_key = (t, defer_use, id) in
    Hashtbl.find_opt repos_cache cache_key

  let add_repos cx t defer_use id tvar =
    let repos_cache = Context.eval_repos_cache cx in
    let cache_key = (t, defer_use, id) in
    Hashtbl.add repos_cache cache_key tvar
end

module Fix = struct
  type cache_key = reason * Type.t

  let cache : (cache_key, Type.t) Hashtbl.t = Hashtbl.create 0

  let find reason i =
    let cache_key = (reason, i) in
    Hashtbl.find_opt cache cache_key

  let add reason i tvar =
    let cache_key = (reason, i) in
    Hashtbl.add cache cache_key tvar
end

(* This cache maps from spreads (indexed by spread ids, which are generated by eval_destructor
 * and Statement.ml) to one of the lower bounds of their operands in each index and the reasons
 * that reach that spread operand.
 *
 * cache(spread_id)(resolve_idx) gets you a slice and reasons for a spread index. If any
 * two indices have more than one lower bound, then we will get at least quadratic results
 * by computing the spreads. Instead of going through with the computation, we emit an error.
 *
 * We need to track the slice explicitly in addition to the list of reasons because
 * only count an index as having multiple lower bounds if those lower bounds are actually
 * different. This is important: if an early index receives multiple lower bounds, it will
 * kick off a resolution job for each. Both of those resolution jobs share a spread id,
 * so it's important that we don't double count a later operand being resolved as multiple
 * lower bounds when it's just resolved twice because of the separate resolution jobs.
 *)
module Spread = struct
  type reason_state = ALoc.t Error_message.exponential_spread_reason_group

  type cache_state =
    (int option * (Object.slice * reason_state) IMap.t, reason_state * reason_state) result

  let cache : (int, cache_state) Hashtbl.t = Hashtbl.create 0

  let add_lower_bound spread_id resolve_idx r objtypes =
    let state =
      match Hashtbl.find_opt cache spread_id with
      | None -> Ok (None, IMap.empty)
      | Some state -> state
    in
    let state' =
      match state with
      | Error error_groups -> Error error_groups
      | Ok (idx_option, map) ->
        let (map', has_multiple_lower_bounds) =
          let (new_entry, has_multiple_lower_bounds) =
            let open Error_message in
            match IMap.find_opt resolve_idx map with
            | None ->
              ( (Nel.hd objtypes, { first_reason = r; second_reason = None }),
                Nel.length objtypes <> 1 )
            | Some (slice, reason_state) ->
              let has_new_lower_bound =
                Nel.fold_left (fun acc s -> acc || slice <> s) false objtypes
              in
              let reason_state = { reason_state with second_reason = Some r } in
              ((slice, reason_state), has_new_lower_bound)
          in
          (IMap.add resolve_idx new_entry map, has_multiple_lower_bounds)
        in
        (* If we have multiple lower bounds and this isn't the only idx with multiple
         * lower bounds then we enter our error state *)
        if has_multiple_lower_bounds then
          match idx_option with
          | Some idx when idx <> resolve_idx ->
            let group1 = snd (IMap.find resolve_idx map') in
            let group2 = snd (IMap.find idx map') in
            Error (group1, group2)
          | _ -> Ok (Some resolve_idx, map')
        else
          Ok (idx_option, map')
    in
    Hashtbl.replace cache spread_id state'

  let get_error_groups spread_id =
    match Hashtbl.find_opt cache spread_id with
    | Some (Error (group1, group2)) -> (group1, group2)
    | _ ->
      assert_false
        "Invariant violation: make sure can_spread is false before calling get_error_groups"

  let can_spread spread_id =
    match Hashtbl.find_opt cache spread_id with
    | Some (Error _) -> false
    | _ -> true
end

let clear () =
  Hashtbl.clear Fix.cache;
  Hashtbl.clear Spread.cache;
  ()

let stats_poly_instantiation cx =
  let cache = Context.instantiation_cache cx in
  Hashtbl.stats cache

(* debug util: please don't dead-code-eliminate *)
(* Summarize flow constraints in cache as ctor/reason pairs, and return counts
   for each group. *)
let summarize_flow_constraint cx =
  let group_counts =
    FlowSet.fold
      (fun (l, u) map ->
        let key =
          spf
            "[%s] %s => [%s] %s"
            (string_of_ctor l)
            (string_of_reason (reason_of_t l))
            (string_of_use_ctor u)
            (string_of_reason (reason_of_use_t u))
        in
        match SMap.find_opt key map with
        | None -> SMap.add key 0 map
        | Some i -> SMap.add key (i + 1) map)
      !(Context.constraint_cache cx)
      SMap.empty
  in
  SMap.elements group_counts |> List.sort (fun (_, i1) (_, i2) -> Stdlib.compare i1 i2)
