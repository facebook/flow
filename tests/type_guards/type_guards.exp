Error --------------------------------------------------------------------------------------------- class_imports.js:8:4

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   class_imports.js:8:4
   8|   (x: string); // error number ~> string
         ^

References:
   class_exports.js:2:21
   2|   m(x: mixed): x is number {
                          ^^^^^^ [1]
   class_imports.js:8:7
   8|   (x: string); // error number ~> string
            ^^^^^^ [2]


Error -------------------------------------------------------------------------------------------- class_imports.js:13:4

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   class_imports.js:13:4
   13|   (x: string); // error number ~> string
          ^

References:
   class_exports.js:5:30
    5|   os(x: mixed): implies x is number {
                                    ^^^^^^ [1]
   class_imports.js:13:7
   13|   (x: string); // error number ~> string
             ^^^^^^ [2]


Error -------------------------------------------------------------------------------------------- class_imports.js:19:4

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   class_imports.js:19:4
   19|   (x: string); // error number ~> string
          ^

References:
   class_exports.js:11:21
   11|   m(x: mixed): x is number;
                           ^^^^^^ [1]
   class_imports.js:19:7
   19|   (x: string); // error number ~> string
             ^^^^^^ [2]


Error -------------------------------------------------------------------------------------------- class_imports.js:24:4

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   class_imports.js:24:4
   24|   (x: string); // error number ~> string
          ^

References:
   class_exports.js:12:30
   12|   os(x: mixed): implies x is number;
                                    ^^^^^^ [1]
   class_imports.js:24:7
   24|   (x: string); // error number ~> string
             ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- classes.js:15:14

Cannot use type guard parameter `x` [1] because at this return point it is written to in [2]. [function-predicate]

   classes.js:15:14
   15|       return typeof x === 'number'; // error param write reaching this return
                    ^^^^^^^^^^^^^^^^^^^^^

References:
   classes.js:13:25
   13|     invalid1(x: mixed): x is number {
                               ^ [1]
   classes.js:14:7
   14|       x = 1;
             ^ [2]


Error ------------------------------------------------------------------------------------------------- classes.js:18:25

Cannot find type guard parameter `y` [1] in the parameters of this function (type). [function-predicate]

   18|     invalid2(x: mixed): y is number { // error param missing
                               ^ [1]


Error ------------------------------------------------------------------------------------------------- classes.js:22:25

Inconsistent type guard declaration because number [1] is incompatible with string [2]. The type of `x` [3] refined with
the predicate encoded in return expression `(typeof x) === 'number'` [1] needs to be compatible with the guard type
string [2]. See 1. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions.
[incompatible-type-guard]

   classes.js:22:25
   22|     invalid3(x: mixed): x is string {
                               ^^^^^^^^^^^

References:
   classes.js:23:14
   23|       return typeof x === 'number'; // error number ~> string
                    ^^^^^^^^^^^^^^^^^^^^^ [1]
   classes.js:22:30
   22|     invalid3(x: mixed): x is string {
                                    ^^^^^^ [2]
   classes.js:22:14
   22|     invalid3(x: mixed): x is string {
                    ^ [3]


Error ------------------------------------------------------------------------------------------------- classes.js:22:25

Inconsistent type guard declaration. The negation of the predicate encoded in return expression
`(typeof x) === 'number'` [1] needs to completely refine away the guard type string [2]. Consider using a one-sided
type-guard (`implies x is T`). See 2. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   classes.js:22:25
   22|     invalid3(x: mixed): x is string {
                               ^^^^^^^^^^^

References:
   classes.js:23:14
   23|       return typeof x === 'number'; // error number ~> string
                    ^^^^^^^^^^^^^^^^^^^^^ [1]
   classes.js:22:30
   22|     invalid3(x: mixed): x is string {
                                    ^^^^^^ [2]


Error -------------------------------------------------------------------------------------------------- classes.js:30:6

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   classes.js:30:6
   30|     (x: string); // error number ~> string
            ^

References:
   classes.js:5:23
    5|     m(x: mixed): x is number {
                             ^^^^^^ [1]
   classes.js:30:9
   30|     (x: string); // error number ~> string
               ^^^^^^ [2]


Error -------------------------------------------------------------------------------------------------- classes.js:33:6

Cannot cast `x` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   classes.js:33:6
   33|     (x: number); // error string ~> number
            ^

References:
   classes.js:9:30
    9|     static s(x: mixed): x is string {
                                    ^^^^^^ [1]
   classes.js:33:9
   33|     (x: number); // error string ~> number
               ^^^^^^ [2]


Error -------------------------------------------------------------------------------------------------- classes.js:40:5

Cannot extend `C` [1] with `D1` because function [2], a non-type-guard function, is incompatible with function [3],
which is a type-guard function in property `m`. [function-predicate]

   classes.js:40:5
           v----------------------------------------------------
   40|     m(x: mixed): boolean { // error extends non-predicate
   41|       return true;
   42|     }
           ^ [2]

References:
   classes.js:39:20
   39|   class D1 extends C {
                          ^ [1]
   classes.js:5:5
           v-------------------------
    5|     m(x: mixed): x is number {
    6|       return typeof x === 'number';
    7|     }
           ^ [3]


Error ------------------------------------------------------------------------------------------------- classes.js:46:23

Cannot extend `C` [1] with `D2` because mixed [2] is incompatible with number [3] in the type predicate of property `m`.
[incompatible-extend]

   classes.js:46:23
   46|     m(x: mixed): x is mixed { // error extends
                             ^^^^^ [2]

References:
   classes.js:45:20
   45|   class D2 extends C {
                          ^ [1]
   classes.js:5:23
    5|     m(x: mixed): x is number {
                             ^^^^^^ [3]


Error ------------------------------------------------------------------------------------------------- classes.js:46:18

Inconsistent type guard declaration. The negation of the predicate encoded in return expression `true` [1] needs to
completely refine away the guard type mixed [2]. Consider using a one-sided type-guard (`implies x is T`). See 2. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   classes.js:46:18
   46|     m(x: mixed): x is mixed { // error extends
                        ^^^^^^^^^^

References:
   classes.js:47:14
   47|       return true;
                    ^^^^ [1]
   classes.js:46:23
   46|     m(x: mixed): x is mixed { // error extends
                             ^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- classes.js:51:18

Inconsistent type guard declaration because mixed [1] is incompatible with number [2]. The type of `x` [3] refined with
the predicate encoded in return expression `true` [4] needs to be compatible with the guard type number [2]. See 1. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   classes.js:51:18
   51|     m(x: mixed): x is number {
                        ^^^^^^^^^^^

References:
   classes.js:51:10
   51|     m(x: mixed): x is number {
                ^^^^^ [1]
   classes.js:51:23
   51|     m(x: mixed): x is number {
                             ^^^^^^ [2]
   classes.js:51:7
   51|     m(x: mixed): x is number {
             ^ [3]
   classes.js:52:14
   52|       return true; // error mixed ~> number
                    ^^^^ [4]


Error ------------------------------------------------------------------------------------------------- classes.js:51:18

Inconsistent type guard declaration. The negation of the predicate encoded in return expression `true` [1] needs to
completely refine away the guard type number [2]. Consider using a one-sided type-guard (`implies x is T`). See 2. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   classes.js:51:18
   51|     m(x: mixed): x is number {
                        ^^^^^^^^^^^

References:
   classes.js:52:14
   52|       return true; // error mixed ~> number
                    ^^^^ [1]
   classes.js:51:23
   51|     m(x: mixed): x is number {
                             ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- classes.js:67:23

Cannot implement `I` [1] with `E1` because number [2] is incompatible with string [3] in the type predicate of property
`n`. [incompatible-type]

   classes.js:67:23
   67|     n(x: mixed): x is number { // error number ~> string
                             ^^^^^^ [2]

References:
   classes.js:63:23
   63|   class E1 implements I {
                             ^ [1]
   classes.js:60:23
   60|     n(x: mixed): x is string;
                             ^^^^^^ [3]


Error ------------------------------------------------------------------------------------------------- classes.js:81:23

Cannot implement `IP` [1] with `E2` because string [2] is incompatible with number [3] in the type predicate of property
`n`. [incompatible-type]

   classes.js:81:23
   81|     n(x: mixed): x is string { // error number ~> string
                             ^^^^^^ [2]

References:
   classes.js:77:23
   77|   class E2 implements IP<number> {
                             ^^^^^^^^^^ [1]
   classes.js:77:26
   77|   class E2 implements IP<number> {
                                ^^^^^^ [3]


Error -------------------------------------------------------------------------------------------------- classes.js:98:6

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   classes.js:98:6
   98|     (x: string); // error number ~> string
            ^

References:
   classes.js:91:23
   91|     m(x: mixed): x is number;
                             ^^^^^^ [1]
   classes.js:98:9
   98|     (x: string); // error number ~> string
               ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- classes.js:102:6

Cannot cast `x` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   classes.js:102:6
   102|     (x: number); // error string ~> number
             ^

References:
   classes.js:92:30
    92|     static s(x: mixed): x is string;
                                     ^^^^^^ [1]
   classes.js:102:9
   102|     (x: number); // error string ~> number
                ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- classes.js:107:5

Cannot extend `C` [1] with `D1` because function [2], a non-type-guard function, is incompatible with function type [3],
which is a type-guard function in property `m`. [function-predicate]

   classes.js:107:5
            v----------------------------------------------------
   107|     m(x: mixed): boolean { // error extends non-predicate
   108|       return true;
   109|     }
            ^ [2]

References:
   classes.js:106:20
   106|   class D1 extends C {
                           ^ [1]
   classes.js:91:5
    91|     m(x: mixed): x is number;
            ^^^^^^^^^^^^^^^^^^^^^^^^ [3]


Error ------------------------------------------------------------------------------------------------ classes.js:113:23

Cannot extend `C` [1] with `D2` because mixed [2] is incompatible with number [3] in the type predicate of property `m`.
[incompatible-extend]

   classes.js:113:23
   113|     m(x: mixed): x is mixed { // error mixed ~> number
                              ^^^^^ [2]

References:
   classes.js:112:20
   112|   class D2 extends C {
                           ^ [1]
   classes.js:91:23
    91|     m(x: mixed): x is number;
                              ^^^^^^ [3]


Error ------------------------------------------------------------------------------------------------ classes.js:113:18

Inconsistent type guard declaration. The negation of the predicate encoded in return expression `true` [1] needs to
completely refine away the guard type mixed [2]. Consider using a one-sided type-guard (`implies x is T`). See 2. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   classes.js:113:18
   113|     m(x: mixed): x is mixed { // error mixed ~> number
                         ^^^^^^^^^^

References:
   classes.js:114:14
   114|       return true; // error (negation) mixed ~> empty
                     ^^^^ [1]
   classes.js:113:23
   113|     m(x: mixed): x is mixed { // error mixed ~> number
                              ^^^^^ [2]


Error ------------------------------------------------------------------------------------------------ classes.js:118:18

Inconsistent type guard declaration because mixed [1] is incompatible with number [2]. The type of `x` [3] refined with
the predicate encoded in return expression `true` [4] needs to be compatible with the guard type number [2]. See 1. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   classes.js:118:18
   118|     m(x: mixed): x is number {
                         ^^^^^^^^^^^

References:
   classes.js:118:10
   118|     m(x: mixed): x is number {
                 ^^^^^ [1]
   classes.js:118:23
   118|     m(x: mixed): x is number {
                              ^^^^^^ [2]
   classes.js:118:7
   118|     m(x: mixed): x is number {
              ^ [3]
   classes.js:119:14
   119|       return true; // error mixed ~> number and (negation) number ~> empty
                     ^^^^ [4]


Error ------------------------------------------------------------------------------------------------ classes.js:118:18

Inconsistent type guard declaration. The negation of the predicate encoded in return expression `true` [1] needs to
completely refine away the guard type number [2]. Consider using a one-sided type-guard (`implies x is T`). See 2. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   classes.js:118:18
   118|     m(x: mixed): x is number {
                         ^^^^^^^^^^^

References:
   classes.js:119:14
   119|       return true; // error mixed ~> number and (negation) number ~> empty
                     ^^^^ [1]
   classes.js:118:23
   118|     m(x: mixed): x is number {
                              ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- classes.js:134:6

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   classes.js:134:6
   134|     (x: string); // error number ~> string
             ^

References:
   classes.js:131:19
   131|   const p = new P<number>();
                          ^^^^^^ [1]
   classes.js:134:9
   134|     (x: string); // error number ~> string
                ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- consistency.js:7:31

Cannot declare a type guard [1] for function [2] because boolean [1] is incompatible with implicitly-returned undefined.
[incompatible-return]

   consistency.js:7:31
   7| function no_return(x: mixed): x is number {} // error no return
                                    ^^^^^^^^^^^ [1]

References:
   consistency.js:7:1
   7| function no_return(x: mixed): x is number {} // error no return
      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- consistency.js:9:33

Inconsistent type guard declaration because mixed [1] is incompatible with number [2]. The type of `x` [3] refined with
the predicate encoded in return expression `true` [4] needs to be compatible with the guard type number [2]. See 1. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:9:33
    9| function return_true(x: mixed): x is number {
                                       ^^^^^^^^^^^

References:
   consistency.js:9:25
    9| function return_true(x: mixed): x is number {
                               ^^^^^ [1]
   consistency.js:9:38
    9| function return_true(x: mixed): x is number {
                                            ^^^^^^ [2]
   consistency.js:9:22
    9| function return_true(x: mixed): x is number {
                            ^ [3]
   consistency.js:10:12
   10|     return true; // error x: mixed ~> number and (negation) number ~> empty
                  ^^^^ [4]


Error ---------------------------------------------------------------------------------------------- consistency.js:9:33

Inconsistent type guard declaration. The negation of the predicate encoded in return expression `true` [1] needs to
completely refine away the guard type number [2]. Consider using a one-sided type-guard (`implies x is T`). See 2. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:9:33
    9| function return_true(x: mixed): x is number {
                                       ^^^^^^^^^^^

References:
   consistency.js:10:12
   10|     return true; // error x: mixed ~> number and (negation) number ~> empty
                  ^^^^ [1]
   consistency.js:9:38
    9| function return_true(x: mixed): x is number {
                                            ^^^^^^ [2]


Error --------------------------------------------------------------------------------------------- consistency.js:13:43

Inconsistent type guard declaration because mixed [1] is incompatible with number [2]. The type of `x` [3] refined with
the predicate encoded in return expression `true` [4] needs to be compatible with the guard type number [2]. See 1. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:13:43
   13| function return_true_in_branch(x: mixed): x is number {
                                                 ^^^^^^^^^^^

References:
   consistency.js:13:35
   13| function return_true_in_branch(x: mixed): x is number {
                                         ^^^^^ [1]
   consistency.js:13:48
   13| function return_true_in_branch(x: mixed): x is number {
                                                      ^^^^^^ [2]
   consistency.js:13:32
   13| function return_true_in_branch(x: mixed): x is number {
                                      ^ [3]
   consistency.js:15:12
   15|     return true; // error in this branch x: mixed ~> number
                  ^^^^ [4]


Error --------------------------------------------------------------------------------------------- consistency.js:13:43

Inconsistent type guard declaration. The negation of the predicate encoded in return expression `true` [1] needs to
completely refine away the guard type number [2]. Consider using a one-sided type-guard (`implies x is T`). See 2. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:13:43
   13| function return_true_in_branch(x: mixed): x is number {
                                                 ^^^^^^^^^^^

References:
   consistency.js:15:12
   15|     return true; // error in this branch x: mixed ~> number
                  ^^^^ [1]
   consistency.js:13:48
   13| function return_true_in_branch(x: mixed): x is number {
                                                      ^^^^^^ [2]


Error --------------------------------------------------------------------------------------------- consistency.js:25:40

Inconsistent type guard declaration because mixed [1] is incompatible with `A` [2]. The type of `x` [3] refined with the
predicate encoded in return expression `false` [4] needs to be compatible with the guard type `A` [2]. See 1. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. Consider replacing the body
of this predicate function with a single conditional expression. [incompatible-type-guard]

   consistency.js:25:40
   25| function always_false_error(x: mixed): x is A {
                                              ^^^^^^

References:
   consistency.js:25:32
   25| function always_false_error(x: mixed): x is A {
                                      ^^^^^ [1]
   consistency.js:25:45
   25| function always_false_error(x: mixed): x is A {
                                                   ^ [2]
   consistency.js:25:29
   25| function always_false_error(x: mixed): x is A {
                                   ^ [3]
   consistency.js:26:10
   26|   return false; // error (negation) A ~> empty, TODO: positive side should not error
                ^^^^^ [4]


Error --------------------------------------------------------------------------------------------- consistency.js:25:40

Inconsistent type guard declaration. The negation of the predicate encoded in return expression `false` [1] needs to
completely refine away the guard type `A` [2]. Consider using a one-sided type-guard (`implies x is T`). See 2. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:25:40
   25| function always_false_error(x: mixed): x is A {
                                              ^^^^^^

References:
   consistency.js:26:10
   26|   return false; // error (negation) A ~> empty, TODO: positive side should not error
                ^^^^^ [1]
   consistency.js:25:45
   25| function always_false_error(x: mixed): x is A {
                                                   ^ [2]


Error --------------------------------------------------------------------------------------------- consistency.js:29:70

Inconsistent type guard declaration because number [1] is incompatible with boolean [2]. The type of `x` [3] refined
with the predicate encoded in return expression `false` [4] needs to be compatible with the guard type boolean [2]. See
1. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. Consider replacing the
body of this predicate function with a single conditional expression. [incompatible-type-guard]

   consistency.js:29:70
   29| function return_false_under_condition(x: number | string | boolean): x is boolean {
                                                                            ^^^^^^^^^^^^

References:
   consistency.js:29:42
   29| function return_false_under_condition(x: number | string | boolean): x is boolean {
                                                ^^^^^^ [1]
   consistency.js:29:75
   29| function return_false_under_condition(x: number | string | boolean): x is boolean {
                                                                                 ^^^^^^^ [2]
   consistency.js:29:39
   29| function return_false_under_condition(x: number | string | boolean): x is boolean {
                                             ^ [3]
   consistency.js:31:12
   31|     return false; // error (for the same reason as above)
                  ^^^^^ [4]


Error --------------------------------------------------------------------------------------------- consistency.js:29:70

Inconsistent type guard declaration because string [1] is incompatible with boolean [2]. The type of `x` [3] refined
with the predicate encoded in return expression `false` [4] needs to be compatible with the guard type boolean [2]. See
1. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. Consider replacing the
body of this predicate function with a single conditional expression. [incompatible-type-guard]

   consistency.js:29:70
   29| function return_false_under_condition(x: number | string | boolean): x is boolean {
                                                                            ^^^^^^^^^^^^

References:
   consistency.js:29:51
   29| function return_false_under_condition(x: number | string | boolean): x is boolean {
                                                         ^^^^^^ [1]
   consistency.js:29:75
   29| function return_false_under_condition(x: number | string | boolean): x is boolean {
                                                                                 ^^^^^^^ [2]
   consistency.js:29:39
   29| function return_false_under_condition(x: number | string | boolean): x is boolean {
                                             ^ [3]
   consistency.js:33:12
   33|     return false; // error (for the same reason as above)
                  ^^^^^ [4]


Error --------------------------------------------------------------------------------------------- consistency.js:29:70

Inconsistent type guard declaration. The negation of the predicate encoded in return expression `true` [1] needs to
completely refine away the guard type boolean [2]. Consider using a one-sided type-guard (`implies x is T`). See 2. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:29:70
   29| function return_false_under_condition(x: number | string | boolean): x is boolean {
                                                                            ^^^^^^^^^^^^

References:
   consistency.js:35:12
   35|     return true; // TODO okay (no negation error)
                  ^^^^ [1]
   consistency.js:29:75
   29| function return_false_under_condition(x: number | string | boolean): x is boolean {
                                                                                 ^^^^^^^ [2]


Error --------------------------------------------------------------------------------------------- consistency.js:43:33

Inconsistent type guard declaration because string [1] is incompatible with number [2]. The type of `x` [3] refined with
the predicate encoded in return expression `((typeof x) === 'number') || ((typeof x) === 'string')` [4] needs to be
compatible with the guard type number [2]. See 1. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:43:33
   43| const arrow_error = (x: mixed): x is number => (
                                       ^^^^^^^^^^^

References:
   consistency.js:45:3
   45|   typeof x === 'string' // error x: string ~> number
         ^^^^^^^^^^^^^^^^^^^^^ [1]
   consistency.js:43:38
   43| const arrow_error = (x: mixed): x is number => (
                                            ^^^^^^ [2]
   consistency.js:43:22
   43| const arrow_error = (x: mixed): x is number => (
                            ^ [3]
   consistency.js:44:3
         v-----------------------
   44|   typeof x === 'number' ||
   45|   typeof x === 'string' // error x: string ~> number
         --------------------^ [4]


Error --------------------------------------------------------------------------------------------- consistency.js:49:16

Inconsistent type guard declaration because string [1] is incompatible with number [2]. The type of `x` [3] refined with
the predicate encoded in return expression `(typeof x) === 'string'` [1] needs to be compatible with the guard type
number [2]. See 1. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions.
[incompatible-type-guard]

   consistency.js:49:16
   49|   m(x: mixed): x is number {
                      ^^^^^^^^^^^

References:
   consistency.js:50:12
   50|     return typeof x === 'string'; // error x: string ~> number and (negation) number ~> empty
                  ^^^^^^^^^^^^^^^^^^^^^ [1]
   consistency.js:49:21
   49|   m(x: mixed): x is number {
                           ^^^^^^ [2]
   consistency.js:49:5
   49|   m(x: mixed): x is number {
           ^ [3]


Error --------------------------------------------------------------------------------------------- consistency.js:49:16

Inconsistent type guard declaration. The negation of the predicate encoded in return expression
`(typeof x) === 'string'` [1] needs to completely refine away the guard type number [2]. Consider using a one-sided
type-guard (`implies x is T`). See 2. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:49:16
   49|   m(x: mixed): x is number {
                      ^^^^^^^^^^^

References:
   consistency.js:50:12
   50|     return typeof x === 'string'; // error x: string ~> number and (negation) number ~> empty
                  ^^^^^^^^^^^^^^^^^^^^^ [1]
   consistency.js:49:21
   49|   m(x: mixed): x is number {
                           ^^^^^^ [2]


Error --------------------------------------------------------------------------------------------- consistency.js:55:30

Inconsistent type guard declaration because number [1] is incompatible with string [2]. The type of `x` [3] refined with
the predicate encoded in return expression `x != null` [4] needs to be compatible with the guard type string [2]. See 1.
in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:55:30
   55|   const tes1 = (x: ?number): x is string => ( // error on string because string ~/> ?number
                                    ^^^^^^^^^^^

References:
   consistency.js:55:21
   55|   const tes1 = (x: ?number): x is string => ( // error on string because string ~/> ?number
                           ^^^^^^ [1]
   consistency.js:55:35
   55|   const tes1 = (x: ?number): x is string => ( // error on string because string ~/> ?number
                                         ^^^^^^ [2]
   consistency.js:55:17
   55|   const tes1 = (x: ?number): x is string => ( // error on string because string ~/> ?number
                       ^ [3]
   consistency.js:56:5
   56|     x != null // error number ~> string
           ^^^^^^^^^ [4]


Error --------------------------------------------------------------------------------------------- consistency.js:55:35

Cannot use string [1] as type prediate for parameter `x` because string [1] is incompatible with number [2]. A user
defined type guard needs to be compatible with its parameter's type. [incompatible-type-guard]

   consistency.js:55:35
   55|   const tes1 = (x: ?number): x is string => ( // error on string because string ~/> ?number
                                         ^^^^^^ [1]

References:
   consistency.js:55:21
   55|   const tes1 = (x: ?number): x is string => ( // error on string because string ~/> ?number
                           ^^^^^^ [2]


Error --------------------------------------------------------------------------------------------- consistency.js:59:31

Inconsistent type guard declaration because null or undefined [1] is incompatible with number [2]. The type of `x` [3]
refined with the predicate encoded in return expression `x !== null` [4] needs to be compatible with the guard type
number [2]. See 1. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions.
[incompatible-type-guard]

   consistency.js:59:31
   59|   const test2 = (x: ?number): x is number => (
                                     ^^^^^^^^^^^

References:
   consistency.js:59:21
   59|   const test2 = (x: ?number): x is number => (
                           ^^^^^^^ [1]
   consistency.js:59:36
   59|   const test2 = (x: ?number): x is number => (
                                          ^^^^^^ [2]
   consistency.js:59:18
   59|   const test2 = (x: ?number): x is number => (
                        ^ [3]
   consistency.js:60:5
   60|     x !== null // error null | undefined ~> string
           ^^^^^^^^^^ [4]


Error --------------------------------------------------------------------------------------------- consistency.js:71:19

Inconsistent type guard declaration because number [1] is incompatible with string [2]. The type of `x` [3] refined with
the predicate encoded in return expression `x != null` [4] needs to be compatible with the guard type string [2]. See 1.
in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:71:19
   71|   arr.filter((x): x is string => ( // error on string because string ~/> ?number
                         ^^^^^^^^^^^

References:
   consistency.js:69:27
   69|   declare var arr: Array<?number>;
                                 ^^^^^^ [1]
   consistency.js:71:24
   71|   arr.filter((x): x is string => ( // error on string because string ~/> ?number
                              ^^^^^^ [2]
   consistency.js:71:15
   71|   arr.filter((x): x is string => ( // error on string because string ~/> ?number
                     ^ [3]
   consistency.js:72:5
   72|     x != null // error number ~> string
           ^^^^^^^^^ [4]


Error --------------------------------------------------------------------------------------------- consistency.js:71:24

Cannot use string [1] as type prediate for parameter `x` because string [1] is incompatible with number [2]. A user
defined type guard needs to be compatible with its parameter's type. [incompatible-type-guard]

   consistency.js:71:24
   71|   arr.filter((x): x is string => ( // error on string because string ~/> ?number
                              ^^^^^^ [1]

References:
   consistency.js:69:27
   69|   declare var arr: Array<?number>;
                                 ^^^^^^ [2]


Error --------------------------------------------------------------------------------------------- consistency.js:75:19

Inconsistent type guard declaration because null or undefined [1] is incompatible with number [2]. The type of `x` [3]
refined with the predicate encoded in return expression `x !== null` [4] needs to be compatible with the guard type
number [2]. See 1. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions.
[incompatible-type-guard]

   consistency.js:75:19
   75|   arr.filter((x): x is number => (
                         ^^^^^^^^^^^

References:
   consistency.js:69:26
   69|   declare var arr: Array<?number>;
                                ^^^^^^^ [1]
   consistency.js:75:24
   75|   arr.filter((x): x is number => (
                              ^^^^^^ [2]
   consistency.js:75:15
   75|   arr.filter((x): x is number => (
                     ^ [3]
   consistency.js:76:5
   76|     x !== null // error null | undefined ~> string
           ^^^^^^^^^^ [4]


Error --------------------------------------------------------------------------------------------- consistency.js:94:40

Inconsistent type guard declaration. The negation of the predicate encoded in return expression `x instanceof B` [1]
needs to completely refine away the guard type `A` [2]. Consider using a one-sided type-guard (`implies x is T`). See 2.
in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:94:40
   94| function instanceof_error_1(x: mixed): x is A {
                                              ^^^^^^

References:
   consistency.js:95:10
   95|   return x instanceof B; // error (negation) A ~> empty
                ^^^^^^^^^^^^^^ [1]
   consistency.js:94:45
   94| function instanceof_error_1(x: mixed): x is A {
                                                   ^ [2]


Error --------------------------------------------------------------------------------------------- consistency.js:98:40

Inconsistent type guard declaration because `A` [1] is incompatible with `B` [2]. The type of `x` [3] refined with the
predicate encoded in return expression `x instanceof A` [4] needs to be compatible with the guard type `B` [2]. See 1.
in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:98:40
   98| function instanceof_error_2(x: mixed): x is B {
                                              ^^^^^^

References:
   consistency.js:99:23
   99|   return x instanceof A; // error A ~> B
                             ^ [1]
   consistency.js:98:45
   98| function instanceof_error_2(x: mixed): x is B {
                                                   ^ [2]
   consistency.js:98:29
   98| function instanceof_error_2(x: mixed): x is B {
                                   ^ [3]
   consistency.js:99:10
   99|   return x instanceof A; // error A ~> B
                ^^^^^^^^^^^^^^ [4]


Error -------------------------------------------------------------------------------------------- consistency.js:124:44

Inconsistent type guard declaration because array element of refined mixed [1] is incompatible with `A` [2] in array
element. The type of `x` [3] refined with the predicate encoded in return expression `Array.isArray(...)` [4] needs to
be compatible with the guard type read-only array type [5]. See 1. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:124:44
   124| function is_array_poly_error<A>(x: mixed): x is $ReadOnlyArray<A> { // error ROArray<mixed> ~> ROArray<A>
                                                   ^^^^^^^^^^^^^^^^^^^^^^

References:
   consistency.js:124:36
   124| function is_array_poly_error<A>(x: mixed): x is $ReadOnlyArray<A> { // error ROArray<mixed> ~> ROArray<A>
                                           ^^^^^ [1]
   consistency.js:124:64
   124| function is_array_poly_error<A>(x: mixed): x is $ReadOnlyArray<A> { // error ROArray<mixed> ~> ROArray<A>
                                                                       ^ [2]
   consistency.js:124:33
   124| function is_array_poly_error<A>(x: mixed): x is $ReadOnlyArray<A> { // error ROArray<mixed> ~> ROArray<A>
                                        ^ [3]
   consistency.js:125:10
   125|   return Array.isArray(x);
                 ^^^^^^^^^^^^^^^^ [4]
   consistency.js:124:49
   124| function is_array_poly_error<A>(x: mixed): x is $ReadOnlyArray<A> { // error ROArray<mixed> ~> ROArray<A>
                                                        ^^^^^^^^^^^^^^^^^ [5]


Error -------------------------------------------------------------------------------------------- consistency.js:137:29

Inconsistent type guard declaration. The negation of the predicate encoded in return expression
`isNumberOrString(...) && isBoolean(...)` [1] needs to completely refine away the guard type string [2]. Consider using
a one-sided type-guard (`implies x is T`). See 2. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:137:29
   137|   function error(x: mixed): x is string {
                                    ^^^^^^^^^^^

References:
   consistency.js:138:12
   138|     return isNumberOrString(x) && isBoolean(x); // error (negation) string ~> empty
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]
   consistency.js:137:34
   137|   function error(x: mixed): x is string {
                                         ^^^^^^ [2]


Error -------------------------------------------------------------------------------------------- consistency.js:149:10

Cannot use type guard parameter `x` [1] because at this return point it is written to in [2]. [function-predicate]

   consistency.js:149:10
   149|   return x instanceof A; // error 'x' is written to
                 ^^^^^^^^^^^^^^

References:
   consistency.js:147:55
   147| function error_write_to_type_guard_param_1(x: mixed): x is A {
                                                              ^ [1]
   consistency.js:148:3
   148|   x = 1;
          ^ [2]


Error -------------------------------------------------------------------------------------------- consistency.js:154:10

Cannot use type guard parameter `x` [1] because at this return point it is written to in [2]. [function-predicate]

   consistency.js:154:10
   154|   return x instanceof B; // error 'x' is written to
                 ^^^^^^^^^^^^^^

References:
   consistency.js:152:55
   152| function error_write_to_type_guard_param_2(x: mixed): x is B {
                                                              ^ [1]
   consistency.js:153:3
   153|   x = new B();
          ^ [2]


Error -------------------------------------------------------------------------------------------- consistency.js:160:12

Cannot use type guard parameter `x` [1] because at this return point it is written to in [2]. [function-predicate]

   consistency.js:160:12
   160|     return x instanceof B; // error 'x' is written to (1st loc)
                   ^^^^^^^^^^^^^^

References:
   consistency.js:157:59
   157| function error_write_to_type_guard_param_multi(x: mixed): x is B {
                                                                  ^ [1]
   consistency.js:159:5
   159|     x = new B();
            ^ [2]


Error -------------------------------------------------------------------------------------------- consistency.js:163:12

Cannot use type guard parameter `x` [1] because at this return point it is written to in [2]. [function-predicate]

   consistency.js:163:12
   163|     return x instanceof B; // error 'x' is written to (2nd loc)
                   ^^^^^^^^^^^^^^

References:
   consistency.js:157:59
   157| function error_write_to_type_guard_param_multi(x: mixed): x is B {
                                                                  ^ [1]
   consistency.js:162:5
   162|     x = new B();
            ^ [2]


Error -------------------------------------------------------------------------------------------- consistency.js:167:37

Inconsistent type guard declaration. The negation of the predicate encoded in return expression `x instanceof B` [1]
needs to completely refine away the guard type `A` [2]. Consider using a one-sided type-guard (`implies x is T`). See 2.
in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:167:37
   167| function multi_return_ok(x: mixed): x is A {
                                            ^^^^^^

References:
   consistency.js:171:10
   171|   return x instanceof B; // error (negation) A ~> empty
                 ^^^^^^^^^^^^^^ [1]
   consistency.js:167:42
   167| function multi_return_ok(x: mixed): x is A {
                                                 ^ [2]


Error -------------------------------------------------------------------------------------------- consistency.js:174:51

Inconsistent type guard declaration because `A` [1] is incompatible with `B` [2]. The type of `x` [3] refined with the
predicate encoded in return expression `x instanceof A` [4] needs to be compatible with the guard type `B` [2]. See 1.
in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:174:51
   174| function multi_return_one_branch_error(x: mixed): x is B {
                                                          ^^^^^^

References:
   consistency.js:176:25
   176|     return x instanceof A; // error A ~> B
                                ^ [1]
   consistency.js:174:56
   174| function multi_return_one_branch_error(x: mixed): x is B {
                                                               ^ [2]
   consistency.js:174:40
   174| function multi_return_one_branch_error(x: mixed): x is B {
                                               ^ [3]
   consistency.js:176:12
   176|     return x instanceof A; // error A ~> B
                   ^^^^^^^^^^^^^^ [4]


Error -------------------------------------------------------------------------------------------- consistency.js:185:33

Cannot use type guard parameter `x`, because `x` [1] is reassigned in [2]. [function-predicate]

   consistency.js:185:33
   185| function havoc_error(x: mixed): x is B { // error 'x' is havoced
                                        ^

References:
   consistency.js:185:22
   185| function havoc_error(x: mixed): x is B { // error 'x' is havoced
                             ^ [1]
   consistency.js:189:3
   189|   y();
          ^^^ [2]


Error -------------------------------------------------------------------------------------------------- invalid.js:6:22

Cannot return boolean because boolean [1] is incompatible with constructor void return [2]. [incompatible-return]

   invalid.js:6:22
   6|   constructor(x: A): x is C { // error no type guard on constructor
                           ^^^^^^ [1]

References:
   invalid.js:6:20
   6|   constructor(x: A): x is C { // error no type guard on constructor
                         ^^^^^^^^ [2]


Error -------------------------------------------------------------------------------------------------- invalid.js:6:22

Cannot declare a type guard on a(n) constructor function. [function-predicate]

   6|   constructor(x: A): x is C { // error no type guard on constructor
                           ^^^^^^


Error -------------------------------------------------------------------------------------------------- invalid.js:9:12

Cannot declare a type guard on a(n) getter/setter function. [function-predicate]

   9|   get p(): this is C {  // error no type guard on getter
                 ^^^^^^^^^


Error ------------------------------------------------------------------------------------------------- invalid.js:12:16

Cannot declare a type guard on a(n) getter/setter function. [function-predicate]

   12|   set q(x: A): x is C {  // error no type guard on setter
                      ^^^^^^


Error ------------------------------------------------------------------------------------------------- invalid.js:17:31

Cannot declare a type guard [1] for function [2] because boolean [1] is incompatible with implicitly-returned undefined.
[incompatible-return]

   invalid.js:17:31
   17| function no_return(x: mixed): x is number {}
                                     ^^^^^^^^^^^ [1]

References:
   invalid.js:17:1
   17| function no_return(x: mixed): x is number {}
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- invalid.js:19:32

Cannot declare a type guard on a(n) generator function. [function-predicate]

   19| function *generator(x: mixed): x is number { // error
                                      ^^^^^^^^^^^


Error ------------------------------------------------------------------------------------------------- invalid.js:19:32

`Generator` [1] is incompatible with boolean [2]. [incompatible-type]

   invalid.js:19:32
     19| function *generator(x: mixed): x is number { // error
                                        ^^^^^^^^^^^ [2]

References:
   <BUILTINS>/core.js:1756:11
   1756| interface Generator<+Yield,+Return,-Next> {
                   ^^^^^^^^^ [1]


Error ------------------------------------------------------------------------------------------------- invalid.js:19:32

boolean [1], a primitive, cannot be used as a subtype of `$Iterable` [2]. You can wrap it in `new Boolean(...))` to turn
it into an object and attempt to use it as a subtype of an interface. [incompatible-type]

   invalid.js:19:32
     19| function *generator(x: mixed): x is number { // error
                                        ^^^^^^^^^^^ [1]

References:
   <BUILTINS>/core.js:1751:11
   1751| interface $Iterable<+Yield,+Return,-Next> {
                   ^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- invalid.js:20:10

Cannot return `(typeof x) == "number"` because `Generator` [1] is incompatible with boolean [2]. [incompatible-return]

   invalid.js:20:10
     20|   return typeof x == "number";
                  ^^^^^^^^^^^^^^^^^^^^

References:
   <BUILTINS>/core.js:1756:11
   1756| interface Generator<+Yield,+Return,-Next> {
                   ^^^^^^^^^ [1]
   invalid.js:19:32
     19| function *generator(x: mixed): x is number { // error
                                        ^^^^^^^^^^^ [2]


Error -------------------------------------------------------------------------------------------------- invalid.js:25:4

Cannot cast `x` to number because mixed [1] is incompatible with number [2]. [incompatible-cast]

   invalid.js:25:4
   25|   (x: number); // error no refining effect
          ^

References:
   invalid.js:23:16
   23| declare var x: mixed;
                      ^^^^^ [1]
   invalid.js:25:7
   25|   (x: number); // error no refining effect
             ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- invalid.js:28:33

Cannot declare a type guard on a(n) async function. [function-predicate]

   28| async function async(x: mixed): x is number { // error
                                       ^^^^^^^^^^^


Error ------------------------------------------------------------------------------------------------- invalid.js:29:10

Cannot return `(typeof x) == "number"` because `Promise` [1] is incompatible with boolean [2]. [incompatible-return]

   invalid.js:29:10
     29|   return typeof x == "number"
                  ^^^^^^^^^^^^^^^^^^^^

References:
   <BUILTINS>/core.js:1984:15
   1984| declare class Promise<+R = mixed> {
                       ^^^^^^^ [1]
   invalid.js:28:33
     28| async function async(x: mixed): x is number { // error
                                         ^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- invalid.js:33:12

Cannot declare a type guard on a(n) getter function. [function-predicate]

   33|   get p(): x is number;
                  ^^^^^^^^^^^


Error ------------------------------------------------------------------------------------------------- invalid.js:34:20

Cannot declare a type guard on a(n) setter function. [function-predicate]

   34|   set p(x: mixed): x is number;
                          ^^^^^^^^^^^


Error ------------------------------------------------------------------------------------------------- invalid.js:35:26

Cannot declare a type guard on a(n) constructor function. [function-predicate]

   35|   constructor(x: mixed): x is number;
                                ^^^^^^^^^^^


Error ------------------------------------------------------------------------------------------------- objects.js:14:14

Cannot use type guard parameter `x` [1] because at this return point it is written to in [2]. [function-predicate]

   objects.js:14:14
   14|       return typeof x === 'number'; // error write reaches return
                    ^^^^^^^^^^^^^^^^^^^^^

References:
   objects.js:12:24
   12|     invalid(x: mixed): x is number {
                              ^ [1]
   objects.js:13:7
   13|       x = 1;
             ^ [2]


Error -------------------------------------------------------------------------------------------------- objects.js:20:6

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   objects.js:20:6
   20|     (x: string); // error number ~> string
            ^

References:
   objects.js:6:23
    6|     m(x: mixed): x is number {
                             ^^^^^^ [1]
   objects.js:20:9
   20|     (x: string); // error number ~> string
               ^^^^^^ [2]


Error -------------------------------------------------------------------------------------------------- objects.js:23:6

Cannot cast `x` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   objects.js:23:6
   23|     (x: number); // error string ~> number
            ^

References:
   objects.js:9:23
    9|     f(x: mixed): x is string {
                             ^^^^^^ [1]
   objects.js:23:9
   23|     (x: number); // error string ~> number
               ^^^^^^ [2]


Error -------------------------------------------------------------------------------------------------- objects.js:29:4

Cannot cast `obj` to object type because number [1] is incompatible with string [2] in the type predicate of property
`m`. [incompatible-cast]

   objects.js:29:4
   29|   (obj: { // error number ~> string
          ^^^

References:
   objects.js:6:23
    6|     m(x: mixed): x is number {
                             ^^^^^^ [1]
   objects.js:30:23
   30|     m(x: mixed): x is string,
                             ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------- patterns_and_rest.js:1:54

A type guard parameter `b` [1] cannot reference pattern parameter `b` [2]. [function-predicate]

   patterns_and_rest.js:1:54
   1| function invalid_pattern_object({a: b}: {a: mixed}): b is string {
                                                           ^ [1]

References:
   patterns_and_rest.js:1:37
   1| function invalid_pattern_object({a: b}: {a: mixed}): b is string {
                                          ^ [2]


Error ---------------------------------------------------------------------------------------- patterns_and_rest.js:5:47

A type guard parameter `b` [1] cannot reference pattern parameter `b` [2]. [function-predicate]

   patterns_and_rest.js:5:47
   5| function invalid_pattern_array([b]: [mixed]): b is string {
                                                    ^ [1]

References:
   patterns_and_rest.js:5:33
   5| function invalid_pattern_array([b]: [mixed]): b is string {
                                      ^ [2]


Error ---------------------------------------------------------------------------------------- patterns_and_rest.js:9:44

A type guard parameter `a` [1] cannot reference rest parameter `a` [2]. [function-predicate]

   patterns_and_rest.js:9:44
   9| function invalid_rest(...a: Array<mixed>): a is string {
                                                 ^ [1]

References:
   patterns_and_rest.js:9:26
   9| function invalid_rest(...a: Array<mixed>): a is string {
                               ^ [2]


Error --------------------------------------------------------------------------------------- patterns_and_rest.js:13:57

A type guard parameter `a` [1] cannot reference rest parameter `a` [2]. [function-predicate]

   patterns_and_rest.js:13:57
   13| declare function invalid_rest_decl(...a: Array<mixed>): a is string;  // error a is in rest param
                                                               ^ [1]

References:
   patterns_and_rest.js:13:39
   13| declare function invalid_rest_decl(...a: Array<mixed>): a is string;  // error a is in rest param
                                             ^ [2]


Error --------------------------------------------------------------------------------------- patterns_and_rest.js:15:60

A type guard parameter `b` [1] cannot reference pattern parameter `b` [2]. [function-predicate]

   patterns_and_rest.js:15:60
   15| function invalid_pattern_compound({a: [b]}: {a: [mixed]}): b is string {
                                                                  ^ [1]

References:
   patterns_and_rest.js:15:40
   15| function invalid_pattern_compound({a: [b]}: {a: [mixed]}): b is string {
                                              ^ [2]


Error ---------------------------------------------------------------------------------------- patterns_and_rest.js:28:4

Cannot cast `x` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   patterns_and_rest.js:28:4
   28|   (x: number); // TODO error string ~> number
          ^

References:
   patterns_and_rest.js:21:78
   21| function valid_pattern({a}: {a: mixed}, x: mixed, ...r: Array<number>): x is string {
                                                                                    ^^^^^^ [1]
   patterns_and_rest.js:28:7
   28|   (x: number); // TODO error string ~> number
             ^^^^^^ [2]


Error --------------------------------------------------------------------------------------- patterns_and_rest.js:31:44

A type guard parameter `p` [1] cannot reference rest parameter `p` [2]. [function-predicate]

   patterns_and_rest.js:31:44
   31| type F = (x: mixed, ...p: Array<mixed>) => p is number; // error p is in rest param
                                                  ^ [1]

References:
   patterns_and_rest.js:31:24
   31| type F = (x: mixed, ...p: Array<mixed>) => p is number; // error p is in rest param
                              ^ [2]


Error ------------------------------------------------------------------------------------------------ refinement.js:7:6

Cannot cast `y` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   refinement.js:7:6
   7|     (y: string); // error number ~> string
           ^

References:
   refinement.js:2:26
   2|   fn: (x: mixed) => x is number,
                               ^^^^^^ [1]
   refinement.js:7:9
   7|     (y: string); // error number ~> string
              ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- refinement.js:20:6

Cannot cast `x1` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   refinement.js:20:6
   20|     (x1: number); // error string ~> number
            ^^

References:
   refinement.js:13:7
   13|   x1: string,
             ^^^^^^ [1]
   refinement.js:20:10
   20|     (x1: number); // error string ~> number
                ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- refinement.js:24:6

Cannot cast `x2` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   refinement.js:24:6
   24|     (x2: number); // error string ~> number
            ^^

References:
   refinement.js:14:7
   14|   x2: string | null,
             ^^^^^^ [1]
   refinement.js:24:10
   24|     (x2: number); // error string ~> number
                ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- refinement.js:28:6

Cannot cast `x3` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   refinement.js:28:6
   28|     (x3: number); // error string ~> number
            ^^

References:
   refinement.js:15:7
   15|   x3: string | void,
             ^^^^^^ [1]
   refinement.js:28:10
   28|     (x3: number); // error string ~> number
                ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- refinement.js:32:6

Cannot cast `x4` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   refinement.js:32:6
   32|     (x4: number); // error string ~> number
            ^^

References:
   refinement.js:16:8
   16|   x4: ?string,
              ^^^^^^ [1]
   refinement.js:32:10
   32|     (x4: number); // error string ~> number
                ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:47:35

Cannot call `arr.filter` because: [incompatible-call]
 - Either number [1] is incompatible with string [2] in the type predicate.
 - Or property `name` is missing in function [3] but exists in statics of `Boolean` [4].

   refinement.js:47:35
    47|   const arr2: Array<string> = arr.filter((x: mixed): x is number => { return typeof x === "number"; }); // error
                                          ^^^^^^

References:
   refinement.js:47:59
    47|   const arr2: Array<string> = arr.filter((x: mixed): x is number => { return typeof x === "number"; }); // error
                                                                  ^^^^^^ [1]
   refinement.js:47:21
    47|   const arr2: Array<string> = arr.filter((x: mixed): x is number => { return typeof x === "number"; }); // error
                            ^^^^^^ [2]
   refinement.js:47:42
    47|   const arr2: Array<string> = arr.filter((x: mixed): x is number => { return typeof x === "number"; }); // error
                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [3]
   <BUILTINS>/core.js:376:15
   376| declare class Boolean {
                      ^^^^^^^ [4]


Error ---------------------------------------------------------------------------------------------- refinement.js:48:35

Cannot call `arr.filter` because: [incompatible-call]
 - Either property `name` is missing in function [1] but exists in statics of `Boolean` [2].
 - Or function [1], a non-type-guard function, is incompatible with function type [3], which is a type-guard function.

   refinement.js:48:35
    48|   const arr3: Array<string> = arr.filter((x: mixed) => { return typeof x === "number"; }); // error no refinement
                                          ^^^^^^

References:
   refinement.js:48:42
    48|   const arr3: Array<string> = arr.filter((x: mixed) => { return typeof x === "number"; }); // error no refinement
                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]
   <BUILTINS>/core.js:376:15
   376| declare class Boolean {
                      ^^^^^^^ [2]
   refinement.js:40:35
    40|     filter<This, S: T>(predicate: (this: This, value: T, index: number, array: $ReadOnlyArray<T>) => value is S, thisArg?: This): Array<S>;
                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [3]


Error ----------------------------------------------------------------------------------------------- refinement.js:61:8

Cannot cast `x` to `B` because number [1] is incompatible with string [2] in property `foo`. [incompatible-cast]

   refinement.js:61:8
   61|       (x: B); // error A ~> B
              ^

References:
   refinement.js:53:29
   53|   type A = { tag: 'A', foo: number };
                                   ^^^^^^ [1]
   refinement.js:54:29
   54|   type B = { tag: 'B', foo: string };
                                   ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- refinement.js:61:8

Cannot cast `x` to `B` because string literal `A` [1] is incompatible with string literal `B` [2] in property `tag`.
[incompatible-cast]

   refinement.js:61:8
   61|       (x: B); // error A ~> B
              ^

References:
   refinement.js:53:19
   53|   type A = { tag: 'A', foo: number };
                         ^^^ [1]
   refinement.js:54:19
   54|   type B = { tag: 'B', foo: string };
                         ^^^ [2]


Error ----------------------------------------------------------------------------------------------- refinement.js:72:8

Cannot cast `x` to `A` because: [incompatible-cast]
 - Either string [1] is incompatible with number [2] in property `foo`.
 - Or inexact object type [3] is incompatible with exact `A` [4].

   refinement.js:72:8
   72|       (x: A); // error B & {tag_: 'A',...} ~> A
              ^

References:
   refinement.js:54:29
   54|   type B = { tag: 'B', foo: string };
                                   ^^^^^^ [1]
   refinement.js:53:29
   53|   type A = { tag: 'A', foo: number };
                                   ^^^^^^ [2]
   refinement.js:70:57
   70|   declare function invalid_sentinel_key(x: mixed): x is {tag_: 'A', ...};
                                                               ^^^^^^^^^^^^^^^^ [3]
   refinement.js:72:11
   72|       (x: A); // error B & {tag_: 'A',...} ~> A
                 ^ [4]


Error ----------------------------------------------------------------------------------------------- refinement.js:73:8

Cannot cast `x` to `B` because: [incompatible-cast]
 - Either number [1] is incompatible with string [2] in property `foo`.
 - Or inexact object type [3] is incompatible with exact `B` [4].

   refinement.js:73:8
   73|       (x: B); // error A & {tag_: 'A',...} ~> B
              ^

References:
   refinement.js:53:29
   53|   type A = { tag: 'A', foo: number };
                                   ^^^^^^ [1]
   refinement.js:54:29
   54|   type B = { tag: 'B', foo: string };
                                   ^^^^^^ [2]
   refinement.js:70:57
   70|   declare function invalid_sentinel_key(x: mixed): x is {tag_: 'A', ...};
                                                               ^^^^^^^^^^^^^^^^ [3]
   refinement.js:73:11
   73|       (x: B); // error A & {tag_: 'A',...} ~> B
                 ^ [4]


Error ----------------------------------------------------------------------------------------------- refinement.js:86:8

Cannot cast `x` to `B` because number [1] is incompatible with string [2] in property `foo`. [incompatible-cast]

   refinement.js:86:8
   86|       (x: B); // error A ~> B
              ^

References:
   refinement.js:78:39
   78|   type A = $ReadOnly<{ tag: 'A', foo: number }>;
                                             ^^^^^^ [1]
   refinement.js:79:39
   79|   type B = $ReadOnly<{ tag: 'B', foo: string }>;
                                             ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- refinement.js:86:8

Cannot cast `x` to `B` because string literal `A` [1] is incompatible with string literal `B` [2] in property `tag`.
[incompatible-cast]

   refinement.js:86:8
   86|       (x: B); // error A ~> B
              ^

References:
   refinement.js:78:29
   78|   type A = $ReadOnly<{ tag: 'A', foo: number }>;
                                   ^^^ [1]
   refinement.js:79:29
   79|   type B = $ReadOnly<{ tag: 'B', foo: string }>;
                                   ^^^ [2]


Error ----------------------------------------------------------------------------------------------- refinement.js:97:8

Cannot cast `x` to `A` because: [incompatible-cast]
 - Either string [1] is incompatible with number [2] in property `foo`.
 - Or inexact object type [3] is incompatible with exact object type [4].

   refinement.js:97:8
   97|       (x: A); // error B & {+tag_: 'A',...} ~> A
              ^

References:
   refinement.js:79:39
   79|   type B = $ReadOnly<{ tag: 'B', foo: string }>;
                                             ^^^^^^ [1]
   refinement.js:78:39
   78|   type A = $ReadOnly<{ tag: 'A', foo: number }>;
                                             ^^^^^^ [2]
   refinement.js:95:67
   95|   declare function invalid_sentinel_key(x: mixed): x is $ReadOnly<{tag_: 'A', ...}>;
                                                                         ^^^^^^^^^^^^^^^^ [3]
   refinement.js:97:11
   97|       (x: A); // error B & {+tag_: 'A',...} ~> A
                 ^ [4]


Error ----------------------------------------------------------------------------------------------- refinement.js:98:8

Cannot cast `x` to `B` because: [incompatible-cast]
 - Either number [1] is incompatible with string [2] in property `foo`.
 - Or inexact object type [3] is incompatible with exact object type [4].

   refinement.js:98:8
   98|       (x: B); // error A & {+tag_: 'A',...} ~> B
              ^

References:
   refinement.js:78:39
   78|   type A = $ReadOnly<{ tag: 'A', foo: number }>;
                                             ^^^^^^ [1]
   refinement.js:79:39
   79|   type B = $ReadOnly<{ tag: 'B', foo: string }>;
                                             ^^^^^^ [2]
   refinement.js:95:67
   95|   declare function invalid_sentinel_key(x: mixed): x is $ReadOnly<{tag_: 'A', ...}>;
                                                                         ^^^^^^^^^^^^^^^^ [3]
   refinement.js:98:11
   98|       (x: B); // error A & {+tag_: 'A',...} ~> B
                 ^ [4]


Error ---------------------------------------------------------------------------------------------- refinement.js:110:8

Cannot cast `x` to `A` because: [incompatible-cast]
 - Either string [1] is incompatible with number [2] in property `foo`.
 - Or inexact object type [3] is incompatible with exact object type [4].

   refinement.js:110:8
   110|       (x: A); // error B & {+tag: 'C', ...} ~> A
               ^

References:
   refinement.js:104:49
   104|   type B = $ReadOnly<{ tag1: 'B', tag2: 1, foo: string }>;
                                                        ^^^^^^ [1]
   refinement.js:103:49
   103|   type A = $ReadOnly<{ tag1: 'A', tag2: 1, foo: number }>;
                                                        ^^^^^^ [2]
   refinement.js:108:63
   108|   declare function unknown_sentinel(x: mixed): x is $ReadOnly<{tag: 'C', ...}>;
                                                                      ^^^^^^^^^^^^^^^ [3]
   refinement.js:110:11
   110|       (x: A); // error B & {+tag: 'C', ...} ~> A
                  ^ [4]


Error ---------------------------------------------------------------------------------------------- refinement.js:111:8

Cannot cast `x` to `B` because: [incompatible-cast]
 - Either number [1] is incompatible with string [2] in property `foo`.
 - Or inexact object type [3] is incompatible with exact object type [4].

   refinement.js:111:8
   111|       (x: B); // error A & {+tag: 'C', ...} ~> B
               ^

References:
   refinement.js:103:49
   103|   type A = $ReadOnly<{ tag1: 'A', tag2: 1, foo: number }>;
                                                        ^^^^^^ [1]
   refinement.js:104:49
   104|   type B = $ReadOnly<{ tag1: 'B', tag2: 1, foo: string }>;
                                                        ^^^^^^ [2]
   refinement.js:108:63
   108|   declare function unknown_sentinel(x: mixed): x is $ReadOnly<{tag: 'C', ...}>;
                                                                      ^^^^^^^^^^^^^^^ [3]
   refinement.js:111:11
   111|       (x: B); // error A & {+tag: 'C', ...} ~> B
                  ^ [4]


Error ---------------------------------------------------------------------------------------------- refinement.js:117:8

Cannot cast `x` to `B` because number [1] is incompatible with string [2] in property `foo`. [incompatible-cast]

   refinement.js:117:8
   117|       (x: B); // error A ~> B
               ^

References:
   refinement.js:103:49
   103|   type A = $ReadOnly<{ tag1: 'A', tag2: 1, foo: number }>;
                                                        ^^^^^^ [1]
   refinement.js:104:49
   104|   type B = $ReadOnly<{ tag1: 'B', tag2: 1, foo: string }>;
                                                        ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:117:8

Cannot cast `x` to `B` because string literal `A` [1] is incompatible with string literal `B` [2] in property `tag1`.
[incompatible-cast]

   refinement.js:117:8
   117|       (x: B); // error A ~> B
               ^

References:
   refinement.js:103:30
   103|   type A = $ReadOnly<{ tag1: 'A', tag2: 1, foo: number }>;
                                     ^^^ [1]
   refinement.js:104:30
   104|   type B = $ReadOnly<{ tag1: 'B', tag2: 1, foo: string }>;
                                     ^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:122:8

Cannot cast `x` to `A` because string [1] is incompatible with number [2] in property `foo`. [incompatible-cast]

   refinement.js:122:8
   122|       (x: A); // error B ~> A
               ^

References:
   refinement.js:104:49
   104|   type B = $ReadOnly<{ tag1: 'B', tag2: 1, foo: string }>;
                                                        ^^^^^^ [1]
   refinement.js:103:49
   103|   type A = $ReadOnly<{ tag1: 'A', tag2: 1, foo: number }>;
                                                        ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:122:8

Cannot cast `x` to `A` because string literal `B` [1] is incompatible with string literal `A` [2] in property `tag1`.
[incompatible-cast]

   refinement.js:122:8
   122|       (x: A); // error B ~> A
               ^

References:
   refinement.js:104:30
   104|   type B = $ReadOnly<{ tag1: 'B', tag2: 1, foo: string }>;
                                     ^^^ [1]
   refinement.js:103:30
   103|   type A = $ReadOnly<{ tag1: 'A', tag2: 1, foo: number }>;
                                     ^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:123:8

Cannot cast `x` to `B` because number [1] is incompatible with string [2] in property `foo`. [incompatible-cast]

   refinement.js:123:8
   123|       (x: B); // error A ~> B
               ^

References:
   refinement.js:103:49
   103|   type A = $ReadOnly<{ tag1: 'A', tag2: 1, foo: number }>;
                                                        ^^^^^^ [1]
   refinement.js:104:49
   104|   type B = $ReadOnly<{ tag1: 'B', tag2: 1, foo: string }>;
                                                        ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:123:8

Cannot cast `x` to `B` because string literal `A` [1] is incompatible with string literal `B` [2] in property `tag1`.
[incompatible-cast]

   refinement.js:123:8
   123|       (x: B); // error A ~> B
               ^

References:
   refinement.js:103:30
   103|   type A = $ReadOnly<{ tag1: 'A', tag2: 1, foo: number }>;
                                     ^^^ [1]
   refinement.js:104:30
   104|   type B = $ReadOnly<{ tag1: 'B', tag2: 1, foo: string }>;
                                     ^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:136:6

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   refinement.js:136:6
   136|     (x: string); // error number ~> string
             ^

References:
   refinement.js:132:18
   132|   declare var x: number | string;
                         ^^^^^^ [1]
   refinement.js:136:9
   136|     (x: string); // error number ~> string
                ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:139:6

Cannot cast `x` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   refinement.js:139:6
   139|     (x: number); // error string ~> number
             ^

References:
   refinement.js:132:27
   132|   declare var x: number | string;
                                  ^^^^^^ [1]
   refinement.js:139:9
   139|     (x: number); // error string ~> number
                ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:144:6

Cannot cast `x` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   refinement.js:144:6
   144|     (x: number); // error string ~> number
             ^

References:
   refinement.js:132:27
   132|   declare var x: number | string;
                                  ^^^^^^ [1]
   refinement.js:144:9
   144|     (x: number); // error string ~> number
                ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:146:6

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   refinement.js:146:6
   146|     (x: string); // error string ~> number
             ^

References:
   refinement.js:132:18
   132|   declare var x: number | string;
                         ^^^^^^ [1]
   refinement.js:146:9
   146|     (x: string); // error string ~> number
                ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:151:6

Cannot cast `x` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   refinement.js:151:6
   151|     (x: number); // error string ~> number
             ^

References:
   refinement.js:132:27
   132|   declare var x: number | string;
                                  ^^^^^^ [1]
   refinement.js:151:9
   151|     (x: number); // error string ~> number
                ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:152:6

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   refinement.js:152:6
   152|     (x: string); // error number ~> string
             ^

References:
   refinement.js:132:18
   132|   declare var x: number | string;
                         ^^^^^^ [1]
   refinement.js:152:9
   152|     (x: string); // error number ~> string
                ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:175:6

Cannot cast `maybeNumber` to empty because number [1] is incompatible with empty [2]. [incompatible-cast]

   refinement.js:175:6
   175|     (maybeNumber: empty); // error number ~> empty
             ^^^^^^^^^^^

References:
   refinement.js:172:28
   172|   declare var maybeNumber: number;
                                   ^^^^^^ [1]
   refinement.js:175:19
   175|     (maybeNumber: empty); // error number ~> empty
                          ^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:185:6

Cannot cast `anyVal` to empty because number [1] is incompatible with empty [2]. [incompatible-cast]

   refinement.js:185:6
   185|     (anyVal: empty); // error number ~> empty
             ^^^^^^

References:
   refinement.js:180:53
   180|   declare function isNumber(value: mixed): value is number;
                                                            ^^^^^^ [1]
   refinement.js:185:14
   185|     (anyVal: empty); // error number ~> empty
                     ^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:202:6

Cannot cast `x` to empty because `$FbtResultBase` [1] is incompatible with empty [2]. [incompatible-cast]

   refinement.js:202:6
   202|     (x: empty); // error Fbt ~> empty
             ^

References:
   refinement.js:198:25
   198|   declare var x: void | Fbt;
                                ^^^ [1]
   refinement.js:202:9
   202|     (x: empty); // error Fbt ~> empty
                ^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:202:6

Cannot cast `x` to empty because `FbtString` [1] is incompatible with empty [2]. [incompatible-cast]

   refinement.js:202:6
   202|     (x: empty); // error Fbt ~> empty
             ^

References:
   refinement.js:198:25
   198|   declare var x: void | Fbt;
                                ^^^ [1]
   refinement.js:202:9
   202|     (x: empty); // error Fbt ~> empty
                ^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:202:6

Cannot cast `x` to empty because string [1] is incompatible with empty [2]. [incompatible-cast]

   refinement.js:202:6
   202|     (x: empty); // error Fbt ~> empty
             ^

References:
   refinement.js:198:25
   198|   declare var x: void | Fbt;
                                ^^^ [1]
   refinement.js:202:9
   202|     (x: empty); // error Fbt ~> empty
                ^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:214:6

Cannot cast `x` to `OpaqueOrString` because: [incompatible-cast]
 - Either string [1] is incompatible with `OpaqueT` [2].
 - Or `OpaqueT` [1] is incompatible with string [3].

   refinement.js:214:6
   214|     (x: OpaqueOrString); // TODO okay, currently imported opaque type is not filtered because it's underlying type is opaque to type-guard filtering
             ^

References:
   refinement.js:211:25
   211|   declare var x: void | OpaqueOrString;
                                ^^^^^^^^^^^^^^ [1]
   opaque_exports.js:17:30
    17| export type OpaqueOrString = OpaqueT | string;
                                     ^^^^^^^ [2]
   opaque_exports.js:17:40
    17| export type OpaqueOrString = OpaqueT | string;
                                               ^^^^^^ [3]


Error ---------------------------------------------------------------------------------------------- refinement.js:225:6

Cannot cast `x` to empty because string [1] is incompatible with empty [2]. [incompatible-cast]

   refinement.js:225:6
   225|     (x: empty); // error string ~> empty
             ^

References:
   refinement.js:221:25
   221|   declare var x: void | string | any;
                                ^^^^^^ [1]
   refinement.js:225:9
   225|     (x: empty); // error string ~> empty
                ^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:235:6

Cannot cast `value` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   refinement.js:235:6
   235|     (value: string); // error number ~> string
             ^^^^^

References:
   refinement.js:230:10
   230|   value: number | string,
                 ^^^^^^ [1]
   refinement.js:235:13
   235|     (value: string); // error number ~> string
                    ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:237:6

Cannot cast `value` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   refinement.js:237:6
   237|     (value: string); // error number ~> string
             ^^^^^

References:
   refinement.js:230:10
   230|   value: number | string,
                 ^^^^^^ [1]
   refinement.js:237:13
   237|     (value: string); // error number ~> string
                    ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:238:6

Cannot cast `value` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   refinement.js:238:6
   238|     (value: number); // error string ~> number
             ^^^^^

References:
   refinement.js:230:19
   230|   value: number | string,
                          ^^^^^^ [1]
   refinement.js:238:13
   238|     (value: number); // error string ~> number
                    ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:249:7

Cannot call `arr.filter` because: [incompatible-call]
 - Either number [1] is incompatible with string [2] in the type predicate.
 - Or property `name` is missing in statics of function type [3] but exists in statics of `Boolean` [4].

   refinement.js:249:7
   249|   arr.filter(fn) as Array<string>; // error number ~> string
              ^^^^^^

References:
   refinement.js:231:34
   231|   fn: (x: mixed) => implies x is number,
                                         ^^^^^^ [1]
   refinement.js:249:27
   249|   arr.filter(fn) as Array<string>; // error number ~> string
                                  ^^^^^^ [2]
   refinement.js:231:7
   231|   fn: (x: mixed) => implies x is number,
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [3]
   <BUILTINS>/core.js:376:15
   376| declare class Boolean {
                      ^^^^^^^ [4]


Error --------------------------------------------------------------------------------------------- refinement.js:253:10

Cannot call `ro_arr.filter` because: [incompatible-call]
 - Either number [1] is incompatible with string [2] in the type predicate.
 - Or property `name` is missing in statics of function type [3] but exists in statics of `Boolean` [4].

   refinement.js:253:10
   253|   ro_arr.filter(fn) as Array<string>; // error number ~> string
                 ^^^^^^

References:
   refinement.js:231:34
   231|   fn: (x: mixed) => implies x is number,
                                         ^^^^^^ [1]
   refinement.js:253:30
   253|   ro_arr.filter(fn) as Array<string>; // error number ~> string
                                     ^^^^^^ [2]
   refinement.js:231:7
   231|   fn: (x: mixed) => implies x is number,
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [3]
   <BUILTINS>/core.js:376:15
   376| declare class Boolean {
                      ^^^^^^^ [4]


Error --------------------------------------------------------------------------------------------- refinement.js:257:10

Cannot call `rw_arr.filter` because: [incompatible-call]
 - Either number [1] is incompatible with string [2] in the type predicate.
 - Or property `name` is missing in statics of function type [3] but exists in statics of `Boolean` [4].

   refinement.js:257:10
   257|   rw_arr.filter(fn) as Array<string>; // error number ~> string
                 ^^^^^^

References:
   refinement.js:231:34
   231|   fn: (x: mixed) => implies x is number,
                                         ^^^^^^ [1]
   refinement.js:257:30
   257|   rw_arr.filter(fn) as Array<string>; // error number ~> string
                                     ^^^^^^ [2]
   refinement.js:231:7
   231|   fn: (x: mixed) => implies x is number,
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [3]
   <BUILTINS>/core.js:376:15
   376| declare class Boolean {
                      ^^^^^^^ [4]


Error ---------------------------------------------------------------------------------------------- refinement.js:275:7

Cannot cast `item` to `TypeA` because string literal `TypeB` [1] is incompatible with string literal `TypeA` [2] in
property `type`. [incompatible-cast]

   refinement.js:275:7
   275|       item as TypeA; // error
              ^^^^

References:
   refinement.js:262:34
   262|   type TypeB = $ReadOnly<{ type: 'TypeB', id: string }>;
                                         ^^^^^^^ [1]
   refinement.js:261:34
   261|   type TypeA = $ReadOnly<{ type: 'TypeA', id: string }>;
                                         ^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:276:7

Cannot cast `item` to `TypeB` because string literal `TypeA` [1] is incompatible with string literal `TypeB` [2] in
property `type`. [incompatible-cast]

   refinement.js:276:7
   276|       item as TypeB; // error
              ^^^^

References:
   refinement.js:261:34
   261|   type TypeA = $ReadOnly<{ type: 'TypeA', id: string }>;
                                         ^^^^^^^ [1]
   refinement.js:262:34
   262|   type TypeB = $ReadOnly<{ type: 'TypeB', id: string }>;
                                         ^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:277:7

Cannot cast `item` to `TypeC` because string literal `TypeA` [1] is incompatible with string literal `TypeC` [2] in
property `type`. [incompatible-cast]

   refinement.js:277:7
   277|       item as TypeC; // error
              ^^^^

References:
   refinement.js:261:34
   261|   type TypeA = $ReadOnly<{ type: 'TypeA', id: string }>;
                                         ^^^^^^^ [1]
   refinement.js:263:34
   263|   type TypeC = $ReadOnly<{ type: 'TypeC', id: string }>;
                                         ^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:277:7

Cannot cast `item` to `TypeC` because string literal `TypeB` [1] is incompatible with string literal `TypeC` [2] in
property `type`. [incompatible-cast]

   refinement.js:277:7
   277|       item as TypeC; // error
              ^^^^

References:
   refinement.js:262:34
   262|   type TypeB = $ReadOnly<{ type: 'TypeB', id: string }>;
                                         ^^^^^^^ [1]
   refinement.js:263:34
   263|   type TypeC = $ReadOnly<{ type: 'TypeC', id: string }>;
                                         ^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:280:7

Cannot cast `item` to `SpecialTypes` because: [incompatible-cast]
 - Either string literal `TypeC` [1] is incompatible with string literal `TypeA` [2] in property `type`.
 - Or string literal `TypeC` [1] is incompatible with string literal `TypeB` [3] in property `type`.

   refinement.js:280:7
   280|       item as SpecialTypes; // error TypeC ~> SpecialType
              ^^^^

References:
   refinement.js:263:34
   263|   type TypeC = $ReadOnly<{ type: 'TypeC', id: string }>;
                                         ^^^^^^^ [1]
   refinement.js:261:34
   261|   type TypeA = $ReadOnly<{ type: 'TypeA', id: string }>;
                                         ^^^^^^^ [2]
   refinement.js:262:34
   262|   type TypeB = $ReadOnly<{ type: 'TypeB', id: string }>;
                                         ^^^^^^^ [3]


Error ---------------------------------------------------------------------------------------------- refinement.js:282:7

Cannot cast `item` to `TypeA` because string literal `TypeC` [1] is incompatible with string literal `TypeA` [2] in
property `type`. [incompatible-cast]

   refinement.js:282:7
   282|       item as TypeA; // error
              ^^^^

References:
   refinement.js:263:34
   263|   type TypeC = $ReadOnly<{ type: 'TypeC', id: string }>;
                                         ^^^^^^^ [1]
   refinement.js:261:34
   261|   type TypeA = $ReadOnly<{ type: 'TypeA', id: string }>;
                                         ^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:283:7

Cannot cast `item` to `TypeB` because string literal `TypeC` [1] is incompatible with string literal `TypeB` [2] in
property `type`. [incompatible-cast]

   refinement.js:283:7
   283|       item as TypeB; // error
              ^^^^

References:
   refinement.js:263:34
   263|   type TypeC = $ReadOnly<{ type: 'TypeC', id: string }>;
                                         ^^^^^^^ [1]
   refinement.js:262:34
   262|   type TypeB = $ReadOnly<{ type: 'TypeB', id: string }>;
                                         ^^^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- subst.js:10:15

Cannot assign `funA(...)` to `x2` because `A` [1] is incompatible with `B` [2]. [incompatible-type]

   subst.js:10:15
   10| const x2: B = funA(isA); // error A ~> B
                     ^^^^^^^^^

References:
   subst.js:4:38
    4| declare function isA(x: mixed): x is A;
                                            ^ [1]
   subst.js:10:11
   10| const x2: B = funA(isA); // error A ~> B
                 ^ [2]


Error ---------------------------------------------------------------------------------------------------- subst.js:15:4

Cannot cast `input` to `B` because `A` [1] is incompatible with `B` [2]. [incompatible-cast]

   subst.js:15:4
   15|   (input: B); // error A ~> B
          ^^^^^

References:
   subst.js:4:38
    4| declare function isA(x: mixed): x is A;
                                            ^ [1]
   subst.js:15:11
   15|   (input: B); // error A ~> B
                 ^ [2]


Error ------------------------------------------------------------------------------------------------ subtyping.js:6:10

Cannot return `f` because type guard parameter `x` [1] does not appear in the same position as type guard parameter
`x` [2] in the type predicate. [function-predicate]

   subtyping.js:6:10
   6|   return f; // error 'x' is not in the same position as 'y'
               ^

References:
   subtyping.js:5:56
   5| function non_matching_prams(f: (x: mixed, y: mixed) => x is number): (y: mixed, x: mixed) => x is number {
                                                             ^ [1]
   subtyping.js:5:94
   5| function non_matching_prams(f: (x: mixed, y: mixed) => x is number): (y: mixed, x: mixed) => x is number {
                                                                                                   ^ [2]


Error ----------------------------------------------------------------------------------------------- subtyping.js:10:10

Cannot return `f` because function type [1], a non-type-guard function, is incompatible with function type [2], which is
a type-guard function. [function-predicate]

   subtyping.js:10:10
   10|   return f; // error non type predicate
                ^

References:
   subtyping.js:9:42
    9| function non_type_guard_to_type_guard(f: (x: mixed) => boolean): (x: mixed) => x is number {
                                                ^^^^^^^^^^^^^^^^^^^^^ [1]
   subtyping.js:9:66
    9| function non_type_guard_to_type_guard(f: (x: mixed) => boolean): (x: mixed) => x is number {
                                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- subtyping.js:28:10

Cannot return `f` because `A` [1] is incompatible with `B` [2] in the type predicate. [incompatible-return]

   subtyping.js:28:10
   28|   return f; // error A ~> B
                ^

References:
   subtyping.js:27:61
   27| function type_guard_subtyping_error_1(f: (x: mixed) => x is A): (x: mixed) => x is B {
                                                                   ^ [1]
   subtyping.js:27:84
   27| function type_guard_subtyping_error_1(f: (x: mixed) => x is A): (x: mixed) => x is B {
                                                                                          ^ [2]


Error ----------------------------------------------------------------------------------------------- subtyping.js:32:10

Cannot return `f` because `A` [1] is incompatible with `C` [2] in the type predicate. [incompatible-return]

   subtyping.js:32:10
   32|   return f; // error A ~> C
                ^

References:
   subtyping.js:31:61
   31| function type_guard_subtyping_error_2(f: (x: mixed) => x is A): (x: mixed) => x is C {
                                                                   ^ [1]
   subtyping.js:31:84
   31| function type_guard_subtyping_error_2(f: (x: mixed) => x is A): (x: mixed) => x is C {
                                                                                          ^ [2]


Error ----------------------------------------------------------------------------------------------- subtyping.js:36:10

Cannot return `f` because read-only array type [1] is incompatible with array type [2] in the type predicate.
[incompatible-return]

   subtyping.js:36:10
   36|   return f; // error
                ^

References:
   subtyping.js:35:64
   35| function type_guard_subtyping_error_3(f: <A>(x: mixed) => x is $ReadOnlyArray<A>): <B>(x: mixed) => x is Array<B> {
                                                                      ^^^^^^^^^^^^^^^^^ [1]
   subtyping.js:35:106
   35| function type_guard_subtyping_error_3(f: <A>(x: mixed) => x is $ReadOnlyArray<A>): <B>(x: mixed) => x is Array<B> {
                                                                                                                ^^^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- subtyping.js:48:10

Cannot return `f` because one-sided type guard [1] is incompatible with default type guard [2]. [function-predicate]

   subtyping.js:48:10
   48|   return f; // error
                ^

References:
   subtyping.js:47:64
   47| function type_guard_subtyping_one_sided_error(f: (x: mixed) => implies x is A): (x: mixed) => x is A {
                                                                      ^^^^^^^^^^^^^^ [1]
   subtyping.js:47:95
   47| function type_guard_subtyping_one_sided_error(f: (x: mixed) => implies x is A): (x: mixed) => x is A {
                                                                                                     ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- subtyping.js:58:10

Cannot return `f` because `A` [1] is incompatible with `C` [2] in the type predicate of array element. Arrays are
invariantly typed. See
https://flow.org/en/docs/faq/#why-cant-i-pass-an-arraystring-to-a-function-that-takes-an-arraystring-number.
[incompatible-return]

   subtyping.js:58:10
   58|   return f; // error C ~ A
                ^

References:
   subtyping.js:57:92
   57| function type_guard_unif_error_1(f: Array<(x: mixed) => x is C>): Array<(x: mixed) => x is A> {
                                                                                                  ^ [1]
   subtyping.js:57:62
   57| function type_guard_unif_error_1(f: Array<(x: mixed) => x is C>): Array<(x: mixed) => x is A> {
                                                                    ^ [2]


Error ----------------------------------------------------------------------------------------------- subtyping.js:62:10

Cannot return `f` because `A` [1] is incompatible with `B` [2] in the type predicate of array element.
[incompatible-return]

   subtyping.js:62:10
   62|   return f; // errors A ~> B, B ~> A
                ^

References:
   subtyping.js:61:62
   61| function type_guard_unif_error_2(f: Array<(x: mixed) => x is A>): Array<(x: mixed) => x is B> {
                                                                    ^ [1]
   subtyping.js:61:92
   61| function type_guard_unif_error_2(f: Array<(x: mixed) => x is A>): Array<(x: mixed) => x is B> {
                                                                                                  ^ [2]


Error ----------------------------------------------------------------------------------------------- subtyping.js:66:10

Cannot return `f` because `A` [1] is incompatible with `C` [2] in the type predicate of array element.
[incompatible-return]

   subtyping.js:66:10
   66|   return f; // error A ~> C
                ^

References:
   subtyping.js:65:62
   65| function type_guard_unif_error_3(f: Array<(x: mixed) => x is A>): Array<(x: mixed) => x is C> {
                                                                    ^ [1]
   subtyping.js:65:92
   65| function type_guard_unif_error_3(f: Array<(x: mixed) => x is A>): Array<(x: mixed) => x is C> {
                                                                                                  ^ [2]


Error ----------------------------------------------------------------------------------------------- subtyping.js:74:10

Cannot return `f` because one-sided type guard [1] is incompatible with default type guard [2] in array element. Arrays
are invariantly typed. See
https://flow.org/en/docs/faq/#why-cant-i-pass-an-arraystring-to-a-function-that-takes-an-arraystring-number.
[function-predicate]

   subtyping.js:74:10
   74|   return f; // error
                ^

References:
   subtyping.js:73:95
   73| function type_guard_unif_one_sided_error(f: Array<(x: mixed) => x is A>): Array<(x: mixed) => implies x is A> {
                                                                                                     ^^^^^^^^^^^^^^ [1]
   subtyping.js:73:65
   73| function type_guard_unif_one_sided_error(f: Array<(x: mixed) => x is A>): Array<(x: mixed) => implies x is A> {
                                                                       ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------- tuple_refinement.js:11:7

Cannot cast `x` to `B` because string literal `A` [1] is incompatible with string literal `B` [2] in index 0.
[incompatible-cast]

   tuple_refinement.js:11:7
   11|       x as B; // ERROR: A ~> B
             ^

References:
   tuple_refinement.js:2:11
    2| type A = ['A', number];
                 ^^^ [1]
   tuple_refinement.js:3:11
    3| type B = ['B', string];
                 ^^^ [2]


Error ----------------------------------------------------------------------------------------- tuple_refinement.js:11:7

Cannot cast `x` to `B` because number [1] is incompatible with string [2] in index 1. [incompatible-cast]

   tuple_refinement.js:11:7
   11|       x as B; // ERROR: A ~> B
             ^

References:
   tuple_refinement.js:2:16
    2| type A = ['A', number];
                      ^^^^^^ [1]
   tuple_refinement.js:3:16
    3| type B = ['B', string];
                      ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------- tuple_refinement.js:31:7

Cannot cast `x` to `ROB` because string literal `A` [1] is incompatible with string literal `B` [2] in index 0.
[incompatible-cast]

   tuple_refinement.js:31:7
   31|       x as ROB; // ERROR: A ~> B
             ^

References:
   tuple_refinement.js:22:23
   22| type ROA = $ReadOnly<['A', number]>;
                             ^^^ [1]
   tuple_refinement.js:23:23
   23| type ROB = $ReadOnly<['B', string]>;
                             ^^^ [2]


Error ----------------------------------------------------------------------------------------- tuple_refinement.js:31:7

Cannot cast `x` to `ROB` because number [1] is incompatible with string [2] in index 1. [incompatible-cast]

   tuple_refinement.js:31:7
   31|       x as ROB; // ERROR: A ~> B
             ^

References:
   tuple_refinement.js:22:28
   22| type ROA = $ReadOnly<['A', number]>;
                                  ^^^^^^ [1]
   tuple_refinement.js:23:28
   23| type ROB = $ReadOnly<['B', string]>;
                                  ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------- tuple_refinement.js:51:7

Cannot cast `x` to `MTB` because string literal `A` [1] is incompatible with string literal `B` [2] in index 0.
[incompatible-cast]

   tuple_refinement.js:51:7
   51|       x as MTB; // ERROR: A ~> B
             ^

References:
   tuple_refinement.js:42:23
   42| type MTA = $ReadOnly<['A', 1, number]>;
                             ^^^ [1]
   tuple_refinement.js:43:23
   43| type MTB = $ReadOnly<['B', 1, string]>;
                             ^^^ [2]


Error ----------------------------------------------------------------------------------------- tuple_refinement.js:51:7

Cannot cast `x` to `MTB` because number [1] is incompatible with string [2] in index 2. [incompatible-cast]

   tuple_refinement.js:51:7
   51|       x as MTB; // ERROR: A ~> B
             ^

References:
   tuple_refinement.js:42:31
   42| type MTA = $ReadOnly<['A', 1, number]>;
                                     ^^^^^^ [1]
   tuple_refinement.js:43:31
   43| type MTB = $ReadOnly<['B', 1, string]>;
                                     ^^^^^^ [2]


Error -------------------------------------------------------------------------------- type_guard_compatibility.js:15:30

Cannot use `B` [1] as type prediate for parameter `x` because `B` [1] is incompatible with `A` [2]. A user defined type
guard needs to be compatible with its parameter's type. [incompatible-type-guard]

   type_guard_compatibility.js:15:30
   15| function error_1(x: A): x is B { // error B ~> A
                                    ^ [1]

References:
   type_guard_compatibility.js:15:21
   15| function error_1(x: A): x is B { // error B ~> A
                           ^ [2]


Error -------------------------------------------------------------------------------- type_guard_compatibility.js:19:59

Cannot use array type [1] as type prediate for parameter `x` because mixed [2] is incompatible with `X` [3] in array
element. A user defined type guard needs to be compatible with its parameter's type. [incompatible-type-guard]

   type_guard_compatibility.js:19:59
   19| declare function error_poly_1<X>(x: Array<X>): x is Array<mixed>; // error mixed ~> X
                                                                 ^^^^^ [2]

References:
   type_guard_compatibility.js:19:53
   19| declare function error_poly_1<X>(x: Array<X>): x is Array<mixed>; // error mixed ~> X
                                                           ^^^^^^^^^^^^ [1]
   type_guard_compatibility.js:19:43
   19| declare function error_poly_1<X>(x: Array<X>): x is Array<mixed>; // error mixed ~> X
                                                 ^ [3]


Error -------------------------------------------------------------------------------- type_guard_compatibility.js:27:33

Cannot use `B` [1] as type prediate for parameter `x` because `B` [1] is incompatible with `A` [2]. A user defined type
guard needs to be compatible with its parameter's type. [incompatible-type-guard]

   type_guard_compatibility.js:27:33
   27| type F_error_1 = (x: A) => x is B; // error B ~> A
                                       ^ [1]

References:
   type_guard_compatibility.js:27:22
   27| type F_error_1 = (x: A) => x is B; // error B ~> A
                            ^ [2]


Error -------------------------------------------------------------------------------- type_guard_compatibility.js:29:54

Cannot use array type [1] as type prediate for parameter `x` because mixed [2] is incompatible with `X` [3] in array
element. A user defined type guard needs to be compatible with its parameter's type. [incompatible-type-guard]

   type_guard_compatibility.js:29:54
   29| type F_error_poly_1 = <X>(x: Array<X>) => x is Array<mixed>; // error mixed ~> X
                                                            ^^^^^ [2]

References:
   type_guard_compatibility.js:29:48
   29| type F_error_poly_1 = <X>(x: Array<X>) => x is Array<mixed>; // error mixed ~> X
                                                      ^^^^^^^^^^^^ [1]
   type_guard_compatibility.js:29:36
   29| type F_error_poly_1 = <X>(x: Array<X>) => x is Array<mixed>; // error mixed ~> X
                                          ^ [3]


Error -------------------------------------------------------------------------------- type_guard_compatibility.js:30:54

Cannot use array type [1] as type prediate for parameter `x` because mixed [2] is incompatible with `X` [3] in array
element. A user defined type guard needs to be compatible with its parameter's type. [incompatible-type-guard]

   type_guard_compatibility.js:30:54
   30| type F_error_poly_2<X> = (x: Array<X>) => x is Array<mixed>; // error mixed ~> X
                                                            ^^^^^ [2]

References:
   type_guard_compatibility.js:30:48
   30| type F_error_poly_2<X> = (x: Array<X>) => x is Array<mixed>; // error mixed ~> X
                                                      ^^^^^^^^^^^^ [1]
   type_guard_compatibility.js:30:36
   30| type F_error_poly_2<X> = (x: Array<X>) => x is Array<mixed>; // error mixed ~> X
                                          ^ [3]


Error -------------------------------------------------------------------------------------------------- unbound.js:1:23

Cannot find type guard parameter `x` [1] in the parameters of this function (type). [function-predicate]

   1| function no_params(): x is number { // error x unbound
                            ^ [1]


Error -------------------------------------------------------------------------------------------------- unbound.js:5:47

Cannot find type guard parameter `y` [1] in the parameters of this function (type). [function-predicate]

   5| function unbound_type_guard_param(x: number): y is number {  // error y is not a param
                                                    ^ [1]


Error -------------------------------------------------------------------------------------------------- unbound.js:9:23

Cannot find type guard parameter `x` [1] in the parameters of this function (type). [function-predicate]

   9| type No_param = () => x is number; // error x unbound
                            ^ [1]


Error ------------------------------------------------------------------------------------------------- unbound.js:11:37

Cannot find type guard parameter `x` [1] in the parameters of this function (type). [function-predicate]

   11| type Unbound_param = (y: number) => x is number; // error x unbound
                                           ^ [1]


Error ------------------------------------------------------------------------------------------------- unbound.js:13:34

Cannot find type guard parameter `x` [1] in the parameters of this function (type). [function-predicate]

   13| type No_param_name = (number) => x is number; // error x unbound
                                        ^ [1]



Found 158 errors

Only showing the most relevant union/intersection branches.
To see all branches, re-run Flow with --show-all-branches
