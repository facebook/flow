Error --------------------------------------------------------------------------------------------- class_imports.js:8:4

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   class_imports.js:8:4
   8|   (x: string); // error number ~> string
         ^

References:
   class_exports.js:2:21
   2|   m(x: mixed): x is number {
                          ^^^^^^ [1]
   class_imports.js:8:7
   8|   (x: string); // error number ~> string
            ^^^^^^ [2]


Error -------------------------------------------------------------------------------------------- class_imports.js:13:4

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   class_imports.js:13:4
   13|   (x: string); // error number ~> string
          ^

References:
   class_exports.js:5:30
    5|   os(x: mixed): implies x is number {
                                    ^^^^^^ [1]
   class_imports.js:13:7
   13|   (x: string); // error number ~> string
             ^^^^^^ [2]


Error -------------------------------------------------------------------------------------------- class_imports.js:19:4

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   class_imports.js:19:4
   19|   (x: string); // error number ~> string
          ^

References:
   class_exports.js:11:21
   11|   m(x: mixed): x is number;
                           ^^^^^^ [1]
   class_imports.js:19:7
   19|   (x: string); // error number ~> string
             ^^^^^^ [2]


Error -------------------------------------------------------------------------------------------- class_imports.js:24:4

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   class_imports.js:24:4
   24|   (x: string); // error number ~> string
          ^

References:
   class_exports.js:12:30
   12|   os(x: mixed): implies x is number;
                                    ^^^^^^ [1]
   class_imports.js:24:7
   24|   (x: string); // error number ~> string
             ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- classes.js:15:14

Cannot use type guard parameter `x` [1] because at this return point it is written to in [2]. [function-predicate]

   classes.js:15:14
   15|       return typeof x === 'number'; // error param write reaching this return
                    ^^^^^^^^^^^^^^^^^^^^^

References:
   classes.js:13:25
   13|     invalid1(x: mixed): x is number {
                               ^ [1]
   classes.js:14:7
   14|       x = 1;
             ^ [2]


Error ------------------------------------------------------------------------------------------------- classes.js:18:25

Cannot find type guard parameter `y` [1] in the parameters of this function (type). [function-predicate]

   18|     invalid2(x: mixed): y is number { // error param missing
                               ^ [1]


Error ------------------------------------------------------------------------------------------------- classes.js:23:14

Cannot return `(typeof x) === 'number'` because number [1] is incompatible with string [2]. The type of `x` [3] at the
return expression `(typeof x) === 'number'` [1] needs to be compatible with the guard type string [2]. See 1. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   classes.js:23:14
   23|       return typeof x === 'number'; // error number ~> string
                    ^^^^^^^^^^^^^^^^^^^^^ [1]

References:
   classes.js:22:30
   22|     invalid3(x: mixed): x is string {
                                    ^^^^^^ [2]
   classes.js:22:14
   22|     invalid3(x: mixed): x is string {
                    ^ [3]


Error ------------------------------------------------------------------------------------------------- classes.js:23:14

Cannot return `(typeof x) === 'number'` because the negation of the predicate encoded in this expression needs to
completely refine away the guard type string [1]. Consider using a one-sided type-guard (`implies x is T`). See 2. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   classes.js:23:14
   23|       return typeof x === 'number'; // error number ~> string
                    ^^^^^^^^^^^^^^^^^^^^^

References:
   classes.js:22:30
   22|     invalid3(x: mixed): x is string {
                                    ^^^^^^ [1]


Error -------------------------------------------------------------------------------------------------- classes.js:30:6

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   classes.js:30:6
   30|     (x: string); // error number ~> string
            ^

References:
   classes.js:5:23
    5|     m(x: mixed): x is number {
                             ^^^^^^ [1]
   classes.js:30:9
   30|     (x: string); // error number ~> string
               ^^^^^^ [2]


Error -------------------------------------------------------------------------------------------------- classes.js:33:6

Cannot cast `x` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   classes.js:33:6
   33|     (x: number); // error string ~> number
            ^

References:
   classes.js:9:30
    9|     static s(x: mixed): x is string {
                                    ^^^^^^ [1]
   classes.js:33:9
   33|     (x: number); // error string ~> number
               ^^^^^^ [2]


Error -------------------------------------------------------------------------------------------------- classes.js:40:5

Cannot extend `C` [1] with `D1` because function [2], a non-type-guard function, is incompatible with function [3],
which is a type-guard function in property `m`. [function-predicate]

   classes.js:40:5
           v----------------------------------------------------
   40|     m(x: mixed): boolean { // error extends non-predicate
   41|       return true;
   42|     }
           ^ [2]

References:
   classes.js:39:20
   39|   class D1 extends C {
                          ^ [1]
   classes.js:5:5
           v-------------------------
    5|     m(x: mixed): x is number {
    6|       return typeof x === 'number';
    7|     }
           ^ [3]


Error ------------------------------------------------------------------------------------------------- classes.js:46:23

Cannot extend `C` [1] with `D2` because mixed [2] is incompatible with number [3] in the type predicate of property `m`.
[incompatible-extend]

   classes.js:46:23
   46|     m(x: mixed): x is mixed { // error extends
                             ^^^^^ [2]

References:
   classes.js:45:20
   45|   class D2 extends C {
                          ^ [1]
   classes.js:5:23
    5|     m(x: mixed): x is number {
                             ^^^^^^ [3]


Error ------------------------------------------------------------------------------------------------- classes.js:52:14

Cannot return `true` because mixed [1] is incompatible with number [2]. The type of `x` [3] at the return expression
`true` [4] needs to be compatible with the guard type number [2]. See 1. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   classes.js:52:14
   52|       return true; // error mixed ~> number
                    ^^^^ [4]

References:
   classes.js:51:10
   51|     m(x: mixed): x is number {
                ^^^^^ [1]
   classes.js:51:23
   51|     m(x: mixed): x is number {
                             ^^^^^^ [2]
   classes.js:51:7
   51|     m(x: mixed): x is number {
             ^ [3]


Error ------------------------------------------------------------------------------------------------- classes.js:67:23

Cannot implement `I` [1] with `E1` because number [2] is incompatible with string [3] in the type predicate of property
`n`. [incompatible-type]

   classes.js:67:23
   67|     n(x: mixed): x is number { // error number ~> string
                             ^^^^^^ [2]

References:
   classes.js:63:23
   63|   class E1 implements I {
                             ^ [1]
   classes.js:60:23
   60|     n(x: mixed): x is string;
                             ^^^^^^ [3]


Error ------------------------------------------------------------------------------------------------- classes.js:81:23

Cannot implement `IP` [1] with `E2` because string [2] is incompatible with number [3] in the type predicate of property
`n`. [incompatible-type]

   classes.js:81:23
   81|     n(x: mixed): x is string { // error number ~> string
                             ^^^^^^ [2]

References:
   classes.js:77:23
   77|   class E2 implements IP<number> {
                             ^^^^^^^^^^ [1]
   classes.js:77:26
   77|   class E2 implements IP<number> {
                                ^^^^^^ [3]


Error -------------------------------------------------------------------------------------------------- classes.js:98:6

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   classes.js:98:6
   98|     (x: string); // error number ~> string
            ^

References:
   classes.js:91:23
   91|     m(x: mixed): x is number;
                             ^^^^^^ [1]
   classes.js:98:9
   98|     (x: string); // error number ~> string
               ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- classes.js:102:6

Cannot cast `x` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   classes.js:102:6
   102|     (x: number); // error string ~> number
             ^

References:
   classes.js:92:30
    92|     static s(x: mixed): x is string;
                                     ^^^^^^ [1]
   classes.js:102:9
   102|     (x: number); // error string ~> number
                ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- classes.js:107:5

Cannot extend `C` [1] with `D1` because function [2], a non-type-guard function, is incompatible with function type [3],
which is a type-guard function in property `m`. [function-predicate]

   classes.js:107:5
            v----------------------------------------------------
   107|     m(x: mixed): boolean { // error extends non-predicate
   108|       return true;
   109|     }
            ^ [2]

References:
   classes.js:106:20
   106|   class D1 extends C {
                           ^ [1]
   classes.js:91:5
    91|     m(x: mixed): x is number;
            ^^^^^^^^^^^^^^^^^^^^^^^^ [3]


Error ------------------------------------------------------------------------------------------------ classes.js:113:23

Cannot extend `C` [1] with `D2` because mixed [2] is incompatible with number [3] in the type predicate of property `m`.
[incompatible-extend]

   classes.js:113:23
   113|     m(x: mixed): x is mixed { // error mixed ~> number
                              ^^^^^ [2]

References:
   classes.js:112:20
   112|   class D2 extends C {
                           ^ [1]
   classes.js:91:23
    91|     m(x: mixed): x is number;
                              ^^^^^^ [3]


Error ------------------------------------------------------------------------------------------------ classes.js:119:14

Cannot return `true` because mixed [1] is incompatible with number [2]. The type of `x` [3] at the return expression
`true` [4] needs to be compatible with the guard type number [2]. See 1. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   classes.js:119:14
   119|       return true; // error mixed ~> number
                     ^^^^ [4]

References:
   classes.js:118:10
   118|     m(x: mixed): x is number {
                 ^^^^^ [1]
   classes.js:118:23
   118|     m(x: mixed): x is number {
                              ^^^^^^ [2]
   classes.js:118:7
   118|     m(x: mixed): x is number {
              ^ [3]


Error ------------------------------------------------------------------------------------------------- classes.js:134:6

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   classes.js:134:6
   134|     (x: string); // error number ~> string
             ^

References:
   classes.js:131:19
   131|   const p = new P<number>();
                          ^^^^^^ [1]
   classes.js:134:9
   134|     (x: string); // error number ~> string
                ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- consistency.js:7:31

Cannot declare a type guard [1] for function [2] because boolean [1] is incompatible with implicitly-returned undefined.
[incompatible-return]

   consistency.js:7:31
   7| function no_return(x: mixed): x is number {} // error no return
                                    ^^^^^^^^^^^ [1]

References:
   consistency.js:7:1
   7| function no_return(x: mixed): x is number {} // error no return
      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error --------------------------------------------------------------------------------------------- consistency.js:10:12

Cannot return `true` because mixed [1] is incompatible with number [2]. The type of `x` [3] at the return expression
`true` [4] needs to be compatible with the guard type number [2]. See 1. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:10:12
   10|     return true; // error x: mixed ~> number
                  ^^^^ [4]

References:
   consistency.js:9:25
    9| function return_true(x: mixed): x is number {
                               ^^^^^ [1]
   consistency.js:9:38
    9| function return_true(x: mixed): x is number {
                                            ^^^^^^ [2]
   consistency.js:9:22
    9| function return_true(x: mixed): x is number {
                            ^ [3]


Error --------------------------------------------------------------------------------------------- consistency.js:15:12

Cannot return `true` because mixed [1] is incompatible with number [2]. The type of `x` [3] at the return expression
`true` [4] needs to be compatible with the guard type number [2]. See 1. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:15:12
   15|     return true; // error in this branch x: mixed ~> number
                  ^^^^ [4]

References:
   consistency.js:13:35
   13| function return_true_in_branch(x: mixed): x is number {
                                         ^^^^^ [1]
   consistency.js:13:48
   13| function return_true_in_branch(x: mixed): x is number {
                                                      ^^^^^^ [2]
   consistency.js:13:32
   13| function return_true_in_branch(x: mixed): x is number {
                                      ^ [3]


Error --------------------------------------------------------------------------------------------- consistency.js:26:10

Cannot return `false` because the negation of the predicate encoded in this expression needs to completely refine away
the guard type `A` [1]. Consider using a one-sided type-guard (`implies x is T`). See 2. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:26:10
   26|   return false; // error (negation) A ~> empty
                ^^^^^

References:
   consistency.js:25:45
   25| function always_false_error(x: mixed): x is A {
                                                   ^ [1]


Error ---------------------------------------------------------------------------------------------- consistency.js:45:3

Cannot return `((typeof x) === 'number') || ((typeof x) === 'string')` because string [1] is incompatible with
number [2]. The type of `x` [3] at the return expression `((typeof x) === 'number') || ((typeof x) === 'string')` [4]
needs to be compatible with the guard type number [2]. See 1. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:45:3
   45|   typeof x === 'string' // error x: string ~> number
         ^^^^^^^^^^^^^^^^^^^^^ [1]

References:
   consistency.js:43:38
   43| const arrow_error = (x: mixed): x is number => (
                                            ^^^^^^ [2]
   consistency.js:43:22
   43| const arrow_error = (x: mixed): x is number => (
                            ^ [3]
   consistency.js:44:3
         v-----------------------
   44|   typeof x === 'number' ||
   45|   typeof x === 'string' // error x: string ~> number
         --------------------^ [4]


Error --------------------------------------------------------------------------------------------- consistency.js:50:12

Cannot return `(typeof x) === 'string'` because string [1] is incompatible with number [2]. The type of `x` [3] at the
return expression `(typeof x) === 'string'` [1] needs to be compatible with the guard type number [2]. See 1. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:50:12
   50|     return typeof x === 'string'; // error x: string ~> number and (negation) number ~> empty
                  ^^^^^^^^^^^^^^^^^^^^^ [1]

References:
   consistency.js:49:21
   49|   m(x: mixed): x is number {
                           ^^^^^^ [2]
   consistency.js:49:5
   49|   m(x: mixed): x is number {
           ^ [3]


Error --------------------------------------------------------------------------------------------- consistency.js:50:12

Cannot return `(typeof x) === 'string'` because the negation of the predicate encoded in this expression needs to
completely refine away the guard type number [1]. Consider using a one-sided type-guard (`implies x is T`). See 2. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:50:12
   50|     return typeof x === 'string'; // error x: string ~> number and (negation) number ~> empty
                  ^^^^^^^^^^^^^^^^^^^^^

References:
   consistency.js:49:21
   49|   m(x: mixed): x is number {
                           ^^^^^^ [1]


Error --------------------------------------------------------------------------------------------- consistency.js:55:35

Cannot use string [1] as type prediate for parameter `x` because string [1] is incompatible with number [2]. A user
defined type guard needs to be compatible with its parameter's type. [incompatible-type-guard]

   consistency.js:55:35
   55|   const tes1 = (x: ?number): x is string => ( // error on string because string ~/> ?number
                                         ^^^^^^ [1]

References:
   consistency.js:55:21
   55|   const tes1 = (x: ?number): x is string => ( // error on string because string ~/> ?number
                           ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- consistency.js:56:5

Cannot return `x != null` because number [1] is incompatible with string [2]. The type of `x` [3] at the return
expression `x != null` [4] needs to be compatible with the guard type string [2]. See 1. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:56:5
   56|     x != null // error number ~> string
           ^^^^^^^^^ [4]

References:
   consistency.js:55:21
   55|   const tes1 = (x: ?number): x is string => ( // error on string because string ~/> ?number
                           ^^^^^^ [1]
   consistency.js:55:35
   55|   const tes1 = (x: ?number): x is string => ( // error on string because string ~/> ?number
                                         ^^^^^^ [2]
   consistency.js:55:17
   55|   const tes1 = (x: ?number): x is string => ( // error on string because string ~/> ?number
                       ^ [3]


Error ---------------------------------------------------------------------------------------------- consistency.js:60:5

Cannot return `x !== null` because null or undefined [1] is incompatible with number [2]. The type of `x` [3] at the
return expression `x !== null` [4] needs to be compatible with the guard type number [2]. See 1. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:60:5
   60|     x !== null // error null | undefined ~> string
           ^^^^^^^^^^ [4]

References:
   consistency.js:59:21
   59|   const test2 = (x: ?number): x is number => (
                           ^^^^^^^ [1]
   consistency.js:59:36
   59|   const test2 = (x: ?number): x is number => (
                                          ^^^^^^ [2]
   consistency.js:59:18
   59|   const test2 = (x: ?number): x is number => (
                        ^ [3]


Error --------------------------------------------------------------------------------------------- consistency.js:71:24

Cannot use string [1] as type prediate for parameter `x` because string [1] is incompatible with number [2]. A user
defined type guard needs to be compatible with its parameter's type. [incompatible-type-guard]

   consistency.js:71:24
   71|   arr.filter((x): x is string => ( // error on string because string ~/> ?number
                              ^^^^^^ [1]

References:
   consistency.js:69:27
   69|   declare var arr: Array<?number>;
                                 ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- consistency.js:72:5

Cannot return `x != null` because number [1] is incompatible with string [2]. The type of `x` [3] at the return
expression `x != null` [4] needs to be compatible with the guard type string [2]. See 1. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:72:5
   72|     x != null // error number ~> string
           ^^^^^^^^^ [4]

References:
   consistency.js:69:27
   69|   declare var arr: Array<?number>;
                                 ^^^^^^ [1]
   consistency.js:71:24
   71|   arr.filter((x): x is string => ( // error on string because string ~/> ?number
                              ^^^^^^ [2]
   consistency.js:71:15
   71|   arr.filter((x): x is string => ( // error on string because string ~/> ?number
                     ^ [3]


Error ---------------------------------------------------------------------------------------------- consistency.js:76:5

Cannot return `x !== null` because null or undefined [1] is incompatible with number [2]. The type of `x` [3] at the
return expression `x !== null` [4] needs to be compatible with the guard type number [2]. See 1. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:76:5
   76|     x !== null // error null | undefined ~> string
           ^^^^^^^^^^ [4]

References:
   consistency.js:69:26
   69|   declare var arr: Array<?number>;
                                ^^^^^^^ [1]
   consistency.js:75:24
   75|   arr.filter((x): x is number => (
                              ^^^^^^ [2]
   consistency.js:75:15
   75|   arr.filter((x): x is number => (
                     ^ [3]


Error --------------------------------------------------------------------------------------------- consistency.js:95:10

Cannot return `x instanceof B` because the negation of the predicate encoded in this expression needs to completely
refine away the guard type `A` [1]. Consider using a one-sided type-guard (`implies x is T`). See 2. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:95:10
   95|   return x instanceof B; // error (negation) A ~> empty
                ^^^^^^^^^^^^^^

References:
   consistency.js:94:45
   94| function instanceof_error_1(x: mixed): x is A {
                                                   ^ [1]


Error --------------------------------------------------------------------------------------------- consistency.js:99:23

Cannot return `x instanceof A` because `A` [1] is incompatible with `B` [2]. The type of `x` [3] at the return
expression `x instanceof A` [4] needs to be compatible with the guard type `B` [2]. See 1. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:99:23
   99|   return x instanceof A; // error A ~> B
                             ^ [1]

References:
   consistency.js:98:45
   98| function instanceof_error_2(x: mixed): x is B {
                                                   ^ [2]
   consistency.js:98:29
   98| function instanceof_error_2(x: mixed): x is B {
                                   ^ [3]
   consistency.js:99:10
   99|   return x instanceof A; // error A ~> B
                ^^^^^^^^^^^^^^ [4]


Error -------------------------------------------------------------------------------------------- consistency.js:125:10

Cannot return `Array.isArray(...)` because array element of refined mixed [1] is incompatible with `A` [2] in array
element. The type of `x` [3] at the return expression `Array.isArray(...)` [4] needs to be compatible with the guard
type read-only array type [5]. See 1. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:125:10
   125|   return Array.isArray(x);
                 ^^^^^^^^^^^^^^^^ [4]

References:
   consistency.js:124:36
   124| function is_array_poly_error<A>(x: mixed): x is $ReadOnlyArray<A> { // error ROArray<mixed> ~> ROArray<A>
                                           ^^^^^ [1]
   consistency.js:124:64
   124| function is_array_poly_error<A>(x: mixed): x is $ReadOnlyArray<A> { // error ROArray<mixed> ~> ROArray<A>
                                                                       ^ [2]
   consistency.js:124:33
   124| function is_array_poly_error<A>(x: mixed): x is $ReadOnlyArray<A> { // error ROArray<mixed> ~> ROArray<A>
                                        ^ [3]
   consistency.js:124:49
   124| function is_array_poly_error<A>(x: mixed): x is $ReadOnlyArray<A> { // error ROArray<mixed> ~> ROArray<A>
                                                        ^^^^^^^^^^^^^^^^^ [5]


Error -------------------------------------------------------------------------------------------- consistency.js:138:12

Cannot return `isNumberOrString(...) && isBoolean(...)` because the negation of the predicate encoded in this expression
needs to completely refine away the guard type string [1]. Consider using a one-sided type-guard (`implies x is T`). See
2. in https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions.
[incompatible-type-guard]

   consistency.js:138:12
   138|     return isNumberOrString(x) && isBoolean(x); // error (negation) string ~> empty
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

References:
   consistency.js:137:34
   137|   function error(x: mixed): x is string {
                                         ^^^^^^ [1]


Error -------------------------------------------------------------------------------------------- consistency.js:149:10

Cannot use type guard parameter `x` [1] because at this return point it is written to in [2]. [function-predicate]

   consistency.js:149:10
   149|   return x instanceof A; // error 'x' is written to
                 ^^^^^^^^^^^^^^

References:
   consistency.js:147:55
   147| function error_write_to_type_guard_param_1(x: mixed): x is A {
                                                              ^ [1]
   consistency.js:148:3
   148|   x = 1;
          ^ [2]


Error -------------------------------------------------------------------------------------------- consistency.js:154:10

Cannot use type guard parameter `x` [1] because at this return point it is written to in [2]. [function-predicate]

   consistency.js:154:10
   154|   return x instanceof B; // error 'x' is written to
                 ^^^^^^^^^^^^^^

References:
   consistency.js:152:55
   152| function error_write_to_type_guard_param_2(x: mixed): x is B {
                                                              ^ [1]
   consistency.js:153:3
   153|   x = new B();
          ^ [2]


Error -------------------------------------------------------------------------------------------- consistency.js:160:12

Cannot use type guard parameter `x` [1] because at this return point it is written to in [2]. [function-predicate]

   consistency.js:160:12
   160|     return x instanceof B; // error 'x' is written to (1st loc)
                   ^^^^^^^^^^^^^^

References:
   consistency.js:157:59
   157| function error_write_to_type_guard_param_multi(x: mixed): x is B {
                                                                  ^ [1]
   consistency.js:159:5
   159|     x = new B();
            ^ [2]


Error -------------------------------------------------------------------------------------------- consistency.js:163:12

Cannot use type guard parameter `x` [1] because at this return point it is written to in [2]. [function-predicate]

   consistency.js:163:12
   163|     return x instanceof B; // error 'x' is written to (2nd loc)
                   ^^^^^^^^^^^^^^

References:
   consistency.js:157:59
   157| function error_write_to_type_guard_param_multi(x: mixed): x is B {
                                                                  ^ [1]
   consistency.js:162:5
   162|     x = new B();
            ^ [2]


Error -------------------------------------------------------------------------------------------- consistency.js:171:10

Cannot return `x instanceof B` because the negation of the predicate encoded in this expression needs to completely
refine away the guard type `A` [1]. Consider using a one-sided type-guard (`implies x is T`). See 2. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:171:10
   171|   return x instanceof B; // error (negation) A ~> empty
                 ^^^^^^^^^^^^^^

References:
   consistency.js:167:42
   167| function multi_return_ok(x: mixed): x is A {
                                                 ^ [1]


Error -------------------------------------------------------------------------------------------- consistency.js:176:25

Cannot return `x instanceof A` because `A` [1] is incompatible with `B` [2]. The type of `x` [3] at the return
expression `x instanceof A` [4] needs to be compatible with the guard type `B` [2]. See 1. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:176:25
   176|     return x instanceof A; // error A ~> B
                                ^ [1]

References:
   consistency.js:174:56
   174| function multi_return_one_branch_error(x: mixed): x is B {
                                                               ^ [2]
   consistency.js:174:40
   174| function multi_return_one_branch_error(x: mixed): x is B {
                                               ^ [3]
   consistency.js:176:12
   176|     return x instanceof A; // error A ~> B
                   ^^^^^^^^^^^^^^ [4]


Error -------------------------------------------------------------------------------------------- consistency.js:185:33

Cannot use type guard parameter `x`, because `x` [1] is reassigned in [2]. [function-predicate]

   consistency.js:185:33
   185| function havoc_error(x: mixed): x is B { // error 'x' is havoced
                                        ^

References:
   consistency.js:185:22
   185| function havoc_error(x: mixed): x is B { // error 'x' is havoced
                             ^ [1]
   consistency.js:189:3
   189|   y();
          ^^^ [2]


Error -------------------------------------------------------------------------------------------- consistency.js:213:12

Cannot return `this.#prop(...)` because number [1] is incompatible with string [2]. The type of `value` [3] at the
return expression `this.#prop(...)` [4] needs to be compatible with the guard type string [2]. See 1. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:213:12
   213|     return this.#prop(value); // no prop-missing error
                   ^^^^^^^^^^^^^^^^^ [4]

References:
   consistency.js:210:45
   210|   #prop: (value: mixed) => implies value is number;
                                                    ^^^^^^ [1]
   consistency.js:212:41
   212|   test1(value: mixed): implies value is string { // error number ~> string on predicate
                                                ^^^^^^ [2]
   consistency.js:212:9
   212|   test1(value: mixed): implies value is string { // error number ~> string on predicate
                ^^^^^ [3]


Error -------------------------------------------------------------------------------------------- consistency.js:226:19

Cannot call `remote.#prop` because property `#prop` is missing in `Private_property_1` [1]. [prop-missing]

   consistency.js:226:19
   226|     return remote.#prop(value); // error prop-missing
                          ^^^^^

References:
   consistency.js:225:30
   225|   test(value: mixed, remote: Private_property_1): implies value is string { // error number ~> string on predicate
                                     ^^^^^^^^^^^^^^^^^^ [1]


Error -------------------------------------------------------------------------------------------- consistency.js:226:12

Cannot return `remote.#prop(...)` because mixed [1] is incompatible with string [2]. The type of `value` [3] at the
return expression `remote.#prop(...)` [4] needs to be compatible with the guard type string [2]. See 1. in
https://flow.org/en/docs/types/type-guards/#toc-consistency-checks-of-type-guard-functions. [incompatible-type-guard]

   consistency.js:226:12
   226|     return remote.#prop(value); // error prop-missing
                   ^^^^^^^^^^^^^^^^^^^ [4]

References:
   consistency.js:225:15
   225|   test(value: mixed, remote: Private_property_1): implies value is string { // error number ~> string on predicate
                      ^^^^^ [1]
   consistency.js:225:68
   225|   test(value: mixed, remote: Private_property_1): implies value is string { // error number ~> string on predicate
                                                                           ^^^^^^ [2]
   consistency.js:225:8
   225|   test(value: mixed, remote: Private_property_1): implies value is string { // error number ~> string on predicate
               ^^^^^ [3]


Error ------------------------------------------------------------------------------------------------ inferred.js:18:23

Cannot call `takesGuard` with function bound to `fn` because string [1] is incompatible with number [2] in the type
predicate. [incompatible-call]

   inferred.js:18:23
   18|   takesGuard(value => typeof value === "string"); // error wrong guard type
                             ^^^^^^^^^^^^^^^^^^^^^^^^^ [1]

References:
   inferred.js:13:62
   13|   declare function takesGuard(fn: (x: mixed) => implies x is number): void;
                                                                    ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------ inferred.js:19:32

Cannot call `takesGuard` with function bound to `fn` because string [1] is incompatible with number [2] in the type
predicate. [incompatible-call]

   inferred.js:19:32
   19|   takesGuard((value: mixed) => typeof value === "string"); // error wrong guard type
                                      ^^^^^^^^^^^^^^^^^^^^^^^^^ [1]

References:
   inferred.js:13:62
   13|   declare function takesGuard(fn: (x: mixed) => implies x is number): void;
                                                                    ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- inferred.js:29:5

Cannot call `takesGuardTwoParams` with function bound to `fn` because function [1], a non-type-guard function, is
incompatible with function type [2], which is a type-guard function. [function-predicate]

   inferred.js:29:5
           v--------------------------------------------
   29|     ( // error function-predicate incompatibility
   30|       value: mixed,
   31|       otherValue, // error missing-local-annot
   32|     ) => typeof value === "number");
           -----------------------------^ [1]

References:
   inferred.js:23:44
   23|   declare function takesGuardTwoParams(fn: (x: mixed, y: mixed) => implies x is number): void;
                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- inferred.js:31:7

An annotation on `otherValue` is required because Flow cannot infer its type from local context. [missing-local-annot]

   31|       otherValue, // error missing-local-annot
             ^^^^^^^^^^


Error ------------------------------------------------------------------------------------------------- inferred.js:34:5

Cannot call `takesGuardTwoParams` with function bound to `fn` because function [1], a non-type-guard function, is
incompatible with function type [2], which is a type-guard function. [function-predicate]

   inferred.js:34:5
   34|     (value: mixed, otherValue: mixed) => typeof value === "number" // error can only infer type guard
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]

References:
   inferred.js:23:44
   23|   declare function takesGuardTwoParams(fn: (x: mixed, y: mixed) => implies x is number): void;
                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------ inferred.js:38:32

Cannot call `takesGuardTwoParams` with function bound to `fn` because string [1] is incompatible with number [2] in the
type predicate. [incompatible-call]

   inferred.js:38:32
   38|   takesGuardTwoParams(value => typeof value === "string"); // error wrong guard type
                                      ^^^^^^^^^^^^^^^^^^^^^^^^^ [1]

References:
   inferred.js:23:81
   23|   declare function takesGuardTwoParams(fn: (x: mixed, y: mixed) => implies x is number): void;
                                                                                       ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------ inferred.js:39:41

Cannot call `takesGuardTwoParams` with function bound to `fn` because string [1] is incompatible with number [2] in the
type predicate. [incompatible-call]

   inferred.js:39:41
   39|   takesGuardTwoParams((value: mixed) => typeof value === "string"); // error wrong guard type
                                               ^^^^^^^^^^^^^^^^^^^^^^^^^ [1]

References:
   inferred.js:23:81
   23|   declare function takesGuardTwoParams(fn: (x: mixed, y: mixed) => implies x is number): void;
                                                                                       ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- inferred.js:48:5

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   inferred.js:48:5
   48|     x as string; // error number ~> string
           ^

References:
   inferred.js:44:18
   44|   declare var x: number | string;
                        ^^^^^^ [1]
   inferred.js:48:10
   48|     x as string; // error number ~> string
                ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- inferred.js:50:5

Cannot cast `x` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   inferred.js:50:5
   50|     x as number; // error no refinement due to one-sided type guard
           ^

References:
   inferred.js:44:27
   44|   declare var x: number | string;
                                 ^^^^^^ [1]
   inferred.js:50:10
   50|     x as number; // error no refinement due to one-sided type guard
                ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- inferred.js:51:5

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   inferred.js:51:5
   51|     x as string; // error no refinement due to one-sided type guard
           ^

References:
   inferred.js:44:18
   44|   declare var x: number | string;
                        ^^^^^^ [1]
   inferred.js:51:10
   51|     x as string; // error no refinement due to one-sided type guard
                ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- inferred.js:54:3

Cannot cast `fn` to function type because one-sided `value` [1] is incompatible with default type guard [2].
[function-predicate]

   inferred.js:54:3
   54|   fn as (value: mixed) => value is number; // error one-sided incompatible with two-sided
         ^^

References:
   inferred.js:43:15
   43|   const fn = (value: mixed) => typeof value === "number"; // infers: (value: mixed) => implies value is number
                     ^^^^^ [1]
   inferred.js:54:27
   54|   fn as (value: mixed) => value is number; // error one-sided incompatible with two-sided
                                 ^^^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- inferred.js:60:3

Cannot cast `fn` to function type because function [1], a non-type-guard function, is incompatible with function
type [2], which is a type-guard function. [function-predicate]

   inferred.js:60:3
   60|   fn as (value: mixed) => implies value is number; // error non type guard
         ^^

References:
   inferred.js:58:14
   58|   const fn = (value: mixed): boolean => typeof value === "number"; // infers: (value: mixed) => boolean
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]
   inferred.js:60:9
   60|   fn as (value: mixed) => implies value is number; // error non type guard
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- inferred.js:61:3

Cannot cast `fn` to function type because function [1], a non-type-guard function, is incompatible with function
type [2], which is a type-guard function. [function-predicate]

   inferred.js:61:3
   61|   fn as (value: mixed) => value is number; // error non type guard
         ^^

References:
   inferred.js:58:14
   58|   const fn = (value: mixed): boolean => typeof value === "number"; // infers: (value: mixed) => boolean
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]
   inferred.js:61:9
   61|   fn as (value: mixed) => value is number; // error non type guard
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- inferred.js:70:3

Cannot cast `u` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   inferred.js:70:3
   70|   u as number; // error string ~> number
         ^

References:
   inferred.js:67:23
   67|   declare var value: ?string;
                             ^^^^^^ [1]
   inferred.js:70:8
   70|   u as number; // error string ~> number
              ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- inferred.js:79:3

Cannot cast `3` to `typeof t2` because number [1] is incompatible with number literal `4` [2]. [incompatible-cast]

   inferred.js:79:3
   79|   3 as typeof t2; // error: not ideal, but this is an implicit instantiation issue
         ^ [1]

References:
   inferred.js:79:8
   79|   3 as typeof t2; // error: not ideal, but this is an implicit instantiation issue
              ^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- inferred.js:81:3

Cannot cast `u2` to number literal `3` because number literal `4` [1] is incompatible with number literal `3` [2].
[incompatible-cast]

   inferred.js:81:3
   81|   u2 as 3; // error 4 ~> 3
         ^^

References:
   inferred.js:77:43
   77|   const [t2, u2] = takesPolyGuard((value: mixed) => value === 4);
                                                 ^^^^^ [1]
   inferred.js:81:9
   81|   u2 as 3; // error 4 ~> 3
               ^ [2]


Error ------------------------------------------------------------------------------------------------- inferred.js:83:3

Cannot cast `3` to `typeof u2` because number [1] is incompatible with number literal `4` [2]. [incompatible-cast]

   inferred.js:83:3
   83|   3 as typeof u2; // error we infer a sound singleton type for u2
         ^ [1]

References:
   inferred.js:83:8
   83|   3 as typeof u2; // error we infer a sound singleton type for u2
              ^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- inferred.js:94:3

Cannot cast `u1` to number literal `3` because number literal `4` [1] is incompatible with number literal `3` [2].
[incompatible-cast]

   inferred.js:94:3
   94|   u1 as 3; // error 4 ~> 3
         ^^

References:
   inferred.js:91:45
   91|   const [t1, u1] = takesOverloadedPolyGuard(value, x => x === 4); // picks the first overload
                                                   ^^^^^ [1]
   inferred.js:94:9
   94|   u1 as 3; // error 4 ~> 3
               ^ [2]


Error ------------------------------------------------------------------------------------------------- inferred.js:96:3

Cannot cast `3` to `typeof u1` because number [1] is incompatible with number literal `4` [2]. [incompatible-cast]

   inferred.js:96:3
   96|   3 as typeof u1; // error we infer a sound singleton type for u1
         ^ [1]

References:
   inferred.js:96:8
   96|   3 as typeof u1; // error we infer a sound singleton type for u1
              ^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- inferred.js:99:3

Cannot cast `u2` to number literal `4` because number [1] is incompatible with number literal `4` [2].
[incompatible-cast]

   inferred.js:99:3
   99|   u2 as 4; // error number ~> 4
         ^^

References:
   inferred.js:90:22
   90|   declare var value: number;
                            ^^^^^^ [1]
   inferred.js:99:9
   99|   u2 as 4; // error number ~> 4
               ^ [2]


Error ----------------------------------------------------------------------------------------------- inferred.js:108:45

An annotation on `x` is required because Flow cannot infer its type from local context. [missing-local-annot]

   108|   const [t1, u1] = takesOverloadedPolyGuard(x => x === 4); // error missing-local-annot
                                                    ^


Error ------------------------------------------------------------------------------------------------ inferred.js:142:5

Cannot call `takesGuard` with function bound to `guard` because function [1], a non-type-guard function, is incompatible
with function type [2], which is a type-guard function. [function-predicate]

   inferred.js:142:5
   142|     (z) => z, // error non type guard function
            ^^^^^^^^ [1]

References:
   inferred.js:138:48
   138|   declare function takesGuard<T, U: T>(guard: ?(x: T) => implies x is U, T): [T, U];
                                                       ^^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- inferred.js:142:12

Cannot call `takesGuard` with function bound to `guard` because number [1] is incompatible with boolean [2] in the
return value. [incompatible-call]

   inferred.js:142:12
   142|     (z) => z, // error non type guard function
                   ^

References:
   inferred.js:140:18
   140|   declare var x: number;
                         ^^^^^^ [1]
   inferred.js:138:58
   138|   declare function takesGuard<T, U: T>(guard: ?(x: T) => implies x is U, T): [T, U];
                                                                 ^^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------ inferred.js:158:3

Cannot cast `fn` to function type because one-sided `x` [1] is incompatible with default type guard [2].
[function-predicate]

   inferred.js:158:3
   158|   fn as (x: ?number) => x is number; // error inferred type guard is one-sided
          ^^

References:
   inferred.js:155:15
   155|   const fn = (x: ?number)=> x != null;
                      ^ [1]
   inferred.js:158:25
   158|   fn as (x: ?number) => x is number; // error inferred type guard is one-sided
                                ^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------ inferred.js:161:3

Cannot cast `fn1` to `typeof fn` because null or undefined [1] is incompatible with number [2] in the type predicate.
[incompatible-cast]

   inferred.js:161:3
   161|   fn1 as typeof fn; // error ?number ~> number
          ^^^

References:
   inferred.js:160:42
   160|   declare var fn1 : (x: ?number) => x is ?number;
                                                 ^^^^^^^ [1]
   inferred.js:155:19
   155|   const fn = (x: ?number)=> x != null;
                          ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------ inferred.js:186:3

Cannot cast `fn` to function type because function [1], a non-type-guard function, is incompatible with function
type [2], which is a type-guard function. [function-predicate]

   inferred.js:186:3
   186|   fn as (x: mixed) => implies x is mixed; // error non-type guard function
          ^^

References:
   inferred.js:185:14
   185|   const fn = (x: mixed) => typeof x === "object" && x?.hasOwnProperty("a");
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]
   inferred.js:186:9
   186|   fn as (x: mixed) => implies x is mixed; // error non-type guard function
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------ inferred.js:186:3

Cannot cast `fn` to function type because undefined (result of null short-circuiting an optional chain) [1] is
incompatible with boolean [2] in the return value. [incompatible-cast]

   inferred.js:186:3
   186|   fn as (x: mixed) => implies x is mixed; // error non-type guard function
          ^^

References:
   inferred.js:185:18
   185|   const fn = (x: mixed) => typeof x === "object" && x?.hasOwnProperty("a");
                         ^^^^^ [1]
   inferred.js:186:23
   186|   fn as (x: mixed) => implies x is mixed; // error non-type guard function
                              ^^^^^^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- intersect.js:7:5

Cannot cast `x` to string literal `b` because string literal `a` [1] is incompatible with string literal `b` [2].
[incompatible-cast]

   intersect.js:7:5
   7|     x as 'b'; // error 'a' ~> 'b'
          ^

References:
   intersect.js:4:18
   4|   declare var x: 'a'|'c';
                       ^^^ [1]
   intersect.js:7:10
   7|     x as 'b'; // error 'a' ~> 'b'
               ^^^ [2]


Error ------------------------------------------------------------------------------------------------- intersect.js:8:5

Cannot cast `x` to string literal `c` because string literal `a` [1] is incompatible with string literal `c` [2].
[incompatible-cast]

   intersect.js:8:5
   8|     x as 'c'; // error 'a' ~> 'c'
          ^

References:
   intersect.js:4:18
   4|   declare var x: 'a'|'c';
                       ^^^ [1]
   intersect.js:8:10
   8|     x as 'c'; // error 'a' ~> 'c'
               ^^^ [2]


Error ------------------------------------------------------------------------------------------------ intersect.js:19:5

Cannot cast `x` to string literal `b` because string literal `c` [1] is incompatible with string literal `b` [2].
[incompatible-cast]

   intersect.js:19:5
   19|     x as 'b'; // error 'c' ~> 'b'
           ^

References:
   intersect.js:17:26
   17|   declare const x: 'a' | 'c';
                                ^^^ [1]
   intersect.js:19:10
   19|     x as 'b'; // error 'c' ~> 'b'
                ^^^ [2]


Error ------------------------------------------------------------------------------------------------ intersect.js:43:5

Cannot cast `x` to `KB` because string literal `C` [1] is incompatible with string literal `B` [2] in type argument
`X` [3]. [incompatible-cast]

   intersect.js:43:5
   43|     x as KB; // error KC ~> KB
           ^

References:
   intersect.js:34:15
   34|   type KC = K<'C'>;
                     ^^^ [1]
   intersect.js:33:15
   33|   type KB = K<'B'>;
                     ^^^ [2]
   intersect.js:37:11
   37|   class K<X: $Keys<AllTypes>>  extends S<X> {}
                 ^ [3]


Error -------------------------------------------------------------------------------------------------- invalid.js:6:22

Cannot return boolean because boolean [1] is incompatible with constructor void return [2]. [incompatible-return]

   invalid.js:6:22
   6|   constructor(x: A): x is C { // error no type guard on constructor
                           ^^^^^^ [1]

References:
   invalid.js:6:20
   6|   constructor(x: A): x is C { // error no type guard on constructor
                         ^^^^^^^^ [2]


Error -------------------------------------------------------------------------------------------------- invalid.js:6:22

Cannot declare a type guard on a(n) constructor function. [function-predicate]

   6|   constructor(x: A): x is C { // error no type guard on constructor
                           ^^^^^^


Error -------------------------------------------------------------------------------------------------- invalid.js:9:12

Cannot declare a type guard on a(n) getter/setter function. [function-predicate]

   9|   get p(): this is C {  // error no type guard on getter
                 ^^^^^^^^^


Error ------------------------------------------------------------------------------------------------- invalid.js:12:16

Cannot declare a type guard on a(n) getter/setter function. [function-predicate]

   12|   set q(x: A): x is C {  // error no type guard on setter
                      ^^^^^^


Error ------------------------------------------------------------------------------------------------- invalid.js:17:31

Cannot declare a type guard [1] for function [2] because boolean [1] is incompatible with implicitly-returned undefined.
[incompatible-return]

   invalid.js:17:31
   17| function no_return(x: mixed): x is number {}
                                     ^^^^^^^^^^^ [1]

References:
   invalid.js:17:1
   17| function no_return(x: mixed): x is number {}
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- invalid.js:19:32

Cannot declare a type guard on a(n) generator function. [function-predicate]

   19| function *generator(x: mixed): x is number { // error
                                      ^^^^^^^^^^^


Error ------------------------------------------------------------------------------------------------- invalid.js:19:32

`$Generator` [1] is incompatible with boolean [2]. [incompatible-type]

   invalid.js:19:32
     19| function *generator(x: mixed): x is number { // error
                                        ^^^^^^^^^^^ [2]

References:
   <BUILTINS>/core.js:1879:40
   1879| type Generator<+Yield,+Return,-Next> = $Generator<Yield,Return,Next>;
                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]


Error ------------------------------------------------------------------------------------------------- invalid.js:19:32

boolean [1], a primitive, cannot be used as a subtype of `$Iterable` [2]. You can wrap it in `new Boolean(...))` to turn
it into an object and attempt to use it as a subtype of an interface. [incompatible-type]

   invalid.js:19:32
     19| function *generator(x: mixed): x is number { // error
                                        ^^^^^^^^^^^ [1]

References:
   <BUILTINS>/core.js:1865:11
   1865| interface $Iterable<+Yield,+Return,-Next> {
                   ^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- invalid.js:20:10

Cannot return `(typeof x) == "number"` because `$Generator` [1] is incompatible with boolean [2]. [incompatible-return]

   invalid.js:20:10
     20|   return typeof x == "number";
                  ^^^^^^^^^^^^^^^^^^^^

References:
   <BUILTINS>/core.js:1879:40
   1879| type Generator<+Yield,+Return,-Next> = $Generator<Yield,Return,Next>;
                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]
   invalid.js:19:32
     19| function *generator(x: mixed): x is number { // error
                                        ^^^^^^^^^^^ [2]


Error -------------------------------------------------------------------------------------------------- invalid.js:25:4

Cannot cast `x` to number because mixed [1] is incompatible with number [2]. [incompatible-cast]

   invalid.js:25:4
   25|   (x: number); // error no refining effect
          ^

References:
   invalid.js:23:16
   23| declare var x: mixed;
                      ^^^^^ [1]
   invalid.js:25:7
   25|   (x: number); // error no refining effect
             ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- invalid.js:28:33

Cannot declare a type guard on a(n) async function. [function-predicate]

   28| async function async(x: mixed): x is number { // error
                                       ^^^^^^^^^^^


Error ------------------------------------------------------------------------------------------------- invalid.js:29:10

Cannot return `(typeof x) == "number"` because `Promise` [1] is incompatible with boolean [2]. [incompatible-return]

   invalid.js:29:10
     29|   return typeof x == "number"
                  ^^^^^^^^^^^^^^^^^^^^

References:
   <BUILTINS>/core.js:2102:15
   2102| declare class Promise<+R = mixed> {
                       ^^^^^^^ [1]
   invalid.js:28:33
     28| async function async(x: mixed): x is number { // error
                                         ^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- invalid.js:33:12

Cannot declare a type guard on a(n) getter function. [function-predicate]

   33|   get p(): x is number;
                  ^^^^^^^^^^^


Error ------------------------------------------------------------------------------------------------- invalid.js:34:20

Cannot declare a type guard on a(n) setter function. [function-predicate]

   34|   set p(x: mixed): x is number;
                          ^^^^^^^^^^^


Error ------------------------------------------------------------------------------------------------- invalid.js:35:26

Cannot declare a type guard on a(n) constructor function. [function-predicate]

   35|   constructor(x: mixed): x is number;
                                ^^^^^^^^^^^


Error ------------------------------------------------------------------------------------------------- invalid.js:38:52

Cannot resolve name `Missing`. [cannot-resolve-name]

   38| type Error_in_type_guard_type = (x: mixed) => x is Missing; // error missing name
                                                          ^^^^^^^


Error ------------------------------------------------------------------------------------------------- objects.js:14:14

Cannot use type guard parameter `x` [1] because at this return point it is written to in [2]. [function-predicate]

   objects.js:14:14
   14|       return typeof x === 'number'; // error write reaches return
                    ^^^^^^^^^^^^^^^^^^^^^

References:
   objects.js:12:24
   12|     invalid(x: mixed): x is number {
                              ^ [1]
   objects.js:13:7
   13|       x = 1;
             ^ [2]


Error -------------------------------------------------------------------------------------------------- objects.js:20:6

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   objects.js:20:6
   20|     (x: string); // error number ~> string
            ^

References:
   objects.js:6:23
    6|     m(x: mixed): x is number {
                             ^^^^^^ [1]
   objects.js:20:9
   20|     (x: string); // error number ~> string
               ^^^^^^ [2]


Error -------------------------------------------------------------------------------------------------- objects.js:23:6

Cannot cast `x` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   objects.js:23:6
   23|     (x: number); // error string ~> number
            ^

References:
   objects.js:9:23
    9|     f(x: mixed): x is string {
                             ^^^^^^ [1]
   objects.js:23:9
   23|     (x: number); // error string ~> number
               ^^^^^^ [2]


Error -------------------------------------------------------------------------------------------------- objects.js:29:4

Cannot cast `obj` to object type because number [1] is incompatible with string [2] in the type predicate of property
`m`. [incompatible-cast]

   objects.js:29:4
   29|   (obj: { // error number ~> string
          ^^^

References:
   objects.js:6:23
    6|     m(x: mixed): x is number {
                             ^^^^^^ [1]
   objects.js:30:23
   30|     m(x: mixed): x is string,
                             ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------- patterns_and_rest.js:1:54

A type guard parameter `b` [1] cannot reference pattern parameter `b` [2]. [function-predicate]

   patterns_and_rest.js:1:54
   1| function invalid_pattern_object({a: b}: {a: mixed}): b is string {
                                                           ^ [1]

References:
   patterns_and_rest.js:1:37
   1| function invalid_pattern_object({a: b}: {a: mixed}): b is string {
                                          ^ [2]


Error ---------------------------------------------------------------------------------------- patterns_and_rest.js:5:47

A type guard parameter `b` [1] cannot reference pattern parameter `b` [2]. [function-predicate]

   patterns_and_rest.js:5:47
   5| function invalid_pattern_array([b]: [mixed]): b is string {
                                                    ^ [1]

References:
   patterns_and_rest.js:5:33
   5| function invalid_pattern_array([b]: [mixed]): b is string {
                                      ^ [2]


Error ---------------------------------------------------------------------------------------- patterns_and_rest.js:9:44

A type guard parameter `a` [1] cannot reference rest parameter `a` [2]. [function-predicate]

   patterns_and_rest.js:9:44
   9| function invalid_rest(...a: Array<mixed>): a is string {
                                                 ^ [1]

References:
   patterns_and_rest.js:9:26
   9| function invalid_rest(...a: Array<mixed>): a is string {
                               ^ [2]


Error --------------------------------------------------------------------------------------- patterns_and_rest.js:13:57

A type guard parameter `a` [1] cannot reference rest parameter `a` [2]. [function-predicate]

   patterns_and_rest.js:13:57
   13| declare function invalid_rest_decl(...a: Array<mixed>): a is string;  // error a is in rest param
                                                               ^ [1]

References:
   patterns_and_rest.js:13:39
   13| declare function invalid_rest_decl(...a: Array<mixed>): a is string;  // error a is in rest param
                                             ^ [2]


Error --------------------------------------------------------------------------------------- patterns_and_rest.js:15:60

A type guard parameter `b` [1] cannot reference pattern parameter `b` [2]. [function-predicate]

   patterns_and_rest.js:15:60
   15| function invalid_pattern_compound({a: [b]}: {a: [mixed]}): b is string {
                                                                  ^ [1]

References:
   patterns_and_rest.js:15:40
   15| function invalid_pattern_compound({a: [b]}: {a: [mixed]}): b is string {
                                              ^ [2]


Error ---------------------------------------------------------------------------------------- patterns_and_rest.js:28:4

Cannot cast `x` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   patterns_and_rest.js:28:4
   28|   (x: number); // TODO error string ~> number
          ^

References:
   patterns_and_rest.js:21:78
   21| function valid_pattern({a}: {a: mixed}, x: mixed, ...r: Array<number>): x is string {
                                                                                    ^^^^^^ [1]
   patterns_and_rest.js:28:7
   28|   (x: number); // TODO error string ~> number
             ^^^^^^ [2]


Error --------------------------------------------------------------------------------------- patterns_and_rest.js:31:44

A type guard parameter `p` [1] cannot reference rest parameter `p` [2]. [function-predicate]

   patterns_and_rest.js:31:44
   31| type F = (x: mixed, ...p: Array<mixed>) => p is number; // error p is in rest param
                                                  ^ [1]

References:
   patterns_and_rest.js:31:24
   31| type F = (x: mixed, ...p: Array<mixed>) => p is number; // error p is in rest param
                              ^ [2]


Error ------------------------------------------------------------------------------------------------ refinement.js:7:6

Cannot cast `y` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   refinement.js:7:6
   7|     (y: string); // error number ~> string
           ^

References:
   refinement.js:2:26
   2|   fn: (x: mixed) => x is number,
                               ^^^^^^ [1]
   refinement.js:7:9
   7|     (y: string); // error number ~> string
              ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- refinement.js:20:6

Cannot cast `x1` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   refinement.js:20:6
   20|     (x1: number); // error string ~> number
            ^^

References:
   refinement.js:13:7
   13|   x1: string,
             ^^^^^^ [1]
   refinement.js:20:10
   20|     (x1: number); // error string ~> number
                ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- refinement.js:24:6

Cannot cast `x2` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   refinement.js:24:6
   24|     (x2: number); // error string ~> number
            ^^

References:
   refinement.js:14:7
   14|   x2: string | null,
             ^^^^^^ [1]
   refinement.js:24:10
   24|     (x2: number); // error string ~> number
                ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- refinement.js:28:6

Cannot cast `x3` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   refinement.js:28:6
   28|     (x3: number); // error string ~> number
            ^^

References:
   refinement.js:15:7
   15|   x3: string | void,
             ^^^^^^ [1]
   refinement.js:28:10
   28|     (x3: number); // error string ~> number
                ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- refinement.js:32:6

Cannot cast `x4` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   refinement.js:32:6
   32|     (x4: number); // error string ~> number
            ^^

References:
   refinement.js:16:8
   16|   x4: ?string,
              ^^^^^^ [1]
   refinement.js:32:10
   32|     (x4: number); // error string ~> number
                ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:47:35

Cannot call `arr.filter` because: [incompatible-call]
 - Either function [1] is incompatible with class `Boolean` [2].
 - Or number [3] is incompatible with string [4] in array element.

   refinement.js:47:35
   47|   const arr2: Array<string> = arr.filter((x: mixed): x is number => { return typeof x === "number"; }); // error
                                         ^^^^^^

References:
   refinement.js:47:42
   47|   const arr2: Array<string> = arr.filter((x: mixed): x is number => { return typeof x === "number"; }); // error
                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]
   refinement.js:39:24
   39|     filter(callbackfn: typeof Boolean): Array<$NonMaybeType<T>>;
                              ^^^^^^^^^^^^^^ [2]
   refinement.js:47:59
   47|   const arr2: Array<string> = arr.filter((x: mixed): x is number => { return typeof x === "number"; }); // error
                                                                 ^^^^^^ [3]
   refinement.js:47:21
   47|   const arr2: Array<string> = arr.filter((x: mixed): x is number => { return typeof x === "number"; }); // error
                           ^^^^^^ [4]


Error ---------------------------------------------------------------------------------------------- refinement.js:48:35

Cannot call `arr.filter` because: [incompatible-call]
 - Either function [1] is incompatible with class `Boolean` [2].
 - Or function [1], a non-type-guard function, is incompatible with function type [3], which is a type-guard function.

   refinement.js:48:35
   48|   const arr3: Array<string> = arr.filter((x: mixed) => { return typeof x === "number"; }); // error no refinement
                                         ^^^^^^

References:
   refinement.js:48:42
   48|   const arr3: Array<string> = arr.filter((x: mixed) => { return typeof x === "number"; }); // error no refinement
                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]
   refinement.js:39:24
   39|     filter(callbackfn: typeof Boolean): Array<$NonMaybeType<T>>;
                              ^^^^^^^^^^^^^^ [2]
   refinement.js:40:35
   40|     filter<This, S: T>(predicate: (this: This, value: T, index: number, array: $ReadOnlyArray<T>) => value is S, thisArg?: This): Array<S>;
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [3]


Error ----------------------------------------------------------------------------------------------- refinement.js:61:8

Cannot cast `x` to `B` because number [1] is incompatible with string [2] in property `foo`. [incompatible-cast]

   refinement.js:61:8
   61|       (x: B); // error A ~> B
              ^

References:
   refinement.js:53:29
   53|   type A = { tag: 'A', foo: number };
                                   ^^^^^^ [1]
   refinement.js:54:29
   54|   type B = { tag: 'B', foo: string };
                                   ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- refinement.js:61:8

Cannot cast `x` to `B` because string literal `A` [1] is incompatible with string literal `B` [2] in property `tag`.
[incompatible-cast]

   refinement.js:61:8
   61|       (x: B); // error A ~> B
              ^

References:
   refinement.js:53:19
   53|   type A = { tag: 'A', foo: number };
                         ^^^ [1]
   refinement.js:54:19
   54|   type B = { tag: 'B', foo: string };
                         ^^^ [2]


Error ----------------------------------------------------------------------------------------------- refinement.js:72:8

Cannot cast `x` to `A` because: [incompatible-cast]
 - Either string [1] is incompatible with number [2] in property `foo`.
 - Or inexact object type [3] is incompatible with exact `A` [4].

   refinement.js:72:8
   72|       (x: A); // error B & {tag_: 'A',...} ~> A
              ^

References:
   refinement.js:54:29
   54|   type B = { tag: 'B', foo: string };
                                   ^^^^^^ [1]
   refinement.js:53:29
   53|   type A = { tag: 'A', foo: number };
                                   ^^^^^^ [2]
   refinement.js:70:57
   70|   declare function invalid_sentinel_key(x: mixed): x is {tag_: 'A', ...};
                                                               ^^^^^^^^^^^^^^^^ [3]
   refinement.js:72:11
   72|       (x: A); // error B & {tag_: 'A',...} ~> A
                 ^ [4]


Error ----------------------------------------------------------------------------------------------- refinement.js:73:8

Cannot cast `x` to `B` because: [incompatible-cast]
 - Either number [1] is incompatible with string [2] in property `foo`.
 - Or inexact object type [3] is incompatible with exact `B` [4].

   refinement.js:73:8
   73|       (x: B); // error A & {tag_: 'A',...} ~> B
              ^

References:
   refinement.js:53:29
   53|   type A = { tag: 'A', foo: number };
                                   ^^^^^^ [1]
   refinement.js:54:29
   54|   type B = { tag: 'B', foo: string };
                                   ^^^^^^ [2]
   refinement.js:70:57
   70|   declare function invalid_sentinel_key(x: mixed): x is {tag_: 'A', ...};
                                                               ^^^^^^^^^^^^^^^^ [3]
   refinement.js:73:11
   73|       (x: B); // error A & {tag_: 'A',...} ~> B
                 ^ [4]


Error ----------------------------------------------------------------------------------------------- refinement.js:86:8

Cannot cast `x` to `B` because number [1] is incompatible with string [2] in property `foo`. [incompatible-cast]

   refinement.js:86:8
   86|       (x: B); // error A ~> B
              ^

References:
   refinement.js:78:39
   78|   type A = $ReadOnly<{ tag: 'A', foo: number }>;
                                             ^^^^^^ [1]
   refinement.js:79:39
   79|   type B = $ReadOnly<{ tag: 'B', foo: string }>;
                                             ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- refinement.js:86:8

Cannot cast `x` to `B` because string literal `A` [1] is incompatible with string literal `B` [2] in property `tag`.
[incompatible-cast]

   refinement.js:86:8
   86|       (x: B); // error A ~> B
              ^

References:
   refinement.js:78:29
   78|   type A = $ReadOnly<{ tag: 'A', foo: number }>;
                                   ^^^ [1]
   refinement.js:79:29
   79|   type B = $ReadOnly<{ tag: 'B', foo: string }>;
                                   ^^^ [2]


Error ----------------------------------------------------------------------------------------------- refinement.js:97:8

Cannot cast `x` to `A` because: [incompatible-cast]
 - Either string [1] is incompatible with number [2] in property `foo`.
 - Or inexact object type [3] is incompatible with exact object type [4].

   refinement.js:97:8
   97|       (x: A); // error B & {+tag_: 'A',...} ~> A
              ^

References:
   refinement.js:79:39
   79|   type B = $ReadOnly<{ tag: 'B', foo: string }>;
                                             ^^^^^^ [1]
   refinement.js:78:39
   78|   type A = $ReadOnly<{ tag: 'A', foo: number }>;
                                             ^^^^^^ [2]
   refinement.js:95:67
   95|   declare function invalid_sentinel_key(x: mixed): x is $ReadOnly<{tag_: 'A', ...}>;
                                                                         ^^^^^^^^^^^^^^^^ [3]
   refinement.js:97:11
   97|       (x: A); // error B & {+tag_: 'A',...} ~> A
                 ^ [4]


Error ----------------------------------------------------------------------------------------------- refinement.js:98:8

Cannot cast `x` to `B` because: [incompatible-cast]
 - Either number [1] is incompatible with string [2] in property `foo`.
 - Or inexact object type [3] is incompatible with exact object type [4].

   refinement.js:98:8
   98|       (x: B); // error A & {+tag_: 'A',...} ~> B
              ^

References:
   refinement.js:78:39
   78|   type A = $ReadOnly<{ tag: 'A', foo: number }>;
                                             ^^^^^^ [1]
   refinement.js:79:39
   79|   type B = $ReadOnly<{ tag: 'B', foo: string }>;
                                             ^^^^^^ [2]
   refinement.js:95:67
   95|   declare function invalid_sentinel_key(x: mixed): x is $ReadOnly<{tag_: 'A', ...}>;
                                                                         ^^^^^^^^^^^^^^^^ [3]
   refinement.js:98:11
   98|       (x: B); // error A & {+tag_: 'A',...} ~> B
                 ^ [4]


Error ---------------------------------------------------------------------------------------------- refinement.js:110:8

Cannot cast `x` to `A` because: [incompatible-cast]
 - Either string [1] is incompatible with number [2] in property `foo`.
 - Or inexact object type [3] is incompatible with exact object type [4].

   refinement.js:110:8
   110|       (x: A); // error B & {+tag: 'C', ...} ~> A
               ^

References:
   refinement.js:104:49
   104|   type B = $ReadOnly<{ tag1: 'B', tag2: 1, foo: string }>;
                                                        ^^^^^^ [1]
   refinement.js:103:49
   103|   type A = $ReadOnly<{ tag1: 'A', tag2: 1, foo: number }>;
                                                        ^^^^^^ [2]
   refinement.js:108:63
   108|   declare function unknown_sentinel(x: mixed): x is $ReadOnly<{tag: 'C', ...}>;
                                                                      ^^^^^^^^^^^^^^^ [3]
   refinement.js:110:11
   110|       (x: A); // error B & {+tag: 'C', ...} ~> A
                  ^ [4]


Error ---------------------------------------------------------------------------------------------- refinement.js:111:8

Cannot cast `x` to `B` because: [incompatible-cast]
 - Either number [1] is incompatible with string [2] in property `foo`.
 - Or inexact object type [3] is incompatible with exact object type [4].

   refinement.js:111:8
   111|       (x: B); // error A & {+tag: 'C', ...} ~> B
               ^

References:
   refinement.js:103:49
   103|   type A = $ReadOnly<{ tag1: 'A', tag2: 1, foo: number }>;
                                                        ^^^^^^ [1]
   refinement.js:104:49
   104|   type B = $ReadOnly<{ tag1: 'B', tag2: 1, foo: string }>;
                                                        ^^^^^^ [2]
   refinement.js:108:63
   108|   declare function unknown_sentinel(x: mixed): x is $ReadOnly<{tag: 'C', ...}>;
                                                                      ^^^^^^^^^^^^^^^ [3]
   refinement.js:111:11
   111|       (x: B); // error A & {+tag: 'C', ...} ~> B
                  ^ [4]


Error ---------------------------------------------------------------------------------------------- refinement.js:117:8

Cannot cast `x` to `B` because number [1] is incompatible with string [2] in property `foo`. [incompatible-cast]

   refinement.js:117:8
   117|       (x: B); // error A ~> B
               ^

References:
   refinement.js:103:49
   103|   type A = $ReadOnly<{ tag1: 'A', tag2: 1, foo: number }>;
                                                        ^^^^^^ [1]
   refinement.js:104:49
   104|   type B = $ReadOnly<{ tag1: 'B', tag2: 1, foo: string }>;
                                                        ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:117:8

Cannot cast `x` to `B` because string literal `A` [1] is incompatible with string literal `B` [2] in property `tag1`.
[incompatible-cast]

   refinement.js:117:8
   117|       (x: B); // error A ~> B
               ^

References:
   refinement.js:103:30
   103|   type A = $ReadOnly<{ tag1: 'A', tag2: 1, foo: number }>;
                                     ^^^ [1]
   refinement.js:104:30
   104|   type B = $ReadOnly<{ tag1: 'B', tag2: 1, foo: string }>;
                                     ^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:122:8

Cannot cast `x` to `A` because string [1] is incompatible with number [2] in property `foo`. [incompatible-cast]

   refinement.js:122:8
   122|       (x: A); // error B ~> A
               ^

References:
   refinement.js:104:49
   104|   type B = $ReadOnly<{ tag1: 'B', tag2: 1, foo: string }>;
                                                        ^^^^^^ [1]
   refinement.js:103:49
   103|   type A = $ReadOnly<{ tag1: 'A', tag2: 1, foo: number }>;
                                                        ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:122:8

Cannot cast `x` to `A` because string literal `B` [1] is incompatible with string literal `A` [2] in property `tag1`.
[incompatible-cast]

   refinement.js:122:8
   122|       (x: A); // error B ~> A
               ^

References:
   refinement.js:104:30
   104|   type B = $ReadOnly<{ tag1: 'B', tag2: 1, foo: string }>;
                                     ^^^ [1]
   refinement.js:103:30
   103|   type A = $ReadOnly<{ tag1: 'A', tag2: 1, foo: number }>;
                                     ^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:123:8

Cannot cast `x` to `B` because number [1] is incompatible with string [2] in property `foo`. [incompatible-cast]

   refinement.js:123:8
   123|       (x: B); // error A ~> B
               ^

References:
   refinement.js:103:49
   103|   type A = $ReadOnly<{ tag1: 'A', tag2: 1, foo: number }>;
                                                        ^^^^^^ [1]
   refinement.js:104:49
   104|   type B = $ReadOnly<{ tag1: 'B', tag2: 1, foo: string }>;
                                                        ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:123:8

Cannot cast `x` to `B` because string literal `A` [1] is incompatible with string literal `B` [2] in property `tag1`.
[incompatible-cast]

   refinement.js:123:8
   123|       (x: B); // error A ~> B
               ^

References:
   refinement.js:103:30
   103|   type A = $ReadOnly<{ tag1: 'A', tag2: 1, foo: number }>;
                                     ^^^ [1]
   refinement.js:104:30
   104|   type B = $ReadOnly<{ tag1: 'B', tag2: 1, foo: string }>;
                                     ^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:136:6

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   refinement.js:136:6
   136|     (x: string); // error number ~> string
             ^

References:
   refinement.js:132:18
   132|   declare var x: number | string;
                         ^^^^^^ [1]
   refinement.js:136:9
   136|     (x: string); // error number ~> string
                ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:139:6

Cannot cast `x` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   refinement.js:139:6
   139|     (x: number); // error string ~> number
             ^

References:
   refinement.js:132:27
   132|   declare var x: number | string;
                                  ^^^^^^ [1]
   refinement.js:139:9
   139|     (x: number); // error string ~> number
                ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:144:6

Cannot cast `x` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   refinement.js:144:6
   144|     (x: number); // error string ~> number
             ^

References:
   refinement.js:132:27
   132|   declare var x: number | string;
                                  ^^^^^^ [1]
   refinement.js:144:9
   144|     (x: number); // error string ~> number
                ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:146:6

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   refinement.js:146:6
   146|     (x: string); // error string ~> number
             ^

References:
   refinement.js:132:18
   132|   declare var x: number | string;
                         ^^^^^^ [1]
   refinement.js:146:9
   146|     (x: string); // error string ~> number
                ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:151:6

Cannot cast `x` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   refinement.js:151:6
   151|     (x: number); // error string ~> number
             ^

References:
   refinement.js:132:27
   132|   declare var x: number | string;
                                  ^^^^^^ [1]
   refinement.js:151:9
   151|     (x: number); // error string ~> number
                ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:152:6

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   refinement.js:152:6
   152|     (x: string); // error number ~> string
             ^

References:
   refinement.js:132:18
   132|   declare var x: number | string;
                         ^^^^^^ [1]
   refinement.js:152:9
   152|     (x: string); // error number ~> string
                ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:175:6

Cannot cast `maybeNumber` to empty because number [1] is incompatible with empty [2]. [incompatible-cast]

   refinement.js:175:6
   175|     (maybeNumber: empty); // error number ~> empty
             ^^^^^^^^^^^

References:
   refinement.js:172:28
   172|   declare var maybeNumber: number;
                                   ^^^^^^ [1]
   refinement.js:175:19
   175|     (maybeNumber: empty); // error number ~> empty
                          ^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:185:6

Cannot cast `anyVal` to empty because number [1] is incompatible with empty [2]. [incompatible-cast]

   refinement.js:185:6
   185|     (anyVal: empty); // error number ~> empty
             ^^^^^^

References:
   refinement.js:180:53
   180|   declare function isNumber(value: mixed): value is number;
                                                            ^^^^^^ [1]
   refinement.js:185:14
   185|     (anyVal: empty); // error number ~> empty
                     ^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:202:6

Cannot cast `x` to empty because `$FbtResultBase` [1] is incompatible with empty [2]. [incompatible-cast]

   refinement.js:202:6
   202|     (x: empty); // error Fbt ~> empty
             ^

References:
   refinement.js:198:25
   198|   declare var x: void | Fbt;
                                ^^^ [1]
   refinement.js:202:9
   202|     (x: empty); // error Fbt ~> empty
                ^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:202:6

Cannot cast `x` to empty because `FbtString` [1] is incompatible with empty [2]. [incompatible-cast]

   refinement.js:202:6
   202|     (x: empty); // error Fbt ~> empty
             ^

References:
   refinement.js:198:25
   198|   declare var x: void | Fbt;
                                ^^^ [1]
   refinement.js:202:9
   202|     (x: empty); // error Fbt ~> empty
                ^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:202:6

Cannot cast `x` to empty because string [1] is incompatible with empty [2]. [incompatible-cast]

   refinement.js:202:6
   202|     (x: empty); // error Fbt ~> empty
             ^

References:
   refinement.js:198:25
   198|   declare var x: void | Fbt;
                                ^^^ [1]
   refinement.js:202:9
   202|     (x: empty); // error Fbt ~> empty
                ^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:214:6

Cannot cast `x` to `OpaqueOrString` because: [incompatible-cast]
 - Either string [1] is incompatible with `OpaqueT` [2].
 - Or `OpaqueT` [1] is incompatible with string [3].

   refinement.js:214:6
   214|     (x: OpaqueOrString); // TODO okay, currently imported opaque type is not filtered because it's underlying type is opaque to type-guard filtering
             ^

References:
   refinement.js:211:25
   211|   declare var x: void | OpaqueOrString;
                                ^^^^^^^^^^^^^^ [1]
   opaque_exports.js:17:30
    17| export type OpaqueOrString = OpaqueT | string;
                                     ^^^^^^^ [2]
   opaque_exports.js:17:40
    17| export type OpaqueOrString = OpaqueT | string;
                                               ^^^^^^ [3]


Error ---------------------------------------------------------------------------------------------- refinement.js:225:6

Cannot cast `x` to empty because string [1] is incompatible with empty [2]. [incompatible-cast]

   refinement.js:225:6
   225|     (x: empty); // error string ~> empty
             ^

References:
   refinement.js:221:25
   221|   declare var x: void | string | any;
                                ^^^^^^ [1]
   refinement.js:225:9
   225|     (x: empty); // error string ~> empty
                ^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:235:6

Cannot cast `value` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   refinement.js:235:6
   235|     (value: string); // error number ~> string
             ^^^^^

References:
   refinement.js:230:10
   230|   value: number | string,
                 ^^^^^^ [1]
   refinement.js:235:13
   235|     (value: string); // error number ~> string
                    ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:237:6

Cannot cast `value` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   refinement.js:237:6
   237|     (value: string); // error number ~> string
             ^^^^^

References:
   refinement.js:230:10
   230|   value: number | string,
                 ^^^^^^ [1]
   refinement.js:237:13
   237|     (value: string); // error number ~> string
                    ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:238:6

Cannot cast `value` to number because string [1] is incompatible with number [2]. [incompatible-cast]

   refinement.js:238:6
   238|     (value: number); // error string ~> number
             ^^^^^

References:
   refinement.js:230:19
   230|   value: number | string,
                          ^^^^^^ [1]
   refinement.js:238:13
   238|     (value: number); // error string ~> number
                    ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:249:7

Cannot call `arr.filter` because: [incompatible-call]
 - Either number [1] is incompatible with string [2] in the type predicate.
 - Or function type [3] is incompatible with class `Boolean` [4].

   refinement.js:249:7
   249|   arr.filter(fn) as Array<string>; // error number ~> string
              ^^^^^^

References:
   refinement.js:231:34
   231|   fn: (x: mixed) => implies x is number,
                                         ^^^^^^ [1]
   refinement.js:249:27
   249|   arr.filter(fn) as Array<string>; // error number ~> string
                                  ^^^^^^ [2]
   refinement.js:231:7
   231|   fn: (x: mixed) => implies x is number,
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [3]
   refinement.js:242:24
   242|     filter(callbackfn: typeof Boolean): Array<$NonMaybeType<T>>;
                               ^^^^^^^^^^^^^^ [4]


Error --------------------------------------------------------------------------------------------- refinement.js:253:10

Cannot call `ro_arr.filter` because: [incompatible-call]
 - Either number [1] is incompatible with string [2] in the type predicate.
 - Or function type [3] is incompatible with class `Boolean` [4].

   refinement.js:253:10
   253|   ro_arr.filter(fn) as Array<string>; // error number ~> string
                 ^^^^^^

References:
   refinement.js:231:34
   231|   fn: (x: mixed) => implies x is number,
                                         ^^^^^^ [1]
   refinement.js:253:30
   253|   ro_arr.filter(fn) as Array<string>; // error number ~> string
                                     ^^^^^^ [2]
   refinement.js:231:7
   231|   fn: (x: mixed) => implies x is number,
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [3]
   <BUILTINS>/core.js:734:24
   734|     filter(callbackfn: typeof Boolean): Array<$NonMaybeType<T>>;
                               ^^^^^^^^^^^^^^ [4]


Error --------------------------------------------------------------------------------------------- refinement.js:257:10

Cannot call `rw_arr.filter` because: [incompatible-call]
 - Either number [1] is incompatible with string [2] in the type predicate.
 - Or function type [3] is incompatible with class `Boolean` [4].

   refinement.js:257:10
   257|   rw_arr.filter(fn) as Array<string>; // error number ~> string
                 ^^^^^^

References:
   refinement.js:231:34
   231|   fn: (x: mixed) => implies x is number,
                                         ^^^^^^ [1]
   refinement.js:257:30
   257|   rw_arr.filter(fn) as Array<string>; // error number ~> string
                                     ^^^^^^ [2]
   refinement.js:231:7
   231|   fn: (x: mixed) => implies x is number,
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [3]
   <BUILTINS>/core.js:734:24
   734|     filter(callbackfn: typeof Boolean): Array<$NonMaybeType<T>>;
                               ^^^^^^^^^^^^^^ [4]


Error ---------------------------------------------------------------------------------------------- refinement.js:275:7

Cannot cast `item` to `TypeA` because string literal `TypeB` [1] is incompatible with string literal `TypeA` [2] in
property `type`. [incompatible-cast]

   refinement.js:275:7
   275|       item as TypeA; // error
              ^^^^

References:
   refinement.js:262:34
   262|   type TypeB = $ReadOnly<{ type: 'TypeB', id: string }>;
                                         ^^^^^^^ [1]
   refinement.js:261:34
   261|   type TypeA = $ReadOnly<{ type: 'TypeA', id: string }>;
                                         ^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:276:7

Cannot cast `item` to `TypeB` because string literal `TypeA` [1] is incompatible with string literal `TypeB` [2] in
property `type`. [incompatible-cast]

   refinement.js:276:7
   276|       item as TypeB; // error
              ^^^^

References:
   refinement.js:261:34
   261|   type TypeA = $ReadOnly<{ type: 'TypeA', id: string }>;
                                         ^^^^^^^ [1]
   refinement.js:262:34
   262|   type TypeB = $ReadOnly<{ type: 'TypeB', id: string }>;
                                         ^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:277:7

Cannot cast `item` to `TypeC` because string literal `TypeA` [1] is incompatible with string literal `TypeC` [2] in
property `type`. [incompatible-cast]

   refinement.js:277:7
   277|       item as TypeC; // error
              ^^^^

References:
   refinement.js:261:34
   261|   type TypeA = $ReadOnly<{ type: 'TypeA', id: string }>;
                                         ^^^^^^^ [1]
   refinement.js:263:34
   263|   type TypeC = $ReadOnly<{ type: 'TypeC', id: string }>;
                                         ^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:277:7

Cannot cast `item` to `TypeC` because string literal `TypeB` [1] is incompatible with string literal `TypeC` [2] in
property `type`. [incompatible-cast]

   refinement.js:277:7
   277|       item as TypeC; // error
              ^^^^

References:
   refinement.js:262:34
   262|   type TypeB = $ReadOnly<{ type: 'TypeB', id: string }>;
                                         ^^^^^^^ [1]
   refinement.js:263:34
   263|   type TypeC = $ReadOnly<{ type: 'TypeC', id: string }>;
                                         ^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:280:7

Cannot cast `item` to `SpecialTypes` because: [incompatible-cast]
 - Either string literal `TypeC` [1] is incompatible with string literal `TypeA` [2] in property `type`.
 - Or string literal `TypeC` [1] is incompatible with string literal `TypeB` [3] in property `type`.

   refinement.js:280:7
   280|       item as SpecialTypes; // error TypeC ~> SpecialType
              ^^^^

References:
   refinement.js:263:34
   263|   type TypeC = $ReadOnly<{ type: 'TypeC', id: string }>;
                                         ^^^^^^^ [1]
   refinement.js:261:34
   261|   type TypeA = $ReadOnly<{ type: 'TypeA', id: string }>;
                                         ^^^^^^^ [2]
   refinement.js:262:34
   262|   type TypeB = $ReadOnly<{ type: 'TypeB', id: string }>;
                                         ^^^^^^^ [3]


Error ---------------------------------------------------------------------------------------------- refinement.js:282:7

Cannot cast `item` to `TypeA` because string literal `TypeC` [1] is incompatible with string literal `TypeA` [2] in
property `type`. [incompatible-cast]

   refinement.js:282:7
   282|       item as TypeA; // error
              ^^^^

References:
   refinement.js:263:34
   263|   type TypeC = $ReadOnly<{ type: 'TypeC', id: string }>;
                                         ^^^^^^^ [1]
   refinement.js:261:34
   261|   type TypeA = $ReadOnly<{ type: 'TypeA', id: string }>;
                                         ^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinement.js:283:7

Cannot cast `item` to `TypeB` because string literal `TypeC` [1] is incompatible with string literal `TypeB` [2] in
property `type`. [incompatible-cast]

   refinement.js:283:7
   283|       item as TypeB; // error
              ^^^^

References:
   refinement.js:263:34
   263|   type TypeC = $ReadOnly<{ type: 'TypeC', id: string }>;
                                         ^^^^^^^ [1]
   refinement.js:262:34
   262|   type TypeB = $ReadOnly<{ type: 'TypeB', id: string }>;
                                         ^^^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- subst.js:10:15

Cannot assign `funA(...)` to `x2` because `A` [1] is incompatible with `B` [2]. [incompatible-type]

   subst.js:10:15
   10| const x2: B = funA(isA); // error A ~> B
                     ^^^^^^^^^

References:
   subst.js:4:38
    4| declare function isA(x: mixed): x is A;
                                            ^ [1]
   subst.js:10:11
   10| const x2: B = funA(isA); // error A ~> B
                 ^ [2]


Error ---------------------------------------------------------------------------------------------------- subst.js:15:4

Cannot cast `input` to `B` because `A` [1] is incompatible with `B` [2]. [incompatible-cast]

   subst.js:15:4
   15|   (input: B); // error A ~> B
          ^^^^^

References:
   subst.js:4:38
    4| declare function isA(x: mixed): x is A;
                                            ^ [1]
   subst.js:15:11
   15|   (input: B); // error A ~> B
                 ^ [2]


Error ------------------------------------------------------------------------------------------------ subtyping.js:6:10

Cannot return `f` because type guard parameter `x` [1] does not appear in the same position as type guard parameter
`x` [2] in the type predicate. [function-predicate]

   subtyping.js:6:10
   6|   return f; // error 'x' is not in the same position as 'y'
               ^

References:
   subtyping.js:5:56
   5| function non_matching_prams(f: (x: mixed, y: mixed) => x is number): (y: mixed, x: mixed) => x is number {
                                                             ^ [1]
   subtyping.js:5:94
   5| function non_matching_prams(f: (x: mixed, y: mixed) => x is number): (y: mixed, x: mixed) => x is number {
                                                                                                   ^ [2]


Error ----------------------------------------------------------------------------------------------- subtyping.js:10:10

Cannot return `f` because function type [1], a non-type-guard function, is incompatible with function type [2], which is
a type-guard function. [function-predicate]

   subtyping.js:10:10
   10|   return f; // error non type predicate
                ^

References:
   subtyping.js:9:42
    9| function non_type_guard_to_type_guard(f: (x: mixed) => boolean): (x: mixed) => x is number {
                                                ^^^^^^^^^^^^^^^^^^^^^ [1]
   subtyping.js:9:66
    9| function non_type_guard_to_type_guard(f: (x: mixed) => boolean): (x: mixed) => x is number {
                                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- subtyping.js:20:10

Cannot return `f` because `A` [1] is incompatible with `B` [2] in the type predicate. [incompatible-return]

   subtyping.js:20:10
   20|   return f; // error A ~> B
                ^

References:
   subtyping.js:19:61
   19| function type_guard_subtyping_error_1(f: (x: mixed) => x is A): (x: mixed) => x is B {
                                                                   ^ [1]
   subtyping.js:19:84
   19| function type_guard_subtyping_error_1(f: (x: mixed) => x is A): (x: mixed) => x is B {
                                                                                          ^ [2]


Error ----------------------------------------------------------------------------------------------- subtyping.js:24:10

Cannot return `f` because `A` [1] is incompatible with `C` [2] in the type predicate. [incompatible-return]

   subtyping.js:24:10
   24|   return f; // error A ~> C
                ^

References:
   subtyping.js:23:61
   23| function type_guard_subtyping_error_2(f: (x: mixed) => x is A): (x: mixed) => x is C {
                                                                   ^ [1]
   subtyping.js:23:84
   23| function type_guard_subtyping_error_2(f: (x: mixed) => x is A): (x: mixed) => x is C {
                                                                                          ^ [2]


Error ----------------------------------------------------------------------------------------------- subtyping.js:28:10

Cannot return `f` because read-only array type [1] is incompatible with array type [2] in the type predicate.
[incompatible-return]

   subtyping.js:28:10
   28|   return f; // error
                ^

References:
   subtyping.js:27:64
   27| function type_guard_subtyping_error_3(f: <A>(x: mixed) => x is $ReadOnlyArray<A>): <B>(x: mixed) => x is Array<B> {
                                                                      ^^^^^^^^^^^^^^^^^ [1]
   subtyping.js:27:106
   27| function type_guard_subtyping_error_3(f: <A>(x: mixed) => x is $ReadOnlyArray<A>): <B>(x: mixed) => x is Array<B> {
                                                                                                                ^^^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- subtyping.js:32:10

Cannot return `f` because `A` [1] is incompatible with `C` [2] in the type predicate. [incompatible-return]

   subtyping.js:32:10
   32|   return f; // error C <~> A
                ^

References:
   subtyping.js:31:84
   31| function type_guard_subtyping_error_4(f: (x: mixed) => x is C): (x: mixed) => x is A {
                                                                                          ^ [1]
   subtyping.js:31:61
   31| function type_guard_subtyping_error_4(f: (x: mixed) => x is C): (x: mixed) => x is A {
                                                                   ^ [2]


Error ----------------------------------------------------------------------------------------------- subtyping.js:36:10

Cannot return `f` because read-only array type [1] is incompatible with array type [2] in the type predicate.
[incompatible-return]

   subtyping.js:36:10
   36|   return f; // error Array<A> <~> $ReadOnlyArray<B>
                ^

References:
   subtyping.js:35:97
   35| function type_guard_subtyping_error_5(f: <A>(x: mixed) => x is Array<A>): <B>(x: mixed) => x is $ReadOnlyArray<B> {
                                                                                                       ^^^^^^^^^^^^^^^^^ [1]
   subtyping.js:35:64
   35| function type_guard_subtyping_error_5(f: <A>(x: mixed) => x is Array<A>): <B>(x: mixed) => x is $ReadOnlyArray<B> {
                                                                      ^^^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- subtyping.js:56:10

Cannot return `f` because one-sided type guard [1] is incompatible with default type guard [2]. [function-predicate]

   subtyping.js:56:10
   56|   return f; // error
                ^

References:
   subtyping.js:55:64
   55| function type_guard_subtyping_one_sided_error(f: (x: mixed) => implies x is A): (x: mixed) => x is A {
                                                                      ^^^^^^^^^^^^^^ [1]
   subtyping.js:55:95
   55| function type_guard_subtyping_one_sided_error(f: (x: mixed) => implies x is A): (x: mixed) => x is A {
                                                                                                     ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- subtyping.js:66:10

Cannot return `f` because `A` [1] is incompatible with `C` [2] in the type predicate of array element.
[incompatible-return]

   subtyping.js:66:10
   66|   return f; // error C ~ A
                ^

References:
   subtyping.js:65:92
   65| function type_guard_unif_error_1(f: Array<(x: mixed) => x is C>): Array<(x: mixed) => x is A> {
                                                                                                  ^ [1]
   subtyping.js:65:62
   65| function type_guard_unif_error_1(f: Array<(x: mixed) => x is C>): Array<(x: mixed) => x is A> {
                                                                    ^ [2]


Error ----------------------------------------------------------------------------------------------- subtyping.js:70:10

Cannot return `f` because `A` [1] is incompatible with `B` [2] in the type predicate of array element.
[incompatible-return]

   subtyping.js:70:10
   70|   return f; // errors A ~> B, B ~> A
                ^

References:
   subtyping.js:69:62
   69| function type_guard_unif_error_2(f: Array<(x: mixed) => x is A>): Array<(x: mixed) => x is B> {
                                                                    ^ [1]
   subtyping.js:69:92
   69| function type_guard_unif_error_2(f: Array<(x: mixed) => x is A>): Array<(x: mixed) => x is B> {
                                                                                                  ^ [2]


Error ----------------------------------------------------------------------------------------------- subtyping.js:74:10

Cannot return `f` because `A` [1] is incompatible with `C` [2] in the type predicate of array element.
[incompatible-return]

   subtyping.js:74:10
   74|   return f; // error A ~> C
                ^

References:
   subtyping.js:73:62
   73| function type_guard_unif_error_3(f: Array<(x: mixed) => x is A>): Array<(x: mixed) => x is C> {
                                                                    ^ [1]
   subtyping.js:73:92
   73| function type_guard_unif_error_3(f: Array<(x: mixed) => x is A>): Array<(x: mixed) => x is C> {
                                                                                                  ^ [2]


Error ----------------------------------------------------------------------------------------------- subtyping.js:82:10

Cannot return `f` because one-sided type guard [1] is incompatible with default type guard [2] in array element. Arrays
are invariantly typed. See
https://flow.org/en/docs/faq/#why-cant-i-pass-an-arraystring-to-a-function-that-takes-an-arraystring-number.
[function-predicate]

   subtyping.js:82:10
   82|   return f; // error
                ^

References:
   subtyping.js:81:95
   81| function type_guard_unif_one_sided_error(f: Array<(x: mixed) => x is A>): Array<(x: mixed) => implies x is A> {
                                                                                                     ^^^^^^^^^^^^^^ [1]
   subtyping.js:81:65
   81| function type_guard_unif_one_sided_error(f: Array<(x: mixed) => x is A>): Array<(x: mixed) => implies x is A> {
                                                                       ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------------- this.js:19:39

Cannot use this [1] as a type guard variable in this context. `this` type guards are only supported in non-static
declare class or interface methods. [function-predicate]

   19|     isB_prop: (this: A, x: number) => this is B; // error only on methods
                                             ^^^^ [1]


Error ---------------------------------------------------------------------------------------------------- this.js:20:26

Cannot use this [1] as a type guard variable in this context. `this` type guards are only supported in non-static
declare class or interface methods. [function-predicate]

   20|     static isB_static(): this is B; // error only on instance methods
                                ^^^^ [1]


Error ----------------------------------------------------------------------------------------------------- this.js:28:5

Cannot extend `A` [1] with `E` because `B` [2] is incompatible with `C` [3] in the type predicate of property `isB`.
[incompatible-extend]

   this.js:28:5
   28|     isB(): this is C; // error type guard is in invariant position
           ^^^^^^^^^^^^^^^^

References:
   this.js:27:27
   27|   declare class E extends A {
                                 ^ [1]
   this.js:15:20
   15|     isB(): this is B; // okay
                          ^ [2]
   this.js:28:20
   28|     isB(): this is C; // error type guard is in invariant position
                          ^ [3]


Error ----------------------------------------------------------------------------------------------------- this.js:41:5

Cannot cast `a` to `B` because `A` [1] is incompatible with `B` [2]. [incompatible-cast]

   this.js:41:5
   41|     a as B; // error
           ^

References:
   this.js:36:18
   36|   declare var a: A;
                        ^ [1]
   this.js:41:10
   41|     a as B; // error
                ^ [2]


Error ----------------------------------------------------------------------------------------------------- this.js:59:5

Cannot cast `b` to empty because `B` [1] is incompatible with empty [2]. [incompatible-cast]

   this.js:59:5
   59|     b as empty; // error - not refining else branch
           ^

References:
   this.js:47:18
   47|   declare var b: B;
                        ^ [1]
   this.js:59:10
   59|     b as empty; // error - not refining else branch
                ^^^^^ [2]


Error ----------------------------------------------------------------------------------------------------- this.js:65:5

Cannot cast `b` to `D` because `B` [1] is incompatible with `D` [2]. [incompatible-cast]

   this.js:65:5
   65|     b as D; // error
           ^

References:
   this.js:47:18
   47|   declare var b: B;
                        ^ [1]
   this.js:65:10
   65|     b as D; // error
                ^ [2]


Error ----------------------------------------------------------------------------------------------------- this.js:68:5

Cannot cast `B` to `B` because class `B` [1] is incompatible with `B` [2]. [incompatible-cast]

   this.js:68:5
   68|     B as B; // error class B ~> B
           ^

References:
   this.js:23:17
   23|   declare class B extends A {}
                       ^ [1]
   this.js:68:10
   68|     B as B; // error class B ~> B
                ^ [2]


Error ----------------------------------------------------------------------------------------------------- this.js:86:5

Cannot cast `i` to `B` because `I` [1] is incompatible with `B` [2]. [incompatible-cast]

   this.js:86:5
   86|     i as B; // error
           ^

References:
   this.js:82:18
   82|   declare var i: I;
                        ^ [1]
   this.js:86:10
   86|     i as B; // error
                ^ [2]


Error ---------------------------------------------------------------------------------------------------- this.js:90:19

Cannot get `x.isB` because property `isB` [1] cannot be unbound from the context [2] where it was defined.
[method-unbinding]

   this.js:90:19
   90|     const isB = x.isB // error method-unbinding
                         ^^^ [1]

References:
   this.js:15:5
   15|     isB(): this is B; // okay
           ^^^^^^^^^^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------------- this.js:98:27

Cannot use this [1] as a type guard variable in this context. `this` type guards are only supported in non-static
declare class or interface methods. [function-predicate]

   98|   type T1 = (x: mixed) => this is C; // error only on declare classes/interfaces
                                 ^^^^ [1]


Error --------------------------------------------------------------------------------------------------- this.js:100:32

Cannot use this [1] as a type guard variable in this context. `this` type guards are only supported in non-static
declare class or interface methods. [function-predicate]

   100|   type T2 = (cb: (x: mixed) => this is C) => void; // error only on declare classes/interfaces
                                       ^^^^ [1]


Error --------------------------------------------------------------------------------------------------- this.js:102:27

Cannot use this [1] as a type guard variable in this context. `this` type guards are only supported in non-static
declare class or interface methods. [function-predicate]

   102|   type T3 = (x: mixed) => this is Unresolved; // error only on declare classes/interfaces, Unresolved
                                  ^^^^ [1]


Error --------------------------------------------------------------------------------------------------- this.js:102:35

Cannot resolve name `Unresolved`. [cannot-resolve-name]

   102|   type T3 = (x: mixed) => this is Unresolved; // error only on declare classes/interfaces, Unresolved
                                          ^^^^^^^^^^


Error --------------------------------------------------------------------------------------------------- this.js:105:10

Cannot use this [1] as a type guard variable in this context. `this` type guards are only supported in non-static
declare class or interface methods. [function-predicate]

   105|     m(): this is C; // error only on declare classes/interfaces
                 ^^^^ [1]


Error --------------------------------------------------------------------------------------------------- this.js:106:14

Cannot use this [1] as a type guard variable in this context. `this` type guards are only supported in non-static
declare class or interface methods. [function-predicate]

   106|     f: () => this is C; // error only on declare classes/interfaces
                     ^^^^ [1]


Error ---------------------------------------------------------------------------------------------------- this.js:111:5

Cannot cast `x` to `C` because `T4` [1] is incompatible with `C` [2]. [incompatible-cast]

   this.js:111:5
   111|     x as C; // error should not refine
            ^

References:
   this.js:109:18
   109|   declare var x: T4;
                         ^^ [1]
   this.js:111:10
   111|     x as C; // error should not refine
                 ^ [2]


Error --------------------------------------------------------------------------------------------------- this.js:115:25

Cannot use this [1] as a type guard variable in this context. `this` type guards are only supported in non-static
declare class or interface methods. [function-predicate]

   115|     m(cb: (x: mixed) => this is C): void; // error only on declare classes/interfaces method return
                                ^^^^ [1]


Error --------------------------------------------------------------------------------------------------- this.js:116:24

Cannot use this [1] as a type guard variable in this context. `this` type guards are only supported in non-static
declare class or interface methods. [function-predicate]

   116|     n(): (x: mixed) => this is C; // error only on declare classes/interfaces method return
                               ^^^^ [1]


Error --------------------------------------------------------------------------------------------------- this.js:119:27

Cannot use this [1] as a type guard variable in this context. `this` type guards are only supported in non-static
declare class or interface methods. [function-predicate]

   119|   function foo1(this: C): this is C {  // error 'this' type guard only on declare classes
                                  ^^^^ [1]


Error --------------------------------------------------------------------------------------------------- this.js:123:27

Cannot use this [1] as a type guard variable in this context. `this` type guards are only supported in non-static
declare class or interface methods. [function-predicate]

   123|   function foo2(this: C): this is Unresolved {  // error 'this' type guard only on declare classes, unresolved
                                  ^^^^ [1]


Error --------------------------------------------------------------------------------------------------- this.js:123:35

Cannot resolve name `Unresolved`. [cannot-resolve-name]

   123|   function foo2(this: C): this is Unresolved {  // error 'this' type guard only on declare classes, unresolved
                                          ^^^^^^^^^^


Error ---------------------------------------------------------------------------------------------------- this.js:143:5

Cannot cast `x` to `D` because number [1] is incompatible with string [2] in type argument `X` [3]. [incompatible-cast]

   this.js:143:5
   143|     x as D<string>; // error number ~> string
            ^

References:
   this.js:139:20
   139|   declare var x: C<number>;
                           ^^^^^^ [1]
   this.js:143:12
   143|     x as D<string>; // error number ~> string
                   ^^^^^^ [2]
   this.js:137:20
   137|   declare class D<+X> extends C<X> {}
                           ^ [3]


Error ---------------------------------------------------------------------------------------------------- this.js:152:5

Cannot cast `x` to `D` because number [1] is incompatible with string [2] in type argument `X` [3]. [incompatible-cast]

   this.js:152:5
   152|     x as D<string>; // error number ~> string
            ^

References:
   this.js:150:12
   150|   if (x.m2<number>()) {
                   ^^^^^^ [1]
   this.js:152:12
   152|     x as D<string>; // error number ~> string
                   ^^^^^^ [2]
   this.js:137:20
   137|   declare class D<+X> extends C<X> {}
                           ^ [3]


Error ---------------------------------------------------------------------------------------------------- this.js:157:5

Cannot cast `x` to `D` because number [1] is incompatible with string [2] in type argument `X` [3]. [incompatible-cast]

   this.js:157:5
   157|     x as D<string>; // error number ~> string
            ^

References:
   this.js:155:12
   155|   if (x.m3(1)) {
                   ^ [1]
   this.js:157:12
   157|     x as D<string>; // error number ~> string
                   ^^^^^^ [2]
   this.js:137:20
   137|   declare class D<+X> extends C<X> {}
                           ^ [3]


Error ---------------------------------------------------------------------------------------------------- this.js:181:6

Cannot call `fn` with `new B` bound to `cb` because function type [1], a non-type-guard function, is incompatible with
function type [2], which is a type-guard function in property `m`. [function-predicate]

   this.js:181:6
   181|   fn(new B); // error no type-guard
             ^^^^^

References:
   this.js:174:21
   174|   declare class B { m(): boolean }
                            ^^^^^^^^^^^^ [1]
   this.js:177:39
   177|   declare function fn(cb: interface { m(): this is D }): void;
                                              ^^^^^^^^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------------- this.js:186:5

Cannot extend `AImported` [1] with `E` because `B` [2] is incompatible with `C` [3] in the type predicate of property
`isB`. [incompatible-extend]

   this.js:186:5
   186|     isB(): this is CImported; // error type guard is in invariant position
            ^^^^^^^^^^^^^^^^^^^^^^^^

References:
   this.js:185:27
   185|   declare class E extends AImported {
                                  ^^^^^^^^^ [1]
   this_exports.js:2:18
     2|   isB(): this is B;
                         ^ [2]
   this.js:186:20
   186|     isB(): this is CImported; // error type guard is in invariant position
                           ^^^^^^^^^ [3]


Error ---------------------------------------------------------------------------------------------------- this.js:195:5

Cannot cast `a` to `BImported` because `A` [1] is incompatible with `B` [2]. [incompatible-cast]

   this.js:195:5
   195|     a as BImported; // error
            ^

References:
   this.js:190:18
   190|   declare var a: AImported;
                         ^^^^^^^^^ [1]
   this.js:195:10
   195|     a as BImported; // error
                 ^^^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------------- this.js:213:5

Cannot cast `b` to empty because `B` [1] is incompatible with empty [2]. [incompatible-cast]

   this.js:213:5
   213|     b as empty; // error - not refining else branch
            ^

References:
   this.js:201:18
   201|   declare var b: BImported;
                         ^^^^^^^^^ [1]
   this.js:213:10
   213|     b as empty; // error - not refining else branch
                 ^^^^^ [2]


Error ---------------------------------------------------------------------------------------------------- this.js:219:5

Cannot cast `b` to `DImported` because `B` [1] is incompatible with `D` [2]. [incompatible-cast]

   this.js:219:5
   219|     b as DImported; // error
            ^

References:
   this.js:201:18
   201|   declare var b: BImported;
                         ^^^^^^^^^ [1]
   this.js:219:10
   219|     b as DImported; // error
                 ^^^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------------- this.js:222:5

Cannot cast `BImported` to `BImported` because class `B` [1] is incompatible with `B` [2]. [incompatible-cast]

   this.js:222:5
   222|     BImported as BImported; // error class B ~> B
            ^^^^^^^^^

References:
   this_exports.js:9:22
     9| declare export class B extends A {}
                             ^ [1]
   this.js:222:18
   222|     BImported as BImported; // error class B ~> B
                         ^^^^^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- this.js:237:19

Cannot get `x.isB` because property `isB` [1] cannot be unbound from the context [2] where it was defined.
[method-unbinding]

   this.js:237:19
   237|     const isB = x.isB // error method-unbinding
                          ^^^ [1]

References:
   this_exports.js:2:3
     2|   isB(): this is B;
          ^^^^^^^^^^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------------- this.js:243:5

Cannot cast `e` to `FImported` because `E` [1] is incompatible with `F` [2]. [incompatible-cast]

   this.js:243:5
   243|     e as FImported; // error this type guard is on a regular class
            ^

References:
   this.js:241:18
   241|   declare var e: EImported;
                         ^^^^^^^^^ [1]
   this.js:243:10
   243|     e as FImported; // error this type guard is on a regular class
                 ^^^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------------- this.js:246:5

Cannot cast `e` to `FImported` because `E` [1] is incompatible with `F` [2]. [incompatible-cast]

   this.js:246:5
   246|     e as FImported; // error
            ^

References:
   this.js:241:18
   241|   declare var e: EImported;
                         ^^^^^^^^^ [1]
   this.js:246:10
   246|     e as FImported; // error
                 ^^^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------------- this.js:253:5

Cannot cast `i` to `BImported` because `I` [1] is incompatible with `B` [2]. [incompatible-cast]

   this.js:253:5
   253|     i as BImported; // error
            ^

References:
   this.js:249:18
   249|   declare var i: IImported;
                         ^^^^^^^^^ [1]
   this.js:253:10
   253|     i as BImported; // error
                 ^^^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------------- this.js:274:5

Cannot cast `x` to `B` because `A` [1] is incompatible with `B` [2]. [incompatible-cast]

   this.js:274:5
   274|     x as B; // TODO okay (relax this limitation)
            ^

References:
   this.js:270:18
   270|   declare var x: A;
                         ^ [1]
   this.js:274:10
   274|     x as B; // TODO okay (relax this limitation)
                 ^ [2]


Error --------------------------------------------------------------------------------------------- this_exports.js:6:24

Cannot use this [1] as a type guard variable in this context. `this` type guards are only supported in non-static
declare class or interface methods. [function-predicate]

   6|   static isB_static(): this is B; // error should not export this guard
                             ^^^^ [1]


Error -------------------------------------------------------------------------------------------- this_exports.js:14:10

Cannot use this [1] as a type guard variable in this context. `this` type guards are only supported in non-static
declare class or interface methods. [function-predicate]

   14|   isF(): this is F { // error
                ^^^^ [1]


Error ----------------------------------------------------------------------------------------- tuple_refinement.js:11:7

Cannot cast `x` to `B` because string literal `A` [1] is incompatible with string literal `B` [2] in index 0.
[incompatible-cast]

   tuple_refinement.js:11:7
   11|       x as B; // ERROR: A ~> B
             ^

References:
   tuple_refinement.js:2:11
    2| type A = ['A', number];
                 ^^^ [1]
   tuple_refinement.js:3:11
    3| type B = ['B', string];
                 ^^^ [2]


Error ----------------------------------------------------------------------------------------- tuple_refinement.js:11:7

Cannot cast `x` to `B` because number [1] is incompatible with string [2] in index 1. [incompatible-cast]

   tuple_refinement.js:11:7
   11|       x as B; // ERROR: A ~> B
             ^

References:
   tuple_refinement.js:2:16
    2| type A = ['A', number];
                      ^^^^^^ [1]
   tuple_refinement.js:3:16
    3| type B = ['B', string];
                      ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------- tuple_refinement.js:31:7

Cannot cast `x` to `ROB` because string literal `A` [1] is incompatible with string literal `B` [2] in index 0.
[incompatible-cast]

   tuple_refinement.js:31:7
   31|       x as ROB; // ERROR: A ~> B
             ^

References:
   tuple_refinement.js:22:23
   22| type ROA = $ReadOnly<['A', number]>;
                             ^^^ [1]
   tuple_refinement.js:23:23
   23| type ROB = $ReadOnly<['B', string]>;
                             ^^^ [2]


Error ----------------------------------------------------------------------------------------- tuple_refinement.js:31:7

Cannot cast `x` to `ROB` because number [1] is incompatible with string [2] in index 1. [incompatible-cast]

   tuple_refinement.js:31:7
   31|       x as ROB; // ERROR: A ~> B
             ^

References:
   tuple_refinement.js:22:28
   22| type ROA = $ReadOnly<['A', number]>;
                                  ^^^^^^ [1]
   tuple_refinement.js:23:28
   23| type ROB = $ReadOnly<['B', string]>;
                                  ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------- tuple_refinement.js:51:7

Cannot cast `x` to `MTB` because string literal `A` [1] is incompatible with string literal `B` [2] in index 0.
[incompatible-cast]

   tuple_refinement.js:51:7
   51|       x as MTB; // ERROR: A ~> B
             ^

References:
   tuple_refinement.js:42:23
   42| type MTA = $ReadOnly<['A', 1, number]>;
                             ^^^ [1]
   tuple_refinement.js:43:23
   43| type MTB = $ReadOnly<['B', 1, string]>;
                             ^^^ [2]


Error ----------------------------------------------------------------------------------------- tuple_refinement.js:51:7

Cannot cast `x` to `MTB` because number [1] is incompatible with string [2] in index 2. [incompatible-cast]

   tuple_refinement.js:51:7
   51|       x as MTB; // ERROR: A ~> B
             ^

References:
   tuple_refinement.js:42:31
   42| type MTA = $ReadOnly<['A', 1, number]>;
                                     ^^^^^^ [1]
   tuple_refinement.js:43:31
   43| type MTB = $ReadOnly<['B', 1, string]>;
                                     ^^^^^^ [2]


Error -------------------------------------------------------------------------------- type_guard_compatibility.js:15:30

Cannot use `B` [1] as type prediate for parameter `x` because `B` [1] is incompatible with `A` [2]. A user defined type
guard needs to be compatible with its parameter's type. [incompatible-type-guard]

   type_guard_compatibility.js:15:30
   15| function error_1(x: A): x is B { // error B ~> A
                                    ^ [1]

References:
   type_guard_compatibility.js:15:21
   15| function error_1(x: A): x is B { // error B ~> A
                           ^ [2]


Error -------------------------------------------------------------------------------- type_guard_compatibility.js:19:59

Cannot use array type [1] as type prediate for parameter `x` because mixed [2] is incompatible with `X` [3] in array
element. A user defined type guard needs to be compatible with its parameter's type. [incompatible-type-guard]

   type_guard_compatibility.js:19:59
   19| declare function error_poly_1<X>(x: Array<X>): x is Array<mixed>; // error mixed ~> X
                                                                 ^^^^^ [2]

References:
   type_guard_compatibility.js:19:53
   19| declare function error_poly_1<X>(x: Array<X>): x is Array<mixed>; // error mixed ~> X
                                                           ^^^^^^^^^^^^ [1]
   type_guard_compatibility.js:19:43
   19| declare function error_poly_1<X>(x: Array<X>): x is Array<mixed>; // error mixed ~> X
                                                 ^ [3]


Error -------------------------------------------------------------------------------- type_guard_compatibility.js:27:33

Cannot use `B` [1] as type prediate for parameter `x` because `B` [1] is incompatible with `A` [2]. A user defined type
guard needs to be compatible with its parameter's type. [incompatible-type-guard]

   type_guard_compatibility.js:27:33
   27| type F_error_1 = (x: A) => x is B; // error B ~> A
                                       ^ [1]

References:
   type_guard_compatibility.js:27:22
   27| type F_error_1 = (x: A) => x is B; // error B ~> A
                            ^ [2]


Error -------------------------------------------------------------------------------- type_guard_compatibility.js:29:54

Cannot use array type [1] as type prediate for parameter `x` because mixed [2] is incompatible with `X` [3] in array
element. A user defined type guard needs to be compatible with its parameter's type. [incompatible-type-guard]

   type_guard_compatibility.js:29:54
   29| type F_error_poly_1 = <X>(x: Array<X>) => x is Array<mixed>; // error mixed ~> X
                                                            ^^^^^ [2]

References:
   type_guard_compatibility.js:29:48
   29| type F_error_poly_1 = <X>(x: Array<X>) => x is Array<mixed>; // error mixed ~> X
                                                      ^^^^^^^^^^^^ [1]
   type_guard_compatibility.js:29:36
   29| type F_error_poly_1 = <X>(x: Array<X>) => x is Array<mixed>; // error mixed ~> X
                                          ^ [3]


Error -------------------------------------------------------------------------------- type_guard_compatibility.js:30:54

Cannot use array type [1] as type prediate for parameter `x` because mixed [2] is incompatible with `X` [3] in array
element. A user defined type guard needs to be compatible with its parameter's type. [incompatible-type-guard]

   type_guard_compatibility.js:30:54
   30| type F_error_poly_2<X> = (x: Array<X>) => x is Array<mixed>; // error mixed ~> X
                                                            ^^^^^ [2]

References:
   type_guard_compatibility.js:30:48
   30| type F_error_poly_2<X> = (x: Array<X>) => x is Array<mixed>; // error mixed ~> X
                                                      ^^^^^^^^^^^^ [1]
   type_guard_compatibility.js:30:36
   30| type F_error_poly_2<X> = (x: Array<X>) => x is Array<mixed>; // error mixed ~> X
                                          ^ [3]


Error -------------------------------------------------------------------------------------------------- unbound.js:1:23

Cannot find type guard parameter `x` [1] in the parameters of this function (type). [function-predicate]

   1| function no_params(): x is number { // error x unbound
                            ^ [1]


Error -------------------------------------------------------------------------------------------------- unbound.js:5:47

Cannot find type guard parameter `y` [1] in the parameters of this function (type). [function-predicate]

   5| function unbound_type_guard_param(x: number): y is number {  // error y is not a param
                                                    ^ [1]


Error -------------------------------------------------------------------------------------------------- unbound.js:9:23

Cannot find type guard parameter `x` [1] in the parameters of this function (type). [function-predicate]

   9| type No_param = () => x is number; // error x unbound
                            ^ [1]


Error ------------------------------------------------------------------------------------------------- unbound.js:11:37

Cannot find type guard parameter `x` [1] in the parameters of this function (type). [function-predicate]

   11| type Unbound_param = (y: number) => x is number; // error x unbound
                                           ^ [1]


Error ------------------------------------------------------------------------------------------------- unbound.js:13:34

Cannot find type guard parameter `x` [1] in the parameters of this function (type). [function-predicate]

   13| type No_param_name = (number) => x is number; // error x unbound
                                        ^ [1]



Found 222 errors

Only showing the most relevant union/intersection branches.
To see all branches, re-run Flow with --show-all-branches
