Error ------------------------------------------------------------------------------------------------ arr_spread.js:7:3

Cannot call `fn` because rest array [1] is incompatible with `X` [2]. [incompatible-call]

   arr_spread.js:7:3
   7|   fn(...arr) as R; // nope
        ^^

References:
   arr_spread.js:7:3
   7|   fn(...arr) as R; // nope
        ^^^^^^^^^^ [1]
   arr_spread.js:5:41
   5| function f<X: Array<number>, R>(fn: (...X) => R, x: X, arr: Array<number>) {
                                              ^ [2]


Error ---------------------------------------------------------------------------------------------- arr_spread.js:17:12

Cannot return array literal because array literal [1] is incompatible with `X` [2]. [incompatible-return]

   arr_spread.js:17:12
   17|     return [...B, 42]; // nope
                  ^^^^^^^^^^ [1]

References:
   arr_spread.js:12:37
   12| function g<X: Array<number>>(A: X): X {
                                           ^ [2]


Error ---------------------------------------------------------------------------------------------- arr_spread.js:23:14

Cannot assign array literal to `z` because array literal [1] is incompatible with `X` [2]. [incompatible-type]

   arr_spread.js:23:14
   23|   var z: X = ['3', ...x]; // nope
                    ^^^^^^^^^^^ [1]

References:
   arr_spread.js:23:10
   23|   var z: X = ['3', ...x]; // nope
                ^ [2]


Error ----------------------------------------------------------------------------------------------- arr_spread.js:27:3

Cannot call `f` because rest array [1] has 1 element but tuple type [2] has 2 elements. [invalid-tuple-arity]

   arr_spread.js:27:3
   27|   f(...x); // nope
         ^

References:
   arr_spread.js:27:3
   27|   f(...x); // nope
         ^^^^^^^ [1]
   arr_spread.js:26:54
   26| function w<A: [number, number]>(x: A, f: (number, ...A) => void) {
                                                            ^ [2]


Error ----------------------------------------------------------------------------------------------- arr_spread.js:28:3

Cannot call `f` because rest array [1] is incompatible with `A` [2]. [incompatible-call]

   arr_spread.js:28:3
   28|   f(42, 42, 42); // nope
         ^

References:
   arr_spread.js:28:3
   28|   f(42, 42, 42); // nope
         ^^^^^^^^^^^^^ [1]
   arr_spread.js:26:54
   26| function w<A: [number, number]>(x: A, f: (number, ...A) => void) {
                                                            ^ [2]


Error ----------------------------------------------------------------------------------------------- arr_spread.js:30:3

Cannot call `f` because rest array [1] has 4 elements but tuple type [2] has 2 elements. [invalid-tuple-arity]

   arr_spread.js:30:3
   30|   f(42, ...x, ...x); // nope
         ^

References:
   arr_spread.js:30:3
   30|   f(42, ...x, ...x); // nope
         ^^^^^^^^^^^^^^^^^ [1]
   arr_spread.js:26:54
   26| function w<A: [number, number]>(x: A, f: (number, ...A) => void) {
                                                            ^ [2]


Error ----------------------------------------------------------------------------------------------- arr_spread.js:34:3

Cannot call `f` because rest array [1] is incompatible with `A` [2]. [incompatible-call]

   arr_spread.js:34:3
   34|   f(42, 42, 42); // nope
         ^

References:
   arr_spread.js:34:3
   34|   f(42, 42, 42); // nope
         ^^^^^^^^^^^^^ [1]
   arr_spread.js:32:52
   32| function w2<A: Array<number>>(x: A, f: (number, ...A) => void) {
                                                          ^ [2]


Error ----------------------------------------------------------------------------------------------- arr_spread.js:35:3

Cannot call `f` because rest array [1] is incompatible with `A` [2]. [incompatible-call]

   arr_spread.js:35:3
   35|   f(42, 42, 42, ...x); // should be nope
         ^

References:
   arr_spread.js:35:3
   35|   f(42, 42, 42, ...x); // should be nope
         ^^^^^^^^^^^^^^^^^^^ [1]
   arr_spread.js:32:52
   32| function w2<A: Array<number>>(x: A, f: (number, ...A) => void) {
                                                          ^ [2]


Error ----------------------------------------------------------------------------------------------- arr_spread.js:40:5

Cannot call `f` with array literal bound to the first parameter because array literal [1] is incompatible with `A` [2].
[incompatible-call]

   arr_spread.js:40:5
   40|   f([42, 42, 42]); // nope
           ^^^^^^^^^^^^ [1]

References:
   arr_spread.js:39:40
   39| function w3<A: Array<number>>(x: A, f: A => void) {
                                              ^ [2]


Error ----------------------------------------------------------------------------------------------- arr_spread.js:41:5

Cannot call `f` with array literal bound to the first parameter because array literal [1] is incompatible with `A` [2].
[incompatible-call]

   arr_spread.js:41:5
   41|   f([42, ...x]); // should be nope
           ^^^^^^^^^^ [1]

References:
   arr_spread.js:39:40
   39| function w3<A: Array<number>>(x: A, f: A => void) {
                                              ^ [2]


Error ----------------------------------------------------------------------------------------------- arr_spread.js:47:3

Cannot cast array literal to `Y` because array literal [1] is incompatible with `Y` [2]. [incompatible-cast]

   arr_spread.js:47:3
   47|   [...x, ...y] as Y; // should be nope
         ^^^^^^^^^^^^ [1]

References:
   arr_spread.js:47:19
   47|   [...x, ...y] as Y; // should be nope
                         ^ [2]


Error ----------------------------------------------------------------------------------------------- arr_spread.js:48:3

Cannot cast array literal to `X` because array literal [1] is incompatible with `X` [2]. [incompatible-cast]

   arr_spread.js:48:3
   48|   [...x, ...y] as X; // should be nope
         ^^^^^^^^^^^^ [1]

References:
   arr_spread.js:48:19
   48|   [...x, ...y] as X; // should be nope
                         ^ [2]


Error ----------------------------------------------------------------------------------------------- arr_spread.js:52:3

Cannot cast array literal to `Y` because array literal [1] is incompatible with `Y` [2]. [incompatible-cast]

   arr_spread.js:52:3
   52|   [...x, ...y] as Y; // should be nope
         ^^^^^^^^^^^^ [1]

References:
   arr_spread.js:52:19
   52|   [...x, ...y] as Y; // should be nope
                         ^ [2]


Error ---------------------------------------------------------------------------------------------- arr_spread.js:61:10

Cannot return array literal because array literal [1] is incompatible with `X` [2]. [incompatible-return]

   arr_spread.js:61:10
   61|   return [...x, ...x]; // nope, because X could be a tuple
                ^^^^^^^^^^^^ [1]

References:
   arr_spread.js:60:46
   60| function b<X: $ReadOnlyArray<number>>(x: X): X {
                                                    ^ [2]


Error ---------------------------------------------------------------------------------------------- arr_spread.js:65:10

Cannot return array literal because array literal [1] is incompatible with `X` [2]. [incompatible-return]

   arr_spread.js:65:10
   65|   return [42, ...x]; // error
                ^^^^^^^^^^ [1]

References:
   arr_spread.js:64:46
   64| function c<X: $ReadOnlyArray<number>>(x: X): X {
                                                    ^ [2]


Error ---------------------------------------------------------------------------------------------- arr_spread.js:69:10

Cannot return array literal because array literal [1] has 4 elements but tuple type [2] has 2 elements.
[invalid-tuple-arity]

   arr_spread.js:69:10
   69|   return [...x, ...x]; // error
                ^^^^^^^^^^^^ [1]

References:
   arr_spread.js:68:40
   68| function d<X: [number, number]>(x: X): X {
                                              ^ [2]


Error --------------------------------------------------------------------------------------------- basic_class.js:12:12

Cannot return `this.x` because mixed [1] is incompatible with `Y` [2]. [incompatible-return]

   basic_class.js:12:12
   12|     return this.x;
                  ^^^^^^

References:
   basic_class.js:4:6
    4|   x: X;
            ^ [1]
   basic_class.js:11:14
   11|   get_bad(): Y {
                    ^ [2]


Error --------------------------------------------------------------------------------------------- basic_class.js:28:14

Cannot return `this.get_bad()` because number [1] is incompatible with `X` [2]. [incompatible-return]

   basic_class.js:28:14
   28|       return this.get_bad();
                    ^^^^^^^^^^^^^^

References:
   basic_class.js:24:25
   24| class E<X> extends C<X, number> {
                               ^^^^^^ [1]
   basic_class.js:25:14
   25|   set(x: X): X {
                    ^ [2]


Error ------------------------------------------------------------------------------------------- basic_function.js:7:19

Cannot assign `x` to `z` because mixed [1] is incompatible with number [2]. [incompatible-type]

   basic_function.js:7:19
   7|   var z: number = x;
                        ^

References:
   basic_function.js:5:18
   5| function f<X>(x: X): X {
                       ^ [1]
   basic_function.js:7:10
   7|   var z: number = x;
               ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------- basic_function.js:8:19

Cannot assign `y` to `w` because mixed [1] is incompatible with number [2]. [incompatible-type]

   basic_function.js:8:19
   8|   var w: number = y;
                        ^

References:
   basic_function.js:6:10
   6|   var y: X = x;
               ^ [1]
   basic_function.js:8:10
   8|   var w: number = y;
               ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------ basic_function.js:10:12

Cannot return `42` because number [1] is incompatible with `X` [2]. [incompatible-return]

   basic_function.js:10:12
   10|     return 42;
                  ^^ [1]

References:
   basic_function.js:5:22
    5| function f<X>(x: X): X {
                            ^ [2]


Error ------------------------------------------------------------------------------------------ basic_function.js:20:12

Cannot return `42` because number [1] is incompatible with `X` [2]. [incompatible-return]

   basic_function.js:20:12
   20|     return 42;
                  ^^ [1]

References:
   basic_function.js:15:30
   15| function g<X: number>(x: X): X {
                                    ^ [2]


Error ------------------------------------------------------------------------------------------ basic_function.js:31:12

Cannot return `arg[arg.length - 1]` because array element of refined mixed [1] is incompatible with `T` [2].
[incompatible-return]

   basic_function.js:31:12
   31|     return arg[arg.length - 1];
                  ^^^^^^^^^^^^^^^^^^^

References:
   basic_function.js:25:46
   25| function overrideArgument<T>(arg: Array<T> | T): T {
                                                    ^ [1]
   basic_function.js:25:50
   25| function overrideArgument<T>(arg: Array<T> | T): T {
                                                        ^ [2]


Error -------------------------------------------------------------------------------------------- computed_keys.js:10:3

Cannot assign `'hi'` to `a['foo']` because string `foo` [1] is incompatible with `X` [2]. [incompatible-type]

   computed_keys.js:10:3
   10|   a['foo'] = 'hi'; // nope
         ^^^^^^^^ [1]

References:
   computed_keys.js:6:8
    6|   a: {[X]: string},
              ^ [2]


Error -------------------------------------------------------------------------------------------- computed_keys.js:13:5

Cannot assign `42` to `b[x]` because an index signature declaring the expected key / value type is missing in object
type [1]. [prop-missing]

   computed_keys.js:13:5
   13|   b[x] = 42; // nope
           ^

References:
   computed_keys.js:7:6
    7|   b: {prop: number},
            ^^^^^^^^^^^^^^ [1]


Error -------------------------------------------------------------------------------------------- computed_keys.js:14:5

Cannot assign `42` to `b[y]` because property `lit` is missing in object type [1]. [prop-missing]

   computed_keys.js:14:5
   14|   b[y] = 42; // nope
           ^

References:
   computed_keys.js:7:6
    7|   b: {prop: number},
            ^^^^^^^^^^^^^^ [1]


Error -------------------------------------------------------------------------------------------- computed_keys.js:16:5

Cannot access object with computed property using `X` [1]. [invalid-computed-prop]

   computed_keys.js:16:5
   16|   b[x]; // nope
           ^

References:
   computed_keys.js:3:6
    3|   x: X,
            ^ [1]


Error -------------------------------------------------------------------------------------------- computed_keys.js:17:5

Cannot get `b[y]` because property `lit` is missing in object type [1]. [prop-missing]

   computed_keys.js:17:5
   17|   b[y]; // nope
           ^

References:
   computed_keys.js:7:6
    7|   b: {prop: number},
            ^^^^^^^^^^^^^^ [1]


Error --------------------------------------------------------------------------------------------------- config.js:16:3

Cannot cast `y` to `C` because `Props` [1] is incompatible with `C` [2]. [incompatible-cast]

   config.js:16:3
   16|   y as C; // error, generics don't match
         ^

References:
   config.js:11:6
   11|   y: React.Config<P, D>,
            ^^^^^^^^^^^^^^^^^^ [1]
   config.js:16:8
   16|   y as C; // error, generics don't match
              ^ [2]


Error --------------------------------------------------------------------------------------------------- config.js:18:3

Cannot cast `y` to `NotTheRightConfig` because property `baz` is missing in `Props` [1] but exists in
`NotTheRightConfig` [2]. [prop-missing]

   config.js:18:3
   18|   y as NotTheRightConfig; // Error, configs don't match
         ^

References:
   config.js:11:6
   11|   y: React.Config<P, D>,
            ^^^^^^^^^^^^^^^^^^ [1]
   config.js:18:8
   18|   y as NotTheRightConfig; // Error, configs don't match
              ^^^^^^^^^^^^^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- config.js:18:3

Cannot cast `y` to `NotTheRightConfig` because property `qux` is missing in `Props` [1] but exists in
`NotTheRightConfig` [2]. [prop-missing]

   config.js:18:3
   18|   y as NotTheRightConfig; // Error, configs don't match
         ^

References:
   config.js:11:6
   11|   y: React.Config<P, D>,
            ^^^^^^^^^^^^^^^^^^ [1]
   config.js:18:8
   18|   y as NotTheRightConfig; // Error, configs don't match
              ^^^^^^^^^^^^^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- config.js:19:3

Cannot cast `z` to `React.Config` because property `bar` is missing in `NotTheRightConfig` [1] but exists in
`Props` [2]. [prop-missing]

   config.js:19:3
   19|   z as React.Config<Props, DefaultProps>; // Error, configs don't match
         ^

References:
   config.js:12:6
   12|   z: W,
            ^ [1]
   config.js:19:8
   19|   z as React.Config<Props, DefaultProps>; // Error, configs don't match
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- config.js:19:3

Cannot cast `z` to `React.Config` because property `foo` is missing in `NotTheRightConfig` [1] but exists in
`Props` [2]. [prop-missing]

   config.js:19:3
   19|   z as React.Config<Props, DefaultProps>; // Error, configs don't match
         ^

References:
   config.js:12:6
   12|   z: W,
            ^ [1]
   config.js:19:8
   19|   z as React.Config<Props, DefaultProps>; // Error, configs don't match
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error --------------------------------------------------------------------------------- detect_literal_subtypes.js:15:13

Invalid check of string literal `b` against string literal `a` [1] because string literal `b` [2] is incompatible with
string literal `a` [1]. [incompatible-type]

   detect_literal_subtypes.js:15:13
   15|   if (a === 'b'){ } // error 'b' not compatible with 'a'
                   ^^^ [2]

References:
   detect_literal_subtypes.js:14:16
   14| function a1<A: 'a'>(a: A): void {
                      ^^^ [1]


Error --------------------------------------------------------------------------------- detect_literal_subtypes.js:19:13

Invalid check of string literal `b` against string literal `a` [1] because string literal `b` [2] is incompatible with
string literal `a` [1]. [incompatible-type]

   detect_literal_subtypes.js:19:13
   19|   if (b === 'b'){ } // error 'b' not compatible with 'a'
                   ^^^ [2]

References:
   detect_literal_subtypes.js:18:16
   18| function b1<A: 'a', B: A>(b: B): void {
                      ^^^ [1]


Error --------------------------------------------------------------------------------- detect_literal_subtypes.js:37:10

Invalid check of string literal `r` against key set [1] because property `r` is missing in object type [2].
[prop-missing]

   detect_literal_subtypes.js:37:10
   37|     case 'r': // error
                ^^^

References:
   detect_literal_subtypes.js:31:21
   31| function c<X: T>(x: $Keys<X>) {
                           ^^^^^^^^ [1]
   detect_literal_subtypes.js:31:27
   31| function c<X: T>(x: $Keys<X>) {
                                 ^ [2]


Error ----------------------------------------------------------------------------------------------------- exact.js:6:3

Cannot cast `x` to `X` because inexact object type [1] is incompatible with exact `X` [2]. [incompatible-exact]

   exact.js:6:3
   6|   x as $Exact<X>; // nope
        ^

References:
   exact.js:3:40
   3| function f<X: {...}>(ex: $Exact<X>, x: X) {
                                             ^ [1]
   exact.js:6:8
   6|   x as $Exact<X>; // nope
             ^^^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------------- exact.js:7:16

Cannot cast `42` to `X` because object type [1] is incompatible with type including generic type(s) `X` [2].
[incompatible-cast]

   exact.js:7:16
   7|   42 as any as {||} as $Exact<X>; // nope
                     ^^^^ [1]

References:
   exact.js:7:24
   7|   42 as any as {||} as $Exact<X>; // nope
                             ^^^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- intersection.js:8:3

Cannot cast `x` to intersection type because: [incompatible-cast]
 - Either number [1] is incompatible with boolean [2].
 - Or string [1] is incompatible with boolean [2].

   intersection.js:8:3
   8|   x as number & string & boolean; // nope
        ^

References:
   intersection.js:3:52
   3| function f1<X: number & string, Y: X & boolean>(x: X, y: Y) {
                                                         ^ [1]
   intersection.js:8:26
   8|   x as number & string & boolean; // nope
                               ^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------------- maybe.js:15:3

Cannot cast `x` to `X` because null or undefined [1] is incompatible with `X` [2]. [incompatible-cast]

   maybe.js:15:3
   15|   x as X; //nope
         ^

References:
   maybe.js:4:6
    4|   x: ?X,
            ^^ [1]
   maybe.js:15:8
   15|   x as X; //nope
              ^ [2]


Error ---------------------------------------------------------------------------------------------------- maybe.js:20:5

Cannot cast `x` to union type because: [incompatible-cast]
 - Either number [1] is incompatible with null [2].
 - Or number [1] is incompatible with undefined [3].

   maybe.js:20:5
   20|     x as null | void; // nope
           ^

References:
   maybe.js:4:7
    4|   x: ?X,
             ^ [1]
   maybe.js:20:10
   20|     x as null | void; // nope
                ^^^^ [2]
   maybe.js:20:17
   20|     x as null | void; // nope
                       ^^^^ [3]


Error ---------------------------------------------------------------------------------------------------- maybe.js:31:5

Cannot cast `y` to union type because: [incompatible-cast]
 - Either number [1] is incompatible with null [2].
 - Or number [1] is incompatible with undefined [3].

   maybe.js:31:5
   31|     y as null | void; // nope
           ^

References:
   maybe.js:5:6
    5|   y: Y,
            ^ [1]
   maybe.js:31:10
   31|     y as null | void; // nope
                ^^^^ [2]
   maybe.js:31:17
   31|     y as null | void; // nope
                       ^^^^ [3]


Error ---------------------------------------------------------------------------------------------------- maybe.js:38:3

Cannot cast `z` to `X` because null or undefined [1] is incompatible with `X` [2]. [incompatible-cast]

   maybe.js:38:3
   38|   z as X; // nope
         ^

References:
   maybe.js:6:6
    6|   z: Z,
            ^ [1]
   maybe.js:38:8
   38|   z as X; // nope
              ^ [2]


Error ---------------------------------------------------------------------------------------------------- maybe.js:44:5

Cannot cast `z` to union type because: [incompatible-cast]
 - Either number [1] is incompatible with null [2].
 - Or number [1] is incompatible with undefined [3].

   maybe.js:44:5
   44|     z as null | void; // nope
           ^

References:
   maybe.js:6:6
    6|   z: Z,
            ^ [1]
   maybe.js:44:10
   44|     z as null | void; // nope
                ^^^^ [2]
   maybe.js:44:17
   44|     z as null | void; // nope
                       ^^^^ [3]


Error ---------------------------------------------------------------------------------------------------- maybe.js:50:3

Cannot cast `xu` to `X` because undefined [1] is incompatible with `X` [2]. [incompatible-cast]

   maybe.js:50:3
   50|   xu as X; //nope
         ^^

References:
   maybe.js:7:8
    7|   xu?: X,
              ^ [1]
   maybe.js:50:9
   50|   xu as X; //nope
               ^ [2]


Error ---------------------------------------------------------------------------------------------------- maybe.js:55:5

Cannot cast `xu` to undefined because number [1] is incompatible with undefined [2]. [incompatible-cast]

   maybe.js:55:5
   55|     xu as void; // nope
           ^^

References:
   maybe.js:7:8
    7|   xu?: X,
              ^ [1]
   maybe.js:55:11
   55|     xu as void; // nope
                 ^^^^ [2]


Error ---------------------------------------------------------------------------------------------------- maybe.js:59:3

Cannot cast `yu` to union type because: [incompatible-cast]
 - Either null or undefined [1] is incompatible with undefined [2].
 - Or null or undefined [1] is incompatible with number [3].

   maybe.js:59:3
   59|   yu as void | number; // nope
         ^^

References:
   maybe.js:8:8
    8|   yu?: Y,
              ^ [1]
   maybe.js:59:9
   59|   yu as void | number; // nope
               ^^^^ [2]
   maybe.js:59:16
   59|   yu as void | number; // nope
                      ^^^^^^ [3]


Error ---------------------------------------------------------------------------------------------------- maybe.js:60:3

Cannot cast `yu` to `Y` because undefined [1] is incompatible with `Y` [2]. [incompatible-cast]

   maybe.js:60:3
   60|   yu as Y; // nope
         ^^

References:
   maybe.js:8:8
    8|   yu?: Y,
              ^ [1]
   maybe.js:60:9
   60|   yu as Y; // nope
               ^ [2]


Error ---------------------------------------------------------------------------------------------------- maybe.js:61:3

Cannot cast `yu` to union type because: [incompatible-cast]
 - Either undefined [1] is incompatible with `Y` [2].
 - Or undefined [1] is incompatible with `X` [3].

   maybe.js:61:3
   61|   yu as Y | X; // nope
         ^^

References:
   maybe.js:8:8
    8|   yu?: Y,
              ^ [1]
   maybe.js:61:9
   61|   yu as Y | X; // nope
               ^ [2]
   maybe.js:61:13
   61|   yu as Y | X; // nope
                   ^ [3]


Error ---------------------------------------------------------------------------------------------------- maybe.js:67:5

Cannot cast `yu` to union type because: [incompatible-cast]
 - Either number [1] is incompatible with null [2].
 - Or number [1] is incompatible with undefined [3].

   maybe.js:67:5
   67|     yu as null | void; // nope
           ^^

References:
   maybe.js:8:8
    8|   yu?: Y,
              ^ [1]
   maybe.js:67:11
   67|     yu as null | void; // nope
                 ^^^^ [2]
   maybe.js:67:18
   67|     yu as null | void; // nope
                        ^^^^ [3]


Error ---------------------------------------------------------------------------------------------------- maybe.js:74:3

Cannot cast `zu` to `X` because null or undefined [1] is incompatible with `X` [2]. [incompatible-cast]

   maybe.js:74:3
   74|   zu as X; // nope
         ^^

References:
   maybe.js:9:8
    9|   zu?: Z,
              ^ [1]
   maybe.js:74:9
   74|   zu as X; // nope
               ^ [2]


Error ---------------------------------------------------------------------------------------------------- maybe.js:74:3

Cannot cast `zu` to `X` because undefined [1] is incompatible with `X` [2]. [incompatible-cast]

   maybe.js:74:3
   74|   zu as X; // nope
         ^^

References:
   maybe.js:9:8
    9|   zu?: Z,
              ^ [1]
   maybe.js:74:9
   74|   zu as X; // nope
               ^ [2]


Error ---------------------------------------------------------------------------------------------------- maybe.js:76:3

Cannot cast `zu` to `Z` because undefined [1] is incompatible with `Z` [2]. [incompatible-cast]

   maybe.js:76:3
   76|   zu as Z; // nope
         ^^

References:
   maybe.js:9:8
    9|   zu?: Z,
              ^ [1]
   maybe.js:76:9
   76|   zu as Z; // nope
               ^ [2]


Error ---------------------------------------------------------------------------------------------------- maybe.js:81:5

Cannot cast `zu` to union type because: [incompatible-cast]
 - Either number [1] is incompatible with null [2].
 - Or number [1] is incompatible with undefined [3].

   maybe.js:81:5
   81|     zu as null | void; // nope
           ^^

References:
   maybe.js:9:8
    9|   zu?: Z,
              ^ [1]
   maybe.js:81:11
   81|     zu as null | void; // nope
                 ^^^^ [2]
   maybe.js:81:18
   81|     zu as null | void; // nope
                        ^^^^ [3]


Error ---------------------------------------------------------------------------------------------------- maybe.js:88:3

Cannot cast `b.x` to union type because: [incompatible-cast]
 - Either number [1] is incompatible with `Y` [2].
 - Or number [1] is incompatible with undefined [3].

   maybe.js:88:3
   88|   b.x as Y | void; //nope
         ^^^

References:
   maybe.js:85:23
   85|   declare var a: {x?: X};
                             ^ [1]
   maybe.js:88:10
   88|   b.x as Y | void; //nope
                ^ [2]
   maybe.js:88:14
   88|   b.x as Y | void; //nope
                    ^^^^ [3]


Error ---------------------------------------------------------------------------------------------------- maybe.js:94:3

Cannot cast `c` to union type because: [incompatible-cast]
 - Either number [1] is incompatible with null [2].
 - Or number [1] is incompatible with undefined [3].

   maybe.js:94:3
   94|   c as null | void; // nope
         ^

References:
   maybe.js:91:32
   91|   declare var c: $NonMaybeType<X>;
                                      ^ [1]
   maybe.js:94:8
   94|   c as null | void; // nope
              ^^^^ [2]
   maybe.js:94:15
   94|   c as null | void; // nope
                     ^^^^ [3]


Error ------------------------------------------------------------------------------------------------------ misc.js:3:4

Cannot cast `x + x` to `X` because number [1] is incompatible with `X` [2]. [incompatible-cast]

   misc.js:3:4
   3|   (x + x: X); // nope
         ^^^^^ [1]

References:
   misc.js:3:11
   3|   (x + x: X); // nope
                ^ [2]


Error ------------------------------------------------------------------------------------------------------ misc.js:6:5

Cannot cast `-x` to `X` because number [1] is incompatible with `X` [2]. [incompatible-cast]

   misc.js:6:5
   6|   (-x: X); // nope
          ^

References:
   misc.js:1:26
   1| function a<X: number>(x: X) {
                               ^ [1]
   misc.js:6:8
   6|   (-x: X); // nope
             ^ [2]


Error ------------------------------------------------------------------------------------------------------ misc.js:9:4

Cannot cast `x * x` to `X` because number [1] is incompatible with `X` [2]. [incompatible-cast]

   misc.js:9:4
   9|   (x * x: X);
         ^^^^^ [1]

References:
   misc.js:9:11
   9|   (x * x: X);
                ^ [2]


Error ----------------------------------------------------------------------------------------------------- misc.js:19:4

Cannot compare number [1] to string [2] with a non-strict equality check. Make sure the arguments are valid, or try
using strict equality (`===` or `!==`) instead. [invalid-compare]

   misc.js:19:4
   19|   (x == y: boolean); // nope
          ^

References:
   misc.js:15:37
   15| function b<X: number, Y: string>(x: X, y: Y) {
                                           ^ [1]
   misc.js:15:43
   15| function b<X: number, Y: string>(x: X, y: Y) {
                                                 ^ [2]


Error ----------------------------------------------------------------------------------------------------- misc.js:22:4

Cannot compare number [1] to string [2]. [invalid-compare]

   misc.js:22:4
   22|   (x < y: boolean); // nope
          ^

References:
   misc.js:15:37
   15| function b<X: number, Y: string>(x: X, y: Y) {
                                           ^ [1]
   misc.js:15:43
   15| function b<X: number, Y: string>(x: X, y: Y) {
                                                 ^ [2]


Error ---------------------------------------------------------------------------------------------------- misc.js:52:10

Cannot return array literal because array literal [1] is incompatible with type including generic type(s) `X` [2].
[incompatible-return]

   misc.js:52:10
   52|   return ['a']; // error, mapped type doesn't have the unsoundness issue
                ^^^^^ [1]

References:
   misc.js:51:46
   51| function h<X: [number]>(x: X): {[_K in keyof X]: string} {
                                                    ^ [2]


Error ---------------------------------------------------------------------------------------------------- misc.js:68:28

Cannot call `Object.keys(...).reduce` because: [incompatible-call]
 - Either object literal [1] is incompatible with type including generic type(s) `TFormData` [2].
 - Or no more than 1 argument is expected by function type [3].

   misc.js:68:28
     68|   return Object.keys(data).reduce( // error: cannot satisfy generic mapped type
                                    ^^^^^^

References:
   misc.js:71:5
     71|     {},
             ^^ [1]
   misc.js:69:32
     69|     <K: $Keys<TFormData>>(acc: {[K in keyof TFormData]: ?string}, k: K): {[K in keyof TFormData]: ?string} =>
                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [2]
   <BUILTINS>/core.js:1055:5
             v------
   1055|     reduce(
   1056|       callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: Array<T>) => T,
   1057|     ): T;
             ---^ [3]


Error ---------------------------------------------------------------------------------------------------- misc.js:133:3

Cannot return `otherData` because object type [1] is incompatible with `$ReadOnly<T>` [2]. [incompatible-return]

   misc.js:133:3
   133|   otherData;
          ^^^^^^^^^

References:
   misc.js:132:54
   132| const directAccount = <T: LLETR>(data: T, otherData: LLETR): $ReadOnly<T> =>
                                                             ^^^^^ [1]
   misc.js:132:72
   132| const directAccount = <T: LLETR>(data: T, otherData: LLETR): $ReadOnly<T> =>
                                                                               ^ [2]


Error --------------------------------------------------------------------------------------------------- nested.js:8:10

Cannot return `w` because mixed [1] is incompatible with `X` [2]. [incompatible-return]

   nested.js:8:10
   8|   return w; // nope
               ^

References:
   nested.js:5:45
   5| function f<X, Y: X, Z: Y, W>(y: Y, z: X, w: W): X {
                                                  ^ [1]
   nested.js:5:49
   5| function f<X, Y: X, Z: Y, W>(y: Y, z: X, w: W): X {
                                                      ^ [2]


Error ---------------------------------------------------------------------------------------------------- react.js:13:3

Cannot cast `a` to `React.ComponentType` because `Props` [1] is incompatible with object type [2] in type argument
`P` [3]. [incompatible-cast]

   react.js:13:3
    13|   a as React.ComponentType<{a: number}>; // nope, contravariance
          ^

References:
   react.js:11:38
    11|   declare var a: React.ComponentType<Props>;
                                             ^^^^^ [1]
   react.js:13:28
    13|   a as React.ComponentType<{a: number}>; // nope, contravariance
                                   ^^^^^^^^^^^ [2]
   <BUILTINS>/react.js:345:38
   345|   declare export type ComponentType<-P> = React$ComponentType<P>;
                                             ^ [3]


Error ---------------------------------------------------------------------------------------------------- react.js:14:3

Cannot cast `b` to `React.Component` because object type [1] is incompatible with `Props` [2] in type argument
`Props` [3]. [incompatible-cast]

   react.js:14:3
   14|   b as React.Component<Props>; // nope
         ^

References:
   react.js:12:34
   12|   declare var b: React.Component<{+a: number}>;
                                        ^^^^^^^^^^^^ [1]
   react.js:14:24
   14|   b as React.Component<Props>; // nope
                              ^^^^^ [2]
   <BUILTINS>/react.js:30:31
   30| declare class React$Component<Props, State = void> {
                                     ^^^^^ [3]


Error --------------------------------------------------------------------------------------------------- react.js:62:26

Cannot get `X.defaultProps` because property `defaultProps` is missing in `React.AbstractComponentStatics` [1].
[prop-missing]

   react.js:62:26
    62|   C.defaultProps = {...X.defaultProps}; // nope
                                 ^^^^^^^^^^^^

References:
   <BUILTINS>/react.js:108:47
                                                      v
   108| declare type React$AbstractComponentStatics = {
   109|   displayName?: ?string,
   110|   // This is only on function components, but trying to access name when
   111|   // displayName is undefined is a common pattern.
   112|   name?: ?string,
   113|   propTypes?: {[string] : any, ...},
   114|   ...
   115| };
        ^ [1]


Error ---------------------------------------------------------------------------------------------- refinements.js:11:5

Cannot cast `x` to string because number [1] is incompatible with string [2]. [incompatible-cast]

   refinements.js:11:5
   11|     x as string; // nope
           ^

References:
   refinements.js:8:7
    8|   if (typeof x === 'number') {
             ^^^^^^^^^^^^^^^^^^^^^ [1]
   refinements.js:11:10
   11|     x as string; // nope
                ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinements.js:13:3

Cannot cast `x` to number because mixed [1] is incompatible with number [2]. [incompatible-cast]

   refinements.js:13:3
   13|   x as number; // nope
         ^

References:
   refinements.js:7:18
    7| function f<X>(x: X) {
                        ^ [1]
   refinements.js:13:8
   13|   x as number; // nope
              ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinements.js:18:5

Cannot cast `x` to string because `C` [1] is incompatible with string [2]. [incompatible-cast]

   refinements.js:18:5
   18|     x as string; // nope
           ^

References:
   refinements.js:15:20
   15|   if (x instanceof C) {
                          ^ [1]
   refinements.js:18:10
   18|     x as string; // nope
                ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- refinements.js:20:3

Cannot cast `x` to `C` because mixed [1] is incompatible with `C` [2]. [incompatible-cast]

   refinements.js:20:3
   20|   x as C; // nope
         ^

References:
   refinements.js:7:18
    7| function f<X>(x: X) {
                        ^ [1]
   refinements.js:20:8
   20|   x as C; // nope
              ^ [2]


Error ------------------------------------------------------------------------------------------------------ rest.js:5:3

Cannot cast `y` to `$Diff` because object type [1] is incompatible with `{ ...X }` [2]. [incompatible-cast]

   rest.js:5:3
   5|   y as $Diff<{...X, ...Y}, {...Y}>; // nope
        ^

References:
   rest.js:3:40
   3| function f<X: {}, Y: {}>(x: {...X}, y: {...Y}, both: {...X, ...Y}) {
                                             ^^^^^^ [1]
   rest.js:5:14
   5|   y as $Diff<{...X, ...Y}, {...Y}>; // nope
                   ^^^^^^^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------------- rest.js:10:3

Cannot cast `rest` to object type because property `x` is missing in rest of object pattern [1] but exists in object
type [2]. [prop-missing]

   rest.js:10:3
   10|   rest as {...X, ...Y}; //no, because x is missing
         ^^^^

References:
   rest.js:9:14
    9|   var {x, ...rest} = o;
                    ^^^^ [1]
   rest.js:10:11
   10|   rest as {...X, ...Y}; //no, because x is missing
                 ^^^^^^^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------------- rest.js:12:3

Cannot cast `rest` to object type because rest of object pattern [1] is incompatible with `{ ...X }` [2].
[incompatible-cast]

   rest.js:12:3
   12|   rest as {...X}; // no, because X's props could have been overwritten
         ^^^^

References:
   rest.js:9:14
    9|   var {x, ...rest} = o;
                    ^^^^ [1]
   rest.js:12:11
   12|   rest as {...X}; // no, because X's props could have been overwritten
                 ^^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- spreads.js:4:4

Cannot cast object literal to object type because object literal [1] is incompatible with `{ ...X }` [2].
[incompatible-cast]

   spreads.js:4:4
   4|   ({...x, ...y}) as {...X}; // nope, which is different than old generics
         ^^^^^^^^^^^^ [1]

References:
   spreads.js:4:21
   4|   ({...x, ...y}) as {...X}; // nope, which is different than old generics
                          ^^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- spreads.js:6:4

Cannot cast object literal to object type because object literal [1] is incompatible with `{ ...Y, ...X }` [2].
[incompatible-cast]

   spreads.js:6:4
   6|   ({...x}) as {...Y, ...X}; // nope
         ^^^^^^ [1]

References:
   spreads.js:6:15
   6|   ({...x}) as {...Y, ...X}; // nope
                    ^^^^^^^^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- spreads.js:7:4

Cannot cast object literal to object type because object literal [1] is incompatible with `{ ...X, ...Y }` [2].
[incompatible-cast]

   spreads.js:7:4
   7|   ({...y, ...x}) as {...X, ...Y}; // nope, which is different than old generics
         ^^^^^^^^^^^^ [1]

References:
   spreads.js:7:21
   7|   ({...y, ...x}) as {...X, ...Y}; // nope, which is different than old generics
                          ^^^^^^^^^^^^ [2]


Error -------------------------------------------------------------------------------------------------- spreads.js:11:4

Cannot cast object literal to object type because object literal [1] is incompatible with `{ ...X, ...Z, ...Y }` [2].
[incompatible-cast]

   spreads.js:11:4
   11|   ({...x, ...y}) as {...X, ...Z, ...Y}; // nope
          ^^^^^^^^^^^^ [1]

References:
   spreads.js:11:21
   11|   ({...x, ...y}) as {...X, ...Z, ...Y}; // nope
                           ^^^^^^^^^^^^^^^^^^ [2]


Error -------------------------------------------------------------------------------------------------- spreads.js:24:3

Cannot cast `x` to object type because mixed [1] is incompatible with object type [2]. [incompatible-cast]

   spreads.js:24:3
   24|   x as {...X}; // nope
         ^

References:
   spreads.js:23:19
   23| function t2<X>(x: X, sp_x: {...X}) {
                         ^ [1]
   spreads.js:24:8
   24|   x as {...X}; // nope
              ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- spreads.js:41:10

Cannot return `y` because object type [1] is incompatible with `{ ...X, ...Y }` [2]. [incompatible-return]

   spreads.js:41:10
   41|   return y; // should error
                ^

References:
   spreads.js:40:30
   40| function f3<X: {}, Y: {}>(y: Y): {...X, ...Y} {
                                    ^ [1]
   spreads.js:40:34
   40| function f3<X: {}, Y: {}>(y: Y): {...X, ...Y} {
                                        ^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- spreads.js:49:10

Cannot return `y` because object type [1] is incompatible with `Y` [2]. [incompatible-return]

   spreads.js:49:10
   49|   return y; // should be an error!
                ^

References:
   spreads.js:48:31
   48| function f4b<X: {}, Y: {}>(y: {...Y, ...X}): Y {
                                     ^^^^^^^^^^^^ [1]
   spreads.js:48:46
   48| function f4b<X: {}, Y: {}>(y: {...Y, ...X}): Y {
                                                    ^ [2]


Error -------------------------------------------------------------------------------------------------- spreads.js:53:3

Cannot cast `x` to object type because object type [1] is incompatible with `{ ...X, ...Y }` [2]. [incompatible-cast]

   spreads.js:53:3
   53|   x as {...X & Y}; // nope
         ^

References:
   spreads.js:52:39
   52| function f<X: {}, Y: {}, Z: X & Y>(x: {...X}, xy: {...X, ...Y}, z: {...Z}) {
                                             ^^^^^^ [1]
   spreads.js:53:8
   53|   x as {...X & Y}; // nope
              ^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------ synthetic.js:2:10

Cannot return `x` because mapped type [1] is incompatible with type including generic type(s) `T` [2].
[incompatible-return]

   synthetic.js:2:10
   2|   return x; // error S incompatible with T
               ^

References:
   synthetic.js:1:25
   1| function test1<S, T>(x: { [K in keyof S]: S[K] }): { [K in keyof T]: T[K] } {
                              ^^^^^^^^^^^^^^^^^^^^^^^^ [1]
   synthetic.js:1:52
   1| function test1<S, T>(x: { [K in keyof S]: S[K] }): { [K in keyof T]: T[K] } {
                                                         ^^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------ synthetic.js:6:10

Cannot return `x` because `$ReadOnly` [1] is incompatible with `$ReadOnly<T>` [2]. [incompatible-return]

   synthetic.js:6:10
   6|   return x; // error S incompatible with T
               ^

References:
   synthetic.js:5:25
   5| function test2<S, T>(x: $ReadOnly<S>): $ReadOnly<T> {
                              ^^^^^^^^^^^^ [1]
   synthetic.js:5:40
   5| function test2<S, T>(x: $ReadOnly<S>): $ReadOnly<T> {
                                             ^^^^^^^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- synthetic.js:10:10

Cannot return `x` because `Pick` [1] is incompatible with type including generic type(s) `T` [2]. [incompatible-return]

   synthetic.js:10:10
   10|   return x; // error S incompatible with T
                ^

References:
   synthetic.js:9:53
    9| function test3<S: { a: mixed }, T: { a: mixed }>(x: Pick<S, "a">): Pick<T, "a"> {
                                                           ^^^^^^^^^^^^ [1]
   synthetic.js:9:68
    9| function test3<S: { a: mixed }, T: { a: mixed }>(x: Pick<S, "a">): Pick<T, "a"> {
                                                                          ^^^^^^^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- synthetic.js:14:10

Cannot return `x` because partial `S` [1] is incompatible with `Partial<T>` [2]. [incompatible-return]

   synthetic.js:14:10
   14|   return x; // error S incompatible with T
                ^

References:
   synthetic.js:13:33
   13| function test4<S, T>(x: Partial<S>): Partial<T> {
                                       ^ [1]
   synthetic.js:13:46
   13| function test4<S, T>(x: Partial<S>): Partial<T> {
                                                    ^ [2]


Error ----------------------------------------------------------------------------------------------- synthetic.js:18:10

Cannot return `x` because required of `S` [1] is incompatible with `Required<T>` [2]. [incompatible-return]

   synthetic.js:18:10
   18|   return x; // error S incompatible with T
                ^

References:
   synthetic.js:17:34
   17| function test5<S, T>(x: Required<S>): Required<T> {
                                        ^ [1]
   synthetic.js:17:48
   17| function test5<S, T>(x: Required<S>): Required<T> {
                                                      ^ [2]


Error ----------------------------------------------------------------------------------------------------- this.js:8:14

Cannot return `this.f2()` because `C` [1] is incompatible with `this` [2]. [incompatible-return]

   this.js:8:14
   8|       return this.f2();
                   ^^^^^^^^^

References:
   this.js:5:14
   5|   +f2: () => C;
                   ^ [1]
   this.js:6:8
   6|   g(): this {
             ^^^^ [2]


Error ----------------------------------------------------------------------------------------------------- union.js:4:3

Cannot cast `x` to union type because: [incompatible-cast]
 - Either boolean [1] is incompatible with number [2].
 - Or boolean [1] is incompatible with string [3].

   union.js:4:3
   4|   x as number | string;
        ^

References:
   union.js:3:44
   3| function f1<X: boolean, Y: X | boolean>(x: X, y: Y) {
                                                 ^ [1]
   union.js:4:8
   4|   x as number | string;
             ^^^^^^ [2]
   union.js:4:17
   4|   x as number | string;
                      ^^^^^^ [3]


Error ----------------------------------------------------------------------------------------------------- union.js:9:3

Cannot cast `x` to number because boolean [1] is incompatible with number [2]. [incompatible-cast]

   union.js:9:3
   9|   x as number; // nope
        ^

References:
   union.js:3:44
   3| function f1<X: boolean, Y: X | boolean>(x: X, y: Y) {
                                                 ^ [1]
   union.js:9:8
   9|   x as number; // nope
             ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------------- union.js:17:5

Cannot cast `y` to `X` because boolean [1] is incompatible with `X` [2]. [incompatible-cast]

   union.js:17:5
   17|     y as X; // nope
           ^

References:
   union.js:3:50
    3| function f1<X: boolean, Y: X | boolean>(x: X, y: Y) {
                                                        ^ [1]
   union.js:17:10
   17|     y as X; // nope
                ^ [2]



Found 92 errors

Only showing the most relevant union/intersection branches.
To see all branches, re-run Flow with --show-all-branches
