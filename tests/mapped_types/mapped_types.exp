Error ----------------------------------------------------------------------------------------------- deep_types.js:12:4

Cannot cast `a` to empty because number [1] is incompatible with empty [2]. [incompatible-cast]

   deep_types.js:12:4
   12|   (a: empty); // error: number ~> empty
          ^

References:
   deep_types.js:10:20
   10|   declare const a: DeepPartialState<number>;
                          ^^^^^^^^^^^^^^^^^^^^^^^^ [1]
   deep_types.js:12:7
   12|   (a: empty); // error: number ~> empty
             ^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- deep_types.js:16:4

Cannot cast `b` to object type because undefined [1] is incompatible with object type [2] in property `foo`.
[incompatible-cast]

   deep_types.js:16:4
   16|   (b: {+foo: {+bar?: {+baz?: string}}}); // error: foo not optional
          ^

References:
   deep_types.js:6:23
    6|       [K in keyof T]: DeepPartialState<Partial<T>[K]>,
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]
   deep_types.js:16:14
   16|   (b: {+foo: {+bar?: {+baz?: string}}}); // error: foo not optional
                    ^^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- deep_types.js:17:4

Cannot cast `b` to object type because undefined [1] is incompatible with object type [2] in property `foo.bar`.
[incompatible-cast]

   deep_types.js:17:4
   17|   (b: {+foo?: {+bar: {+baz?: string}}}); // error: bar not optional
          ^

References:
   deep_types.js:6:23
    6|       [K in keyof T]: DeepPartialState<Partial<T>[K]>,
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]
   deep_types.js:17:22
   17|   (b: {+foo?: {+bar: {+baz?: string}}}); // error: bar not optional
                            ^^^^^^^^^^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- deep_types.js:18:4

Cannot cast `b` to object type because undefined [1] is incompatible with string [2] in property `foo.bar.baz`.
[incompatible-cast]

   deep_types.js:18:4
   18|   (b: {+foo?: {+bar?: {+baz: string}}}); // error: baz not optional
          ^

References:
   deep_types.js:6:23
    6|       [K in keyof T]: DeepPartialState<Partial<T>[K]>,
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]
   deep_types.js:18:30
   18|   (b: {+foo?: {+bar?: {+baz: string}}}); // error: baz not optional
                                    ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- deep_types.js:44:4

Cannot cast `obj` to empty because mapped type [1] is incompatible with empty [2]. [incompatible-cast]

   deep_types.js:44:4
   44|   (obj: empty); // error
          ^^^

References:
   deep_types.js:26:14
                    v-------------
   26|   const obj: DeepReadOnly<{
   27|     arr: Array<{value: string, ...}>,
   28|     nested: {
   29|       value: string,
   30|       doubleNested: {value: string, ...},
   31|       ...
   32|     },
   33|     ...
   34|   }> = {
         -^ [1]
   deep_types.js:44:9
   44|   (obj: empty); // error
               ^^^^^ [2]


Error ---------------------------------------------------------------------------------------------- deep_types.js:46:11

Cannot call `obj.arr.push` because property `push` is missing in `$ReadOnlyArray` [1]. [prop-missing]

   deep_types.js:46:11
   46|   obj.arr.push({value: 'updated value'}); // error: Cannot mutate arrays.
                 ^^^^

References:
   deep_types.js:23:39
   23|   T extends {...} ? {+[K in keyof T]: DeepReadOnly<T[K]>} : T;
                                             ^^^^^^^^^^^^^^^^^^ [1]


Error ---------------------------------------------------------------------------------------------- deep_types.js:47:14

Cannot assign `'updated value'` to `obj.arr[0].value` because property `value` is not writable. [cannot-write]

   47|   obj.arr[0].value = 'updated value'; // error: Cannot mutate objects in arrays.
                    ^^^^^


Error ----------------------------------------------------------------------------------------------- deep_types.js:48:7

Cannot assign array literal to `obj.arr` because property `arr` is not writable. [cannot-write]

   48|   obj.arr = []; // error: Cannot change top-level values.
             ^^^


Error ----------------------------------------------------------------------------------------------- deep_types.js:49:7

Cannot assign `obj.nested` to `obj.nested` because property `nested` is not writable. [cannot-write]

   49|   obj.nested = obj.nested; // error: Cannot change top-level values.
             ^^^^^^


Error ---------------------------------------------------------------------------------------------- deep_types.js:50:14

Cannot assign `'updated value'` to `obj.nested.value` because property `value` is not writable. [cannot-write]

   50|   obj.nested.value = 'updated value'; // error: Cannot change nested values.
                    ^^^^^


Error ---------------------------------------------------------------------------------------------- deep_types.js:51:14

Cannot assign `obj.nested.doubleNested` to `obj.nested.doubleNested` because property `doubleNested` is not writable.
[cannot-write]

   51|   obj.nested.doubleNested = obj.nested.doubleNested; // error: Cannot change nested values.
                    ^^^^^^^^^^^^


Error ---------------------------------------------------------------------------------------------- deep_types.js:52:27

Cannot assign `'updated value'` to `obj.nested.doubleNested.value` because property `value` is not writable.
[cannot-write]

   52|   obj.nested.doubleNested.value = 'updated value'; // error: Cannot change nested values.
                                 ^^^^^


Error ----------------------------------------------------------------------------------------------- deep_types.js:55:7

Cannot call `arr.push` because property `push` is missing in `$ReadOnlyArray` [1]. [prop-missing]

   deep_types.js:55:7
   55|   arr.push('goodbye'); // error: Cannot mutate arrays.
             ^^^^

References:
   deep_types.js:54:14
   54|   const arr: DeepReadOnly<Array<string>> = ['hello', 'world'];
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]


Error ----------------------------------------------------------------------------------------------- deep_types.js:56:3

Cannot assign `'goodbye'` to `arr[0]` because read-only arrays cannot be written to. [cannot-write]

   56|   arr[0] = 'goodbye'; // error: Cannot mutate values in arrays.
         ^^^^^^


Error -------------------------------------------------------------------------------------------- distributivity.js:8:4

Cannot cast `o` to union type because: [incompatible-cast]
 - Either number [1] is incompatible with empty [2] in property `bar`.
 - Or property `bar` is missing in object type [3] but exists in `Homomorphic` [4].

   distributivity.js:8:4
   8|   (o: {foo: empty} | {bar: empty}); // ERROR x2
         ^

References:
   distributivity.js:5:51
   5|   type Homomorphic<O: {...}> = {[key in keyof O]: O[key]};
                                                        ^^^^^^ [1]
   distributivity.js:8:28
   8|   (o: {foo: empty} | {bar: empty}); // ERROR x2
                                 ^^^^^ [2]
   distributivity.js:8:7
   8|   (o: {foo: empty} | {bar: empty}); // ERROR x2
            ^^^^^^^^^^^^ [3]
   distributivity.js:6:20
   6|   declare const o: Homomorphic<{foo: number} | {bar: number}>; // OK
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [4]


Error -------------------------------------------------------------------------------------------- distributivity.js:8:4

Cannot cast `o` to union type because: [incompatible-cast]
 - Either number [1] is incompatible with empty [2] in property `foo`.
 - Or property `foo` is missing in object type [3] but exists in `Homomorphic` [4].

   distributivity.js:8:4
   8|   (o: {foo: empty} | {bar: empty}); // ERROR x2
         ^

References:
   distributivity.js:5:51
   5|   type Homomorphic<O: {...}> = {[key in keyof O]: O[key]};
                                                        ^^^^^^ [1]
   distributivity.js:8:13
   8|   (o: {foo: empty} | {bar: empty}); // ERROR x2
                  ^^^^^ [2]
   distributivity.js:8:22
   8|   (o: {foo: empty} | {bar: empty}); // ERROR x2
                           ^^^^^^^^^^^^ [3]
   distributivity.js:6:20
   6|   declare const o: Homomorphic<{foo: number} | {bar: number}>; // OK
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [4]


Error ------------------------------------------------------------------------------------------- distributivity.js:15:4

Cannot cast `o` to object type because property `foo` is missing in object type [1] but exists in `SemiHomomorphic` [2].
[prop-missing]

   distributivity.js:15:4
   15|   (o: {}); // ERROR
          ^

References:
   distributivity.js:15:7
   15|   (o: {}); // ERROR
             ^^ [1]
   distributivity.js:13:20
   13|   declare const o: SemiHomomorphic<{foo: number, bar: number} | {foo: string, baz: number}, 'foo'>;
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------- distributivity.js:25:4

Cannot cast `oExplicit` to object type because null [1] is incompatible with object type [2]. [incompatible-cast]

   distributivity.js:25:4
   25|   (oExplicit: {-foo: number}); // ERROR 2x
          ^^^^^^^^^

References:
   distributivity.js:23:28
   23|   declare const oExplicit: DistributeNullAndVoid<O | null | void>;
                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]
   distributivity.js:25:15
   25|   (oExplicit: {-foo: number}); // ERROR 2x
                     ^^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------- distributivity.js:25:4

Cannot cast `oExplicit` to object type because undefined [1] is incompatible with object type [2]. [incompatible-cast]

   distributivity.js:25:4
   25|   (oExplicit: {-foo: number}); // ERROR 2x
          ^^^^^^^^^

References:
   distributivity.js:23:28
   23|   declare const oExplicit: DistributeNullAndVoid<O | null | void>;
                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]
   distributivity.js:25:15
   25|   (oExplicit: {-foo: number}); // ERROR 2x
                     ^^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------- distributivity.js:29:4

Cannot cast `oMaybe` to object type because null or undefined [1] is incompatible with object type [2].
[incompatible-cast]

   distributivity.js:29:4
   29|   (oMaybe: {-foo: number}); // ERROR
          ^^^^^^

References:
   distributivity.js:27:25
   27|   declare const oMaybe: DistributeNullAndVoid<?O>;
                               ^^^^^^^^^^^^^^^^^^^^^^^^^ [1]
   distributivity.js:29:12
   29|   (oMaybe: {-foo: number}); // ERROR
                  ^^^^^^^^^^^^^^ [2]


Error ----------------------------------------------------------------------------------------- idx_replacement.js:30:10

Cannot get `obj1.a.b` because property `b` is missing in null or undefined [1]. [incompatible-use]

   idx_replacement.js:30:10
   30|   obj1.a.b.c; // error
                ^

References:
   idx_replacement.js:29:27
   29|   declare const obj1: {a: ?{b: {c: number}}};
                                 ^^^^^^^^^^^^^^^^^ [1]


Error ------------------------------------------------------------------------------------------ idx_replacement.js:33:4

Cannot cast `idx(...)` to number because null or undefined [1] is incompatible with number [2]. [incompatible-cast]

   idx_replacement.js:33:4
   33|   (idx(obj1, obj => obj.a.b.c): number); // error: result must be MaybeT
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^

References:
   idx_replacement.js:24:4
   24| ): ?UnboxDeepRequired<T2>;
          ^^^^^^^^^^^^^^^^^^^^^^ [1]
   idx_replacement.js:33:33
   33|   (idx(obj1, obj => obj.a.b.c): number); // error: result must be MaybeT
                                       ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------ idx_replacement.js:34:4

Cannot cast `idx(...)` to nullable string because number [1] is incompatible with string [2]. [incompatible-cast]

   idx_replacement.js:34:4
   34|   (idx(obj1, obj => obj.a.b.c): ?string); // error: number ~> string
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^

References:
   idx_replacement.js:24:5
   24| ): ?UnboxDeepRequired<T2>;
           ^^^^^^^^^^^^^^^^^^^^^ [1]
   idx_replacement.js:34:34
   34|   (idx(obj1, obj => obj.a.b.c): ?string); // error: number ~> string
                                        ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------ idx_replacement.js:35:4

Cannot cast `idx(...)` to number because null or undefined [1] is incompatible with number [2]. [incompatible-cast]

   idx_replacement.js:35:4
   35|   (idx(obj1, obj => obj["a"].b.c): number); // error: result must be MaybeT
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

References:
   idx_replacement.js:24:4
   24| ): ?UnboxDeepRequired<T2>;
          ^^^^^^^^^^^^^^^^^^^^^^ [1]
   idx_replacement.js:35:36
   35|   (idx(obj1, obj => obj["a"].b.c): number); // error: result must be MaybeT
                                          ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------- idx_replacement.js:36:24

Cannot get `obj.notAProp` because property `notAProp` is missing in `DeepRequired` [1]. [prop-missing]

   idx_replacement.js:36:24
   36|   idx(obj1, obj => obj.notAProp); // error: prop-missing
                              ^^^^^^^^

References:
   idx_replacement.js:23:34
   23|   accessor: (prop: $NonMaybeType<DeepRequired<T1>>) => T2,
                                        ^^^^^^^^^^^^^^^^ [1]


Error ----------------------------------------------------------------------------------------- idx_replacement.js:37:24

Cannot assign `null` to `obj.a` because property `a` is not writable. [cannot-write]

   37|   idx(obj1, obj => obj.a = null); // error: invalid-idx
                              ^


Error ------------------------------------------------------------------------------------------ idx_replacement.js:40:4

Cannot cast `idx(...)` to number because null or undefined [1] is incompatible with number [2]. [incompatible-cast]

   idx_replacement.js:40:4
   40|   (idx(obj2, obj => obj.a.b.c): number); // error: result must be MaybeT
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^

References:
   idx_replacement.js:24:4
   24| ): ?UnboxDeepRequired<T2>;
          ^^^^^^^^^^^^^^^^^^^^^^ [1]
   idx_replacement.js:40:33
   40|   (idx(obj2, obj => obj.a.b.c): number); // error: result must be MaybeT
                                       ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------ idx_replacement.js:43:4

Cannot cast `idx(...)` to number because null or undefined [1] is incompatible with number [2]. [incompatible-cast]

   idx_replacement.js:43:4
   43|   (idx(obj3, obj => obj.a.b.c): number); // error: result must be MaybeT
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^

References:
   idx_replacement.js:24:4
   24| ): ?UnboxDeepRequired<T2>;
          ^^^^^^^^^^^^^^^^^^^^^^ [1]
   idx_replacement.js:43:33
   43|   (idx(obj3, obj => obj.a.b.c): number); // error: result must be MaybeT
                                       ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------ idx_replacement.js:50:4

Cannot cast `idx(...)` to empty because null or undefined [1] is incompatible with empty [2]. [incompatible-cast]

   idx_replacement.js:50:4
   50|   (idx(ab, _ => _.a): empty); // error
          ^^^^^^^^^^^^^^^^^

References:
   idx_replacement.js:24:4
   24| ): ?UnboxDeepRequired<T2>;
          ^^^^^^^^^^^^^^^^^^^^^^ [1]
   idx_replacement.js:50:23
   50|   (idx(ab, _ => _.a): empty); // error
                             ^^^^^ [2]


Error ------------------------------------------------------------------------------------------ idx_replacement.js:50:4

Cannot cast `idx(...)` to empty because `void` (due to access of non-existent property `a`) [1] is incompatible with
empty [2]. [incompatible-cast]

   idx_replacement.js:50:4
   50|   (idx(ab, _ => _.a): empty); // error
          ^^^^^^^^^^^^^^^^^

References:
   idx_replacement.js:24:5
   24| ): ?UnboxDeepRequired<T2>;
           ^^^^^^^^^^^^^^^^^^^^^ [1]
   idx_replacement.js:50:23
   50|   (idx(ab, _ => _.a): empty); // error
                             ^^^^^ [2]


Error ------------------------------------------------------------------------------------------ idx_replacement.js:50:4

Cannot cast `idx(...)` to empty because string [1] is incompatible with empty [2]. [incompatible-cast]

   idx_replacement.js:50:4
   50|   (idx(ab, _ => _.a): empty); // error
          ^^^^^^^^^^^^^^^^^

References:
   idx_replacement.js:24:5
   24| ): ?UnboxDeepRequired<T2>;
           ^^^^^^^^^^^^^^^^^^^^^ [1]
   idx_replacement.js:50:23
   50|   (idx(ab, _ => _.a): empty); // error
                             ^^^^^ [2]


Error ------------------------------------------------------------------------------------------ idx_replacement.js:51:4

Cannot cast `idx(...)` to empty because null or undefined [1] is incompatible with empty [2]. [incompatible-cast]

   idx_replacement.js:51:4
   51|   (idx(ab, _ => _.b): empty); // error
          ^^^^^^^^^^^^^^^^^

References:
   idx_replacement.js:24:4
   24| ): ?UnboxDeepRequired<T2>;
          ^^^^^^^^^^^^^^^^^^^^^^ [1]
   idx_replacement.js:51:23
   51|   (idx(ab, _ => _.b): empty); // error
                             ^^^^^ [2]


Error ------------------------------------------------------------------------------------------ idx_replacement.js:51:4

Cannot cast `idx(...)` to empty because `void` (due to access of non-existent property `b`) [1] is incompatible with
empty [2]. [incompatible-cast]

   idx_replacement.js:51:4
   51|   (idx(ab, _ => _.b): empty); // error
          ^^^^^^^^^^^^^^^^^

References:
   idx_replacement.js:24:5
   24| ): ?UnboxDeepRequired<T2>;
           ^^^^^^^^^^^^^^^^^^^^^ [1]
   idx_replacement.js:51:23
   51|   (idx(ab, _ => _.b): empty); // error
                             ^^^^^ [2]


Error ------------------------------------------------------------------------------------------ idx_replacement.js:51:4

Cannot cast `idx(...)` to empty because number [1] is incompatible with empty [2]. [incompatible-cast]

   idx_replacement.js:51:4
   51|   (idx(ab, _ => _.b): empty); // error
          ^^^^^^^^^^^^^^^^^

References:
   idx_replacement.js:24:5
   24| ): ?UnboxDeepRequired<T2>;
           ^^^^^^^^^^^^^^^^^^^^^ [1]
   idx_replacement.js:51:23
   51|   (idx(ab, _ => _.b): empty); // error
                             ^^^^^ [2]


Error ------------------------------------------------------------------------------------------ idx_replacement.js:52:4

Cannot cast `idx(...)` to empty because null or undefined [1] is incompatible with empty [2]. [incompatible-cast]

   idx_replacement.js:52:4
   52|   (idx(ab, _ => _.c): empty); // error
          ^^^^^^^^^^^^^^^^^

References:
   idx_replacement.js:24:4
   24| ): ?UnboxDeepRequired<T2>;
          ^^^^^^^^^^^^^^^^^^^^^^ [1]
   idx_replacement.js:52:23
   52|   (idx(ab, _ => _.c): empty); // error
                             ^^^^^ [2]


Error ------------------------------------------------------------------------------------------ idx_replacement.js:52:4

Cannot cast `idx(...)` to empty because `void` (due to access of non-existent property `c`) [1] is incompatible with
empty [2]. [incompatible-cast]

   idx_replacement.js:52:4
   52|   (idx(ab, _ => _.c): empty); // error
          ^^^^^^^^^^^^^^^^^

References:
   idx_replacement.js:24:5
   24| ): ?UnboxDeepRequired<T2>;
           ^^^^^^^^^^^^^^^^^^^^^ [1]
   idx_replacement.js:52:23
   52|   (idx(ab, _ => _.c): empty); // error
                             ^^^^^ [2]


Error ----------------------------------------------------------------------------------------- idx_replacement.js:52:19

Cannot get `_.c` because property `c` is missing in `DeepRequired` [1]. [prop-missing]

   idx_replacement.js:52:19
   52|   (idx(ab, _ => _.c): empty); // error
                         ^

References:
   idx_replacement.js:23:34
   23|   accessor: (prop: $NonMaybeType<DeepRequired<T1>>) => T2,
                                        ^^^^^^^^^^^^^^^^ [1]


Error ------------------------------------------------------------------------------------------ idx_replacement.js:59:4

Cannot cast `idx(...)` to number because null or undefined [1] is incompatible with number [2]. [incompatible-cast]

   idx_replacement.js:59:4
   59|   (idx(new Foo1(), o => o.a.b): number); // error: result must be MaybeT
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^

References:
   idx_replacement.js:24:4
   24| ): ?UnboxDeepRequired<T2>;
          ^^^^^^^^^^^^^^^^^^^^^^ [1]
   idx_replacement.js:59:33
   59|   (idx(new Foo1(), o => o.a.b): number); // error: result must be MaybeT
                                       ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------ idx_replacement.js:59:4

Cannot cast `idx(...)` to number because null or undefined [1] is incompatible with number [2]. [incompatible-cast]

   idx_replacement.js:59:4
   59|   (idx(new Foo1(), o => o.a.b): number); // error: result must be MaybeT
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^

References:
   idx_replacement.js:55:29
   55|   class Foo1 { a: ?Foo1; b: ?number; }
                                   ^^^^^^^ [1]
   idx_replacement.js:59:33
   59|   (idx(new Foo1(), o => o.a.b): number); // error: result must be MaybeT
                                       ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------- idx_replacement.js:60:26

Cannot assign `null` to `o.a` because property `a` is not writable. [cannot-write]

   60|   idx(new Foo1(), o => o.a = null); // error: not writable
                                ^


Error ------------------------------------------------------------------------------------------ idx_replacement.js:72:4

Cannot cast `idx(...)` to number because null or undefined [1] is incompatible with number [2]. [incompatible-cast]

   idx_replacement.js:72:4
   72|   (idx(42, n => n): number); // error: result must be MaybeT
          ^^^^^^^^^^^^^^^

References:
   idx_replacement.js:24:4
   24| ): ?UnboxDeepRequired<T2>;
          ^^^^^^^^^^^^^^^^^^^^^^ [1]
   idx_replacement.js:72:21
   72|   (idx(42, n => n): number); // error: result must be MaybeT
                           ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------- idx_replacement.js:73:18

Cannot get `n.nope` because property `nope` is missing in `DeepRequired` [1]. [prop-missing]

   idx_replacement.js:73:18
   73|   idx(42, n => n.nope); // error: prop-missing
                        ^^^^

References:
   idx_replacement.js:23:34
   23|   accessor: (prop: $NonMaybeType<DeepRequired<T1>>) => T2,
                                        ^^^^^^^^^^^^^^^^ [1]


Error ----------------------------------------------------------------------------------------- idx_replacement.js:80:18

Cannot call `obj` because a call signature declaring the expected parameter / return type is missing in
`DeepRequired` [1]. [prop-missing]

   idx_replacement.js:80:18
   80|   idx({}, obj => obj()); // error
                        ^^^

References:
   idx_replacement.js:23:34
   23|   accessor: (prop: $NonMaybeType<DeepRequired<T1>>) => T2,
                                        ^^^^^^^^^^^^^^^^ [1]


Error ------------------------------------------------------------------------------------------ idx_replacement.js:89:4

Cannot cast `a` to empty because string [1] is incompatible with empty [2]. [incompatible-cast]

   idx_replacement.js:89:4
   89|   (a: empty); // error
          ^

References:
   idx_replacement.js:85:40
   85|   declare const props: { data: { +id: ?string } };
                                              ^^^^^^ [1]
   idx_replacement.js:89:7
   89|   (a: empty); // error
             ^^^^^ [2]


Error ------------------------------------------------------------------------------------------ idx_replacement.js:91:6

Cannot cast `a` to empty because string [1] is incompatible with empty [2]. [incompatible-cast]

   idx_replacement.js:91:6
   91|     (a: empty); // error
            ^

References:
   idx_replacement.js:85:40
   85|   declare const props: { data: { +id: ?string } };
                                              ^^^^^^ [1]
   idx_replacement.js:91:9
   91|     (a: empty); // error
               ^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- import.js:18:4

Cannot cast `mapped` to object type because string [1] is incompatible with empty [2] in property `bar`.
[incompatible-cast]

   import.js:18:4
   18|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
          ^^^^^^

References:
   export.js:1:30
    1| type O = {foo: number, bar?: string, +baz: bool};
                                    ^^^^^^ [1]
   import.js:18:30
   18|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
                                    ^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- import.js:18:4

Cannot cast `mapped` to object type because undefined [1] is incompatible with empty [2] in property `bar`.
[incompatible-cast]

   import.js:18:4
   18|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
          ^^^^^^

References:
   export.js:1:30
    1| type O = {foo: number, bar?: string, +baz: bool};
                                    ^^^^^^ [1]
   import.js:18:30
   18|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
                                    ^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- import.js:18:4

Cannot cast `mapped` to object type because undefined [1] is incompatible with empty [2] in property `bar`.
[incompatible-cast]

   import.js:18:4
   18|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
          ^^^^^^

References:
   export.js:3:42
    3| export type MappedO = {[key in keyof O]: O[key]};
                                                ^^^^^^ [1]
   import.js:18:30
   18|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
                                    ^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- import.js:18:4

Cannot cast `mapped` to object type because boolean [1] is incompatible with empty [2] in property `baz`.
[incompatible-cast]

   import.js:18:4
   18|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
          ^^^^^^

References:
   export.js:1:44
    1| type O = {foo: number, bar?: string, +baz: bool};
                                                  ^^^^ [1]
   import.js:18:43
   18|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
                                                 ^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- import.js:18:4

Cannot cast `mapped` to object type because number [1] is incompatible with empty [2] in property `foo`.
[incompatible-cast]

   import.js:18:4
   18|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
          ^^^^^^

References:
   export.js:1:16
    1| type O = {foo: number, bar?: string, +baz: bool};
                      ^^^^^^ [1]
   import.js:18:18
   18|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
                        ^^^^^ [2]


Error -------------------------------------------------------------------------------------------------- import.js:19:10

Cannot assign `true` to `mapped.baz` because property `baz` is not writable. [cannot-write]

   19|   mapped.baz = true; // ERROR
                ^^^


Error -------------------------------------------------------------------------------------------------- import.js:27:15

Cannot assign `true` to `addOptional.baz` because property `baz` is not writable. [cannot-write]

   27|   addOptional.baz = true; // ERROR
                     ^^^


Error -------------------------------------------------------------------------------------------------- import.js:34:12

Cannot assign `4` to `readonly.foo` because property `foo` is not writable. [cannot-write]

   34|   readonly.foo = 4; // ERROR;
                  ^^^


Error -------------------------------------------------------------------------------------------------- import.js:35:12

Cannot assign `'str'` to `readonly.bar` because property `bar` is not writable. [cannot-write]

   35|   readonly.bar = 'str'; // ERROR;
                  ^^^


Error -------------------------------------------------------------------------------------------------- import.js:36:12

Cannot assign `false` to `readonly.baz` because property `baz` is not writable. [cannot-write]

   36|   readonly.baz = false; // ERROR;
                  ^^^


Error --------------------------------------------------------------------------------------------------- import.js:47:4

Cannot cast `mapped` to object type because undefined [1] is incompatible with empty [2] in property `bar`.
[incompatible-cast]

   import.js:47:4
   47|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
          ^^^^^^

References:
   export.js:7:60
    7| export type ParameterizedId<O: {...}> = {[key in keyof O]: O[key]};
                                                                  ^^^^^^ [1]
   import.js:47:30
   47|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
                                    ^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- import.js:47:4

Cannot cast `mapped` to object type because string [1] is incompatible with empty [2] in property `bar`.
[incompatible-cast]

   import.js:47:4
   47|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
          ^^^^^^

References:
   import.js:40:30
   40| type O = {foo: number, bar?: string, +baz: bool};
                                    ^^^^^^ [1]
   import.js:47:30
   47|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
                                    ^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- import.js:47:4

Cannot cast `mapped` to object type because undefined [1] is incompatible with empty [2] in property `bar`.
[incompatible-cast]

   import.js:47:4
   47|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
          ^^^^^^

References:
   import.js:40:30
   40| type O = {foo: number, bar?: string, +baz: bool};
                                    ^^^^^^ [1]
   import.js:47:30
   47|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
                                    ^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- import.js:47:4

Cannot cast `mapped` to object type because boolean [1] is incompatible with empty [2] in property `baz`.
[incompatible-cast]

   import.js:47:4
   47|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
          ^^^^^^

References:
   import.js:40:44
   40| type O = {foo: number, bar?: string, +baz: bool};
                                                  ^^^^ [1]
   import.js:47:43
   47|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
                                                 ^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- import.js:47:4

Cannot cast `mapped` to object type because number [1] is incompatible with empty [2] in property `foo`.
[incompatible-cast]

   import.js:47:4
   47|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
          ^^^^^^

References:
   import.js:40:16
   40| type O = {foo: number, bar?: string, +baz: bool};
                      ^^^^^^ [1]
   import.js:47:18
   47|   (mapped: {foo: empty, bar: empty, +baz: empty}); // ERROR
                        ^^^^^ [2]


Error -------------------------------------------------------------------------------------------------- import.js:48:10

Cannot assign `true` to `mapped.baz` because property `baz` is not writable. [cannot-write]

   48|   mapped.baz = true; // ERROR
                ^^^


Error -------------------------------------------------------------------------------------------------- import.js:56:15

Cannot assign `true` to `addOptional.baz` because property `baz` is not writable. [cannot-write]

   56|   addOptional.baz = true; // ERROR
                     ^^^


Error -------------------------------------------------------------------------------------------------- import.js:63:12

Cannot assign `4` to `readonly.foo` because property `foo` is not writable. [cannot-write]

   63|   readonly.foo = 4; // ERROR;
                  ^^^


Error -------------------------------------------------------------------------------------------------- import.js:64:12

Cannot assign `'str'` to `readonly.bar` because property `bar` is not writable. [cannot-write]

   64|   readonly.bar = 'str'; // ERROR;
                  ^^^


Error -------------------------------------------------------------------------------------------------- import.js:65:12

Cannot assign `false` to `readonly.baz` because property `baz` is not writable. [cannot-write]

   65|   readonly.baz = false; // ERROR;
                  ^^^


Error -------------------------------------------------------------------------------------------------- import.js:71:10

Cannot cast object literal to `MappedNonHomomorphic` because null [1] is incompatible with number [2] in property `foo`.
[incompatible-cast]

   import.js:71:10
   71|   ({foo: null, bar: null}: MappedNonHomomorphic); // ERROR!
                ^^^^ [1]

References:
   export.js:11:61
   11| export type MappedNonHomomorphic = {[key in 'foo' | 'bar']: number};
                                                                   ^^^^^^ [2]


Error -------------------------------------------------------------------------------------------------- import.js:71:21

Cannot cast object literal to `MappedNonHomomorphic` because null [1] is incompatible with number [2] in property `bar`.
[incompatible-cast]

   import.js:71:21
   71|   ({foo: null, bar: null}: MappedNonHomomorphic); // ERROR!
                           ^^^^ [1]

References:
   export.js:11:61
   11| export type MappedNonHomomorphic = {[key in 'foo' | 'bar']: number};
                                                                   ^^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- import.js:78:4

Cannot cast `semi` to object type because property `foo` is read-only in `SemiHomomorphic` [1] but writable in object
type [2]. [incompatible-variance]

   import.js:78:4
   78|   (semi: {foo: number}); // ERROR
          ^^^^

References:
   import.js:76:23
   76|   declare const semi: SemiHomomorphic<{+foo: number, bar: string}, 'foo'>;
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]
   import.js:78:10
   78|   (semi: {foo: number}); // ERROR
                ^^^^^^^^^^^^^ [2]


Error --------------------------------------------------------------------------------------------------- import.js:85:4

Cannot cast `semi` to union type because: [incompatible-cast]
 - Either string [1] is incompatible with number [2] in property `foo`.
 - Or property `foo` is read-only in `SemiHomomorphic` [3] but writable in object type [4].

   import.js:85:4
   85|   (semi: {foo: number} | {foo: string}); // ERROR 2x
          ^^^^

References:
   import.js:83:63
   83|   declare const semi: SemiHomomorphic<{+foo: number} | {+foo: string}, 'foo'>;
                                                                     ^^^^^^ [1]
   import.js:85:16
   85|   (semi: {foo: number} | {foo: string}); // ERROR 2x
                      ^^^^^^ [2]
   import.js:83:23
   83|   declare const semi: SemiHomomorphic<{+foo: number} | {+foo: string}, 'foo'>;
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [3]
   import.js:85:26
   85|   (semi: {foo: number} | {foo: string}); // ERROR 2x
                                ^^^^^^^^^^^^^ [4]


Error --------------------------------------------------------------------------------------------------- import.js:85:4

Cannot cast `semi` to union type because: [incompatible-cast]
 - Either property `foo` is read-only in `SemiHomomorphic` [1] but writable in object type [2].
 - Or number [3] is incompatible with string [4] in property `foo`.

   import.js:85:4
   85|   (semi: {foo: number} | {foo: string}); // ERROR 2x
          ^^^^

References:
   import.js:83:23
   83|   declare const semi: SemiHomomorphic<{+foo: number} | {+foo: string}, 'foo'>;
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]
   import.js:85:10
   85|   (semi: {foo: number} | {foo: string}); // ERROR 2x
                ^^^^^^^^^^^^^ [2]
   import.js:83:46
   83|   declare const semi: SemiHomomorphic<{+foo: number} | {+foo: string}, 'foo'>;
                                                    ^^^^^^ [3]
   import.js:85:32
   85|   (semi: {foo: number} | {foo: string}); // ERROR 2x
                                      ^^^^^^ [4]


Error --------------------------------------------------------------------------------------------------- import.js:89:4

Cannot cast `homomorphic` to union type because: [incompatible-cast]
 - Either property `bar` is read-only in `ParameterizedReadonly` [1] but writable in object type [2].
 - Or property `bar` is missing in object type [3] but exists in `ParameterizedReadonly` [1].

   import.js:89:4
   89|   (homomorphic: {foo: number} | {bar: number}); // ERROR 2x
          ^^^^^^^^^^^

References:
   import.js:87:30
   87|   declare const homomorphic: ParameterizedReadonly<{foo: number} | {bar:number} >;
                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]
   import.js:89:33
   89|   (homomorphic: {foo: number} | {bar: number}); // ERROR 2x
                                       ^^^^^^^^^^^^^ [2]
   import.js:89:17
   89|   (homomorphic: {foo: number} | {bar: number}); // ERROR 2x
                       ^^^^^^^^^^^^^ [3]


Error --------------------------------------------------------------------------------------------------- import.js:89:4

Cannot cast `homomorphic` to union type because: [incompatible-cast]
 - Either property `foo` is read-only in `ParameterizedReadonly` [1] but writable in object type [2].
 - Or property `foo` is missing in object type [3] but exists in `ParameterizedReadonly` [1].

   import.js:89:4
   89|   (homomorphic: {foo: number} | {bar: number}); // ERROR 2x
          ^^^^^^^^^^^

References:
   import.js:87:30
   87|   declare const homomorphic: ParameterizedReadonly<{foo: number} | {bar:number} >;
                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]
   import.js:89:17
   89|   (homomorphic: {foo: number} | {bar: number}); // ERROR 2x
                       ^^^^^^^^^^^^^ [2]
   import.js:89:33
   89|   (homomorphic: {foo: number} | {bar: number}); // ERROR 2x
                                       ^^^^^^^^^^^^^ [3]


Error ------------------------------------------------------------------------------------------------- instancet.js:9:4

Cannot cast `i` to interface type because property `foo` is read-only in mapped type [1] but writable in interface
type [2]. [incompatible-variance]

   instancet.js:9:4
   9|   (i: interface {foo: number}); // ERROR
         ^

References:
   instancet.js:7:20
   7|   declare const i: MappedInterface;
                         ^^^^^^^^^^^^^^^ [1]
   instancet.js:9:7
   9|   (i: interface {foo: number}); // ERROR
            ^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------ instancet.js:10:4

Cannot cast `i` to object type because mapped type [1] is not a subtype of object type [2]. Class instances are not
subtypes of object types; consider rewriting object type [2] as an interface. [class-object-subtyping]

   instancet.js:10:4
   10|   (i: {+foo: number, ...}); // ERROR (class object subtyping)
          ^

References:
   instancet.js:7:20
    7|   declare const i: MappedInterface;
                          ^^^^^^^^^^^^^^^ [1]
   instancet.js:10:7
   10|   (i: {+foo: number, ...}); // ERROR (class object subtyping)
             ^^^^^^^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------ instancet.js:21:4

Cannot cast `i` to interface type because an index signature declaring the expected key / value type is read-only in
mapped type [1] but writable in interface type [2]. [incompatible-variance]

   instancet.js:21:4
   21|   (i: interface {+foo: number, [string]: boolean}); // ERROR
          ^

References:
   instancet.js:19:20
   19|   declare const i: MappedInterfaceWithIndexer;
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]
   instancet.js:21:7
   21|   (i: interface {+foo: number, [string]: boolean}); // ERROR
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------ instancet.js:33:4

Cannot cast `inst` to interface type because property `foo` is read-only in mapped type [1] but writable in interface
type [2]. [incompatible-variance]

   instancet.js:33:4
   33|   (inst: interface {foo: number}); // ERROR
          ^^^^

References:
   instancet.js:31:23
   31|   declare const inst: MappedInstance;
                             ^^^^^^^^^^^^^^ [1]
   instancet.js:33:10
   33|   (inst: interface {foo: number}); // ERROR
                ^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------ instancet.js:34:9

Cannot get `inst['bar']` because property `bar` is missing in mapped type [1]. [prop-missing]

   instancet.js:34:9
   34|   (inst['bar']); // ERROR
               ^^^^^

References:
   instancet.js:31:23
   31|   declare const inst: MappedInstance;
                             ^^^^^^^^^^^^^^ [1]


Error ------------------------------------------------------------------------------------------------ instancet.js:41:4

Cannot cast `c` to interface type because property `bar` is read-only in mapped type [1] but writable in interface
type [2]. [incompatible-variance]

   instancet.js:41:4
   41|   (c: interface {bar: number}); // ERROR
          ^

References:
   instancet.js:39:20
   39|   declare const c: MappedClass;
                          ^^^^^^^^^^^ [1]
   instancet.js:41:7
   41|   (c: interface {bar: number}); // ERROR
             ^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------ no_explicit_exactness.js:7:20

Mapped Types take on the exactness of the argument passed to keyof. They do not support explicit exact or inexact
syntax. [invalid-mapped-type]

                         v----------
   7| type MappedExact = {| // ERROR
   8|   [key in keyof O]: number
   9| |}
      -^


Error ----------------------------------------------------------------------------------- no_explicit_exactness.js:11:22

Mapped Types take on the exactness of the argument passed to keyof. They do not support explicit exact or inexact
syntax. [invalid-mapped-type]

                            v---------
   11| type MappedInexact = { // ERROR
   12|   [key in keyof O]: number,
   13|   ...
   14| }
       ^


Error ------------------------------------------------------------------------------------------- no_other_props.js:3:20

Mapped Types cannot be used when other properties or indexers are present. [invalid-mapped-type]

                         v
   3| type MappedFirst = {
   4|   [key in keyof {foo: number}]: number, // ERROR
   5|   prop: number,
   6| };
      ^


Error ------------------------------------------------------------------------------------------- no_other_props.js:7:19

Mapped Types cannot be used when other properties or indexers are present. [invalid-mapped-type]

                         v
    7| type SliceFirst = {
    8|   prop: number,
    9|   [key in keyof {foo: number}]: number, // ERROR
   10| };
       ^


Error ------------------------------------------------------------------------------------------ no_other_props.js:11:20

Mapped Types cannot be used when other properties or indexers are present. [invalid-mapped-type]

                          v
   11| type SpreadFirst = {
   12|   ...{prop: number},
   13|   [key in keyof {foo: number}]: number, // ERROR
   14| };
       ^


Error ------------------------------------------------------------------------------------------ no_other_props.js:15:21

Mapped Types cannot be used when other properties or indexers are present. [invalid-mapped-type]

                           v
   15| type MappedLater1 = {
   16|   ...{prop: number},
   17|   foo: number,
   18|   [key in keyof {foo: number}]: number, // ERROR
   19| };
       ^


Error ------------------------------------------------------------------------------------------ no_other_props.js:20:21

Mapped Types cannot be used when other properties or indexers are present. [invalid-mapped-type]

                           v
   20| type MappedLater2 = {
   21|   foo: number,
   22|   ...{prop: number},
   23|   foo: number,
   24|   [key in keyof {foo: number}]: number, // ERROR
   25| };
       ^


Error ------------------------------------------------------------------------------------------ non_homomorphic.js:11:4

Cannot cast `mapped` to empty because mapped type [1] is incompatible with empty [2]. [incompatible-cast]

   non_homomorphic.js:11:4
   11|   (mapped: empty); // ERROR!
          ^^^^^^

References:
   non_homomorphic.js:6:25
    6|   declare const mapped: Mapped;
                               ^^^^^^ [1]
   non_homomorphic.js:11:12
   11|   (mapped: empty); // ERROR!
                  ^^^^^ [2]


Error ------------------------------------------------------------------------------------------ non_homomorphic.js:12:4

Cannot cast `mapped` to object type because number [1] is incompatible with empty [2] in property `bar`.
[incompatible-cast]

   non_homomorphic.js:12:4
   12|   (mapped: {foo: empty, bar: empty}); // ERROR 2x
          ^^^^^^

References:
   non_homomorphic.js:4:33
    4|   type Mapped = {[key in Keys]: number};
                                       ^^^^^^ [1]
   non_homomorphic.js:12:30
   12|   (mapped: {foo: empty, bar: empty}); // ERROR 2x
                                    ^^^^^ [2]


Error ------------------------------------------------------------------------------------------ non_homomorphic.js:12:4

Cannot cast `mapped` to object type because number [1] is incompatible with empty [2] in property `foo`.
[incompatible-cast]

   non_homomorphic.js:12:4
   12|   (mapped: {foo: empty, bar: empty}); // ERROR 2x
          ^^^^^^

References:
   non_homomorphic.js:4:33
    4|   type Mapped = {[key in Keys]: number};
                                       ^^^^^^ [1]
   non_homomorphic.js:12:18
   12|   (mapped: {foo: empty, bar: empty}); // ERROR 2x
                        ^^^^^ [2]


Error ------------------------------------------------------------------------------------------ non_homomorphic.js:21:4

Cannot cast `withLeftovers` to object type because number [1] is incompatible with string [2] in property `foo`.
[incompatible-cast]

   non_homomorphic.js:21:4
   21|   (withLeftovers: {[number]: string, foo: string}); // ERROR 2x
          ^^^^^^^^^^^^^

References:
   non_homomorphic.js:18:50
   18|   type WithLeftovers = {[key in 'foo' | number]: number};
                                                        ^^^^^^ [1]
   non_homomorphic.js:21:43
   21|   (withLeftovers: {[number]: string, foo: string}); // ERROR 2x
                                                 ^^^^^^ [2]


Error ------------------------------------------------------------------------------------------ non_homomorphic.js:21:4

Cannot cast `withLeftovers` to object type because number [1] is incompatible with string [2] in the indexer property.
[incompatible-cast]

   non_homomorphic.js:21:4
   21|   (withLeftovers: {[number]: string, foo: string}); // ERROR 2x
          ^^^^^^^^^^^^^

References:
   non_homomorphic.js:18:50
   18|   type WithLeftovers = {[key in 'foo' | number]: number};
                                                        ^^^^^^ [1]
   non_homomorphic.js:21:30
   21|   (withLeftovers: {[number]: string, foo: string}); // ERROR 2x
                                    ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------- non_homomorphic.js:28:27

Cannot instantiate mapped type [1] because boolean [2] is incompatible with `string | number | symbol`, so it cannot be
used to generate keys for mapped type [1]. [incompatible-type]

   non_homomorphic.js:28:27
   28|   type BadKeys = {[key in boolean]: number}; // ERROR!
                                 ^^^^^^^ [2]

References:
   non_homomorphic.js:28:18
   28|   type BadKeys = {[key in boolean]: number}; // ERROR!
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]


Error ------------------------------------------------------------------------------------------ non_homomorphic.js:40:4

Cannot cast `keyMirroredObject` to object type because string literal `bar` [1] is incompatible with string literal
`baz` [2] in property `bar`. [incompatible-cast]

   non_homomorphic.js:40:4
   40|   (keyMirroredObject: {foo: 'bar', bar: 'baz', baz: 'foo'}); // ERROR x3
          ^^^^^^^^^^^^^^^^^

References:
   non_homomorphic.js:35:69
   35|   declare function keyMirror<T>(...$ReadOnlyArray<T>): {[key in T]: key};
                                                                           ^^^ [1]
   non_homomorphic.js:40:41
   40|   (keyMirroredObject: {foo: 'bar', bar: 'baz', baz: 'foo'}); // ERROR x3
                                               ^^^^^ [2]


Error ------------------------------------------------------------------------------------------ non_homomorphic.js:40:4

Cannot cast `keyMirroredObject` to object type because string literal `baz` [1] is incompatible with string literal
`foo` [2] in property `baz`. [incompatible-cast]

   non_homomorphic.js:40:4
   40|   (keyMirroredObject: {foo: 'bar', bar: 'baz', baz: 'foo'}); // ERROR x3
          ^^^^^^^^^^^^^^^^^

References:
   non_homomorphic.js:35:69
   35|   declare function keyMirror<T>(...$ReadOnlyArray<T>): {[key in T]: key};
                                                                           ^^^ [1]
   non_homomorphic.js:40:53
   40|   (keyMirroredObject: {foo: 'bar', bar: 'baz', baz: 'foo'}); // ERROR x3
                                                           ^^^^^ [2]


Error ------------------------------------------------------------------------------------------ non_homomorphic.js:40:4

Cannot cast `keyMirroredObject` to object type because string literal `foo` [1] is incompatible with string literal
`bar` [2] in property `foo`. [incompatible-cast]

   non_homomorphic.js:40:4
   40|   (keyMirroredObject: {foo: 'bar', bar: 'baz', baz: 'foo'}); // ERROR x3
          ^^^^^^^^^^^^^^^^^

References:
   non_homomorphic.js:35:69
   35|   declare function keyMirror<T>(...$ReadOnlyArray<T>): {[key in T]: key};
                                                                           ^^^ [1]
   non_homomorphic.js:40:29
   40|   (keyMirroredObject: {foo: 'bar', bar: 'baz', baz: 'foo'}); // ERROR x3
                                   ^^^^^ [2]


Error ------------------------------------------------------------------------------------------ non_homomorphic.js:48:4

Cannot cast `noContext` to object type because property `baz` is missing in mapped type [1] but exists in object
type [2]. [prop-missing]

   non_homomorphic.js:48:4
   48|   (noContext: {foo: empty, bar: empty, baz: number}); // ERROR 3x
          ^^^^^^^^^

References:
   non_homomorphic.js:45:83
   45|   declare function ObjWithKeys<T>(x: {[key in T]: number}, ...$ReadOnlyArray<T>): {[key in T]: number};
                                                                                         ^^^^^^^^^^^^^^^^^^^^ [1]
   non_homomorphic.js:48:15
   48|   (noContext: {foo: empty, bar: empty, baz: number}); // ERROR 3x
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------ non_homomorphic.js:48:4

Cannot cast `noContext` to object type because number [1] is incompatible with empty [2] in property `bar`.
[incompatible-cast]

   non_homomorphic.js:48:4
   48|   (noContext: {foo: empty, bar: empty, baz: number}); // ERROR 3x
          ^^^^^^^^^

References:
   non_homomorphic.js:45:96
   45|   declare function ObjWithKeys<T>(x: {[key in T]: number}, ...$ReadOnlyArray<T>): {[key in T]: number};
                                                                                                      ^^^^^^ [1]
   non_homomorphic.js:48:33
   48|   (noContext: {foo: empty, bar: empty, baz: number}); // ERROR 3x
                                       ^^^^^ [2]


Error ------------------------------------------------------------------------------------------ non_homomorphic.js:48:4

Cannot cast `noContext` to object type because number [1] is incompatible with empty [2] in property `foo`.
[incompatible-cast]

   non_homomorphic.js:48:4
   48|   (noContext: {foo: empty, bar: empty, baz: number}); // ERROR 3x
          ^^^^^^^^^

References:
   non_homomorphic.js:45:96
   45|   declare function ObjWithKeys<T>(x: {[key in T]: number}, ...$ReadOnlyArray<T>): {[key in T]: number};
                                                                                                      ^^^^^^ [1]
   non_homomorphic.js:48:21
   48|   (noContext: {foo: empty, bar: empty, baz: number}); // ERROR 3x
                           ^^^^^ [2]


Error ------------------------------------------------------------------------------- non_homomorphic_resolution.js:10:4

Cannot cast `mappedTypeApp` to empty because `Mapped` [1] is incompatible with empty [2]. [incompatible-cast]

   non_homomorphic_resolution.js:10:4
   10|   (mappedTypeApp: empty); // ERROR
          ^^^^^^^^^^^^^

References:
   non_homomorphic_resolution.js:9:32
    9|   declare const mappedTypeApp: MappedTypeApp;
                                      ^^^^^^^^^^^^^ [1]
   non_homomorphic_resolution.js:10:19
   10|   (mappedTypeApp: empty); // ERROR
                         ^^^^^ [2]


Error ------------------------------------------------------------------------------- non_homomorphic_resolution.js:18:4

Cannot cast `mappedKeys` to empty because `Mapped` [1] is incompatible with empty [2]. [incompatible-cast]

   non_homomorphic_resolution.js:18:4
   18|   (mappedKeys: empty); // ERROR
          ^^^^^^^^^^

References:
   non_homomorphic_resolution.js:17:29
   17|   declare const mappedKeys: MappedKeys;
                                   ^^^^^^^^^^ [1]
   non_homomorphic_resolution.js:18:16
   18|   (mappedKeys: empty); // ERROR
                      ^^^^^ [2]


Error ------------------------------------------------------------------------------- non_homomorphic_resolution.js:27:4

Cannot cast `mappedEval` to empty because `Mapped` [1] is incompatible with empty [2]. [incompatible-cast]

   non_homomorphic_resolution.js:27:4
   27|   (mappedEval: empty); // ERROR
          ^^^^^^^^^^

References:
   non_homomorphic_resolution.js:26:29
   26|   declare const mappedEval: MappedEval;
                                   ^^^^^^^^^^ [1]
   non_homomorphic_resolution.js:27:16
   27|   (mappedEval: empty); // ERROR
                      ^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- optionality.js:9:4

Cannot cast `preserve` to object type because string [1] is incompatible with number [2] in property `bar`.
[incompatible-cast]

   optionality.js:9:4
   9|   (preserve: {foo: string, bar?: number}); // Error string ~> number, number ~> string
         ^^^^^^^^

References:
   optionality.js:5:38
   5|   type Preserve = {[key in keyof O]: O[key]};
                                           ^^^^^^ [1]
   optionality.js:9:34
   9|   (preserve: {foo: string, bar?: number}); // Error string ~> number, number ~> string
                                       ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- optionality.js:9:4

Cannot cast `preserve` to object type because number [1] is incompatible with string [2] in property `bar`. This
property is invariantly typed. See
https://flow.org/en/docs/faq/#why-cant-i-pass-a-string-to-a-function-that-takes-a-string-number. [incompatible-cast]

   optionality.js:9:4
   9|   (preserve: {foo: string, bar?: number}); // Error string ~> number, number ~> string
         ^^^^^^^^

References:
   optionality.js:9:34
   9|   (preserve: {foo: string, bar?: number}); // Error string ~> number, number ~> string
                                       ^^^^^^ [1]
   optionality.js:1:30
   1| type O = {foo: number, bar?: string};
                                   ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------- optionality.js:9:4

Cannot cast `preserve` to object type because number [1] is incompatible with string [2] in property `foo`.
[incompatible-cast]

   optionality.js:9:4
   9|   (preserve: {foo: string, bar?: number}); // Error string ~> number, number ~> string
         ^^^^^^^^

References:
   optionality.js:5:38
   5|   type Preserve = {[key in keyof O]: O[key]};
                                           ^^^^^^ [1]
   optionality.js:9:20
   9|   (preserve: {foo: string, bar?: number}); // Error string ~> number, number ~> string
                         ^^^^^^ [2]


Error --------------------------------------------------------------------------------------------- optionality.js:13:10

Cannot cast object literal to `Preserve` because string [1] is incompatible with number [2] in property `foo`.
[incompatible-cast]

   optionality.js:13:10
   13|   ({foo: 'str', bar: 3}: Preserve); // ERROR
                ^^^^^ [1]

References:
   optionality.js:5:38
    5|   type Preserve = {[key in keyof O]: O[key]};
                                            ^^^^^^ [2]


Error --------------------------------------------------------------------------------------------- optionality.js:13:22

Cannot cast object literal to `Preserve` because number [1] is incompatible with string [2] in property `bar`.
[incompatible-cast]

   optionality.js:13:22
   13|   ({foo: 'str', bar: 3}: Preserve); // ERROR
                            ^ [1]

References:
   optionality.js:1:30
    1| type O = {foo: number, bar?: string};
                                    ^^^^^^ [2]


Error --------------------------------------------------------------------------------------------- optionality.js:28:19

Mapped Types do not yet support optionality removal. [invalid-mapped-type]

   28|   type Removed = {[key in keyof O]-?: O[key]}; // ERROR
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^


Error -------------------------------------------------------------------------------------------- pick_and_omit.js:17:9

Cannot assign `3` to `noFoo.foo` because property `foo` is missing in `Omit` [1]. [prop-missing]

   pick_and_omit.js:17:9
   17|   noFoo.foo = 3; // ERROR!
               ^^^

References:
   pick_and_omit.js:16:24
   16|   declare const noFoo: Omit<O, 'foo'>;
                              ^^^^^^^^^^^^^^ [1]


Error ------------------------------------------------------------------------------------------- pick_and_omit.js:23:36

Cannot instantiate `Omit` because an index signature declaring the expected key / value type is missing in `O` [1] in
type argument `Keys`. [prop-missing]

   pick_and_omit.js:23:36
   23|   declare const noKeysBad: Omit<O, string>; // ERROR! string is not a subtype of $Keys<O>
                                          ^^^^^^

References:
   pick_and_omit.js:23:33
   23|   declare const noKeysBad: Omit<O, string>; // ERROR! string is not a subtype of $Keys<O>
                                       ^ [1]


Error ------------------------------------------------------------------------------------------- pick_and_omit.js:49:47

Cannot call `omitInput` with object literal bound to `x` because property `bar` is missing in object literal [1] but
exists in `Omit` [2]. [prop-missing]

   pick_and_omit.js:49:47
   49|   const badCall = omitInput({foo: 3, bar: 3}, {foo: 3}, 'foo' as 'foo'); // ERROR 2x
                                                     ^^^^^^^^ [1]

References:
   pick_and_omit.js:45:8
   45|     x: Omit<O, Keys>,
              ^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------- pick_and_omit.js:49:47

Cannot call `omitInput` with object literal bound to `x` because property `foo` is missing in `Omit` [1] but exists in
object literal [2]. [prop-missing]

   pick_and_omit.js:49:47
   49|   const badCall = omitInput({foo: 3, bar: 3}, {foo: 3}, 'foo' as 'foo'); // ERROR 2x
                                                     ^^^^^^^^ [2]

References:
   pick_and_omit.js:45:8
   45|     x: Omit<O, Keys>,
              ^^^^^^^^^^^^^ [1]


Error ------------------------------------------------------------------------------------------- pick_and_omit.js:63:11

Cannot get `onlyFoo.bar` because property `bar` is missing in `Pick` [1]. [prop-missing]

   pick_and_omit.js:63:11
   63|   onlyFoo.bar; // ERROR!
                 ^^^

References:
   pick_and_omit.js:62:26
   62|   declare const onlyFoo: Pick<P, 'foo'>;
                                ^^^^^^^^^^^^^^ [1]


Error ------------------------------------------------------------------------------------------- pick_and_omit.js:83:47

Cannot call `pickInput` with object literal bound to `x` because property `bar` is missing in `Pick` [1] but exists in
object literal [2]. [prop-missing]

   pick_and_omit.js:83:47
   83|   const badCall = pickInput({foo: 3, bar: 3}, {bar: 3}, 'foo'); // ERROR 2x
                                                     ^^^^^^^^ [2]

References:
   pick_and_omit.js:78:8
   78|     x: Pick<O, Keys>,
              ^^^^^^^^^^^^^ [1]


Error ------------------------------------------------------------------------------------------- pick_and_omit.js:83:47

Cannot call `pickInput` with object literal bound to `x` because property `foo` is missing in object literal [1] but
exists in `Pick` [2]. [prop-missing]

   pick_and_omit.js:83:47
   83|   const badCall = pickInput({foo: 3, bar: 3}, {bar: 3}, 'foo'); // ERROR 2x
                                                     ^^^^^^^^ [1]

References:
   pick_and_omit.js:78:8
   78|     x: Pick<O, Keys>,
              ^^^^^^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------------- reasons.js:10:26

Cannot instantiate mapped type [1] because string literal `bar` [2] is incompatible with string literal `foo` [3] in
type argument `T`. [incompatible-type-arg]

   reasons.js:10:26
   10|   type MappedFooBarObj = {[key in keyof FooBarObj]: TakesFoo<key>}; // ERROR
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ [1]

References:
   reasons.js:9:34
    9|   type FooBarObj = {foo: number, bar: number};
                                        ^^^ [2]
   reasons.js:7:20
    7|   type TakesFoo<T: 'foo'> = T;
                          ^^^^^ [3]


Error ----------------------------------------------------------------------------------------- semi_homomorphic.js:11:5

Cannot assign `3` to `a.foo` because property `foo` is not writable. [cannot-write]

   11|   a.foo = 3; // ERROR
           ^^^


Error ---------------------------------------------------------------------------------------- semi_homomorphic.js:13:28

Cannot instantiate `Semi` because property `bar` is missing in `O` [1] in type argument `Keys`. [prop-missing]

   semi_homomorphic.js:13:28
   13|   type MappedBad = Semi<O, 'bar'>; // ERROR HERE
                                  ^^^^^

References:
   semi_homomorphic.js:13:25
   13|   type MappedBad = Semi<O, 'bar'>; // ERROR HERE
                               ^ [1]


Error ----------------------------------------------------------------------------------------- semi_homomorphic.js:26:4

Cannot cast `withIndexer` to object type because indexed `Semi` [1] is incompatible with exact object type [2].
[incompatible-indexer]

   semi_homomorphic.js:26:4
   26|   (withIndexer: {foo: number}); // ERROR, missing indexer
          ^^^^^^^^^^^

References:
   semi_homomorphic.js:24:30
   24|   declare const withIndexer: MappedWithIndexer;
                                    ^^^^^^^^^^^^^^^^^ [1]
   semi_homomorphic.js:26:17
   26|   (withIndexer: {foo: number}); // ERROR, missing indexer
                       ^^^^^^^^^^^^^ [2]


Error ----------------------------------------------------------------------------------------- semi_homomorphic.js:34:4

Cannot cast `p` to `MappedWithoutIndexer` because indexed `P` [1] is incompatible with exact `Semi` [2].
[incompatible-indexer]

   semi_homomorphic.js:34:4
   34|   (p: MappedWithoutIndexer); // ERROR
          ^

References:
   semi_homomorphic.js:33:20
   33|   declare const p: P;
                          ^ [1]
   semi_homomorphic.js:34:7
   34|   (p: MappedWithoutIndexer); // ERROR
             ^^^^^^^^^^^^^^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------- semi_homomorphic.js:38:29

Cannot instantiate `Semi` because number [1] is incompatible with key set [2] in type argument `Keys`.
[incompatible-type-arg]

   semi_homomorphic.js:38:29
   38|   type IndexedBad = Semi<P, number>; // ERROR
                                   ^^^^^^ [1]

References:
   semi_homomorphic.js:1:27
    1| type Semi<O: {...}, Keys: $Keys<O>> = {
                                 ^^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------- semi_homomorphic.js:44:32

Cannot instantiate `Semi` because number [1] is incompatible with key set [2] in type argument `Keys`.
[incompatible-type-arg]

   semi_homomorphic.js:44:32
   44|   type NoIndexerBad = Semi<{}, number>; // ERROR
                                      ^^^^^^ [1]

References:
   semi_homomorphic.js:1:27
    1| type Semi<O: {...}, Keys: $Keys<O>> = {
                                 ^^^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------------- test.js:26:4

Cannot cast `badKey` to `Mapped` because property `bar` is missing in `Mapped` [1] but exists in object type [2].
[prop-missing]

   test.js:26:4
   26|   (badKey: Mapped<O>); // ERROR
          ^^^^^^

References:
   test.js:26:12
   26|   (badKey: Mapped<O>); // ERROR
                  ^^^^^^^^^ [1]
   test.js:25:25
   25|   declare const badKey: {bar: {contents: number}};
                               ^^^^^^^^^^^^^^^^^^^^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------------- test.js:26:4

Cannot cast `badKey` to `Mapped` because property `foo` is missing in object type [1] but exists in `Mapped` [2].
[prop-missing]

   test.js:26:4
   26|   (badKey: Mapped<O>); // ERROR
          ^^^^^^

References:
   test.js:25:25
   25|   declare const badKey: {bar: {contents: number}};
                               ^^^^^^^^^^^^^^^^^^^^^^^^^ [1]
   test.js:26:12
   26|   (badKey: Mapped<O>); // ERROR
                  ^^^^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------------- test.js:29:4

Cannot cast `badVal` to `Mapped` because string [1] is incompatible with number [2] in property `foo.contents`.
[incompatible-cast]

   test.js:29:4
   29|   (badVal: Mapped<O>); // ERROR
          ^^^^^^

References:
   test.js:28:42
   28|   declare const badVal: {foo: {contents: string}};
                                                ^^^^^^ [1]
   test.js:1:18
    1| type O = {| foo: number |}
                        ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------------- test.js:35:5

Mapped Types are not supported in interfaces or declared classes. [invalid-mapped-type]

   35|     [x in keyof O]: number; // ERROR
           ^^^^^^^^^^^^^^^^^^^^^^


Error ----------------------------------------------------------------------------------------------------- test.js:38:5

Mapped Types are not supported in interfaces or declared classes. [invalid-mapped-type]

   38|     [x in keyof O]: number; // ERROR
           ^^^^^^^^^^^^^^^^^^^^^^


Error ----------------------------------------------------------------------------------------------------- test.js:47:4

Cannot cast `mappedIndexer.foo` to number because `Box` [1] is incompatible with number [2]. [incompatible-cast]

   test.js:47:4
   47|   (mappedIndexer.foo: number); // ERROR
          ^^^^^^^^^^^^^^^^^

References:
   test.js:11:21
   11|   [key in keyof O]: Box<O[key]>,
                           ^^^^^^^^^^^ [1]
   test.js:47:23
   47|   (mappedIndexer.foo: number); // ERROR
                             ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------------- test.js:48:4

Cannot cast `mappedIndexer.bar` to string because `Box` [1] is incompatible with string [2]. [incompatible-cast]

   test.js:48:4
   48|   (mappedIndexer.bar: string); // ERROR
          ^^^^^^^^^^^^^^^^^

References:
   test.js:11:21
   11|   [key in keyof O]: Box<O[key]>,
                           ^^^^^^^^^^^ [1]
   test.js:48:23
   48|   (mappedIndexer.bar: string); // ERROR
                             ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------------- test.js:60:12

Cannot assign `3` to `readonly.foo` because property `foo` is not writable. [cannot-write]

   60|   readonly.foo = 3; // ERROR
                  ^^^


Error ---------------------------------------------------------------------------------------------------- test.js:64:14

Cannot get `writeonly.foo` because property `foo` is not readable. [cannot-read]

   64|   (writeonly.foo: number); // ERROR
                    ^^^


Error ---------------------------------------------------------------------------------------------------- test.js:70:19

Cannot assign `'str'` to `readonlyIndexer.qux` because property `qux` is not writable. [cannot-write]

   70|   readonlyIndexer.qux = 'str'; // ERROR
                         ^^^


Error ----------------------------------------------------------------------------------------------------- test.js:77:4

Cannot cast `partial.foo` to number because undefined [1] is incompatible with number [2]. [incompatible-cast]

   test.js:77:4
   77|   (partial.foo: number); // ERROR
          ^^^^^^^^^^^

References:
   test.js:75:48
   75|   type Partial<T: {...}> = {[key in keyof T]?: T[key]};
                                                      ^^^^^^ [1]
   test.js:77:17
   77|   (partial.foo: number); // ERROR
                       ^^^^^^ [2]


Error ----------------------------------------------------------------------------------------------------- test.js:81:4

Cannot cast `partialIndexer.qux` to string because undefined [1] is incompatible with string [2]. [incompatible-cast]

   test.js:81:4
   81|   (partialIndexer.qux: string); // ERROR
          ^^^^^^^^^^^^^^^^^^

References:
   test.js:75:48
   75|   type Partial<T: {...}> = {[key in keyof T]?: T[key]};
                                                      ^^^^^^ [1]
   test.js:81:24
   81|   (partialIndexer.qux: string); // ERROR
                              ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------------- test.js:92:28

Cannot instantiate `MappedConstrained` because number [1] is incompatible with string [2] in type argument `T`.
[incompatible-type-arg]

   test.js:92:28
   92|   declare var constrained: MappedConstrained<O>; // ERROR HERE, NOT IN DEFINITION OF MAPPEDCONSTRAINED
                                  ^^^^^^^^^^^^^^^^^^^^

References:
   test.js:1:18
    1| type O = {| foo: number |}
                        ^^^^^^ [1]
   test.js:87:26
   87|   type ConstrainedBox<T: string> = Box<T>;
                                ^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------------- test.js:99:35

Cannot instantiate `UnconstrainedKey` because boolean [1] is incompatible with `string | number | symbol`, so it cannot
be used to generate keys for `UnconstrainedKey` [2]. [incompatible-type]

   test.js:99:35
   99|   type BadKeys = UnconstrainedKey<boolean>; // ERROR HERE, NOT LINE ABOVE
                                         ^^^^^^^ [1]

References:
   test.js:98:30
   98|   type UnconstrainedKey<T> = {[key in T]: number};
                                    ^^^^^^^^^^^^^^^^^^^^ [2]


Error ---------------------------------------------------------------------------------------------------- test.js:101:4

Cannot cast `badKeys` to empty because `UnconstrainedKey` [1] is incompatible with empty [2]. [incompatible-cast]

   test.js:101:4
   101|   (badKeys: empty); // ERROR
           ^^^^^^^

References:
   test.js:100:26
   100|   declare const badKeys: BadKeys;
                                 ^^^^^^^ [1]
   test.js:101:13
   101|   (badKeys: empty); // ERROR
                    ^^^^^ [2]



Found 135 errors

Only showing the most relevant union/intersection branches.
To see all branches, re-run Flow with --show-all-branches
