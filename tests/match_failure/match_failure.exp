Error -------------------------------------------------------------------------------------------- disjoint_union.js:8:7

Cannot compare `shape.type` [1] to string literal `square` [2], because `shape.type` [1] is not a subtype of string
literal `square` [2] and string literal `square` [2] is not a subtype of `shape.type` [1]. In **rare** cases, these
types may have overlapping values but lack a subtyping relationship. If that happens, you can cast one side to the union
of both types to pass the flow check.  [invalid-compare]

   disjoint_union.js:8:7
   8|   if (shape.type === 'square') { // error
            ^^^^^^^^^^^^^^^^^^^^^^^

References:
   disjoint_union.js:8:7
   8|   if (shape.type === 'square') { // error
            ^^^^^^^^^^ [1]
   disjoint_union.js:8:22
   8|   if (shape.type === 'square') { // error
                           ^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------- disjoint_union.js:21:7

Cannot compare `shape.type` [1] to string literal `square` [2], because `shape.type` [1] is not a subtype of string
literal `square` [2] and string literal `square` [2] is not a subtype of `shape.type` [1]. In **rare** cases, these
types may have overlapping values but lack a subtyping relationship. If that happens, you can cast one side to the union
of both types to pass the flow check.  [invalid-compare]

   disjoint_union.js:21:7
   21|   if (shape.type === 'square') { // error
             ^^^^^^^^^^^^^^^^^^^^^^^

References:
   disjoint_union.js:21:7
   21|   if (shape.type === 'square') { // error
             ^^^^^^^^^^ [1]
   disjoint_union.js:21:22
   21|   if (shape.type === 'square') { // error
                            ^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------- disjoint_union.js:34:7

Cannot compare `shape.type` [1] to string literal `square` [2], because `shape.type` [1] is not a subtype of string
literal `square` [2] and string literal `square` [2] is not a subtype of `shape.type` [1]. In **rare** cases, these
types may have overlapping values but lack a subtyping relationship. If that happens, you can cast one side to the union
of both types to pass the flow check.  [invalid-compare]

   disjoint_union.js:34:7
   34|   if (shape.type === 'square') { // error
             ^^^^^^^^^^^^^^^^^^^^^^^

References:
   disjoint_union.js:34:7
   34|   if (shape.type === 'square') { // error
             ^^^^^^^^^^ [1]
   disjoint_union.js:34:22
   34|   if (shape.type === 'square') { // error
                            ^^^^^^^^ [2]


Error ------------------------------------------------------------------------------------------- disjoint_union.js:56:7

Cannot compare `x.type` [1] to `C` [2], because `x.type` [1] is not a subtype of string literal `C` [3] and string
literal `C` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:56:7
   56|       case C: break; // error C is not included in 'A' | 'B'
             ^^^^^^

References:
   disjoint_union.js:53:13
   53|     switch (x.type) {
                   ^^^^^^ [1]
   disjoint_union.js:45:9
   45|   const C: 'C' = 'C';
               ^ [2]
   disjoint_union.js:45:12
   45|   const C: 'C' = 'C';
                  ^^^ [3]


Error ------------------------------------------------------------------------------------------- disjoint_union.js:57:7

Cannot compare `x.type` [1] to `D` [2], because `x.type` [1] is not a subtype of string literal `D` [3] and string
literal `D` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:57:7
   57|       case D: break; // error D is not included in 'A' | 'B'
             ^^^^^^

References:
   disjoint_union.js:53:13
   53|     switch (x.type) {
                   ^^^^^^ [1]
   disjoint_union.js:46:9
   46|   const D: 'D' = 'D';
               ^ [2]
   disjoint_union.js:46:12
   46|   const D: 'D' = 'D';
                  ^^^ [3]


Error ------------------------------------------------------------------------------------------- disjoint_union.js:65:7

Cannot compare `x.type` [1] to `OBJ.C` [2], because `x.type` [1] is not a subtype of string literal `C` [3] and string
literal `C` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:65:7
   65|       case OBJ.C: break; // error C is not included in 'A' | 'B'
             ^^^^^^^^^^

References:
   disjoint_union.js:62:13
   62|     switch (x.type) {
                   ^^^^^^ [1]
   disjoint_union.js:65:12
   65|       case OBJ.C: break; // error C is not included in 'A' | 'B'
                  ^^^^^ [2]
   disjoint_union.js:45:12
   45|   const C: 'C' = 'C';
                  ^^^ [3]


Error ------------------------------------------------------------------------------------------- disjoint_union.js:66:7

Cannot compare `x.type` [1] to `OBJ.D` [2], because `x.type` [1] is not a subtype of string literal `D` [3] and string
literal `D` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:66:7
   66|       case OBJ.D: break; // error D is not included in 'A' | 'B'
             ^^^^^^^^^^

References:
   disjoint_union.js:62:13
   62|     switch (x.type) {
                   ^^^^^^ [1]
   disjoint_union.js:66:12
   66|       case OBJ.D: break; // error D is not included in 'A' | 'B'
                  ^^^^^ [2]
   disjoint_union.js:46:12
   46|   const D: 'D' = 'D';
                  ^^^ [3]


Error ------------------------------------------------------------------------------------------- disjoint_union.js:73:9

Cannot compare `x.type` [1] to `C` [2], because `x.type` [1] is not a subtype of string literal `C` [3] and string
literal `C` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:73:9
   73|     if (x.type === C) {}; // error C is not included in 'A' | 'B'
               ^^^^^^^^^^^^

References:
   disjoint_union.js:73:9
   73|     if (x.type === C) {}; // error C is not included in 'A' | 'B'
               ^^^^^^ [1]
   disjoint_union.js:45:9
   45|   const C: 'C' = 'C';
               ^ [2]
   disjoint_union.js:45:12
   45|   const C: 'C' = 'C';
                  ^^^ [3]


Error ------------------------------------------------------------------------------------------- disjoint_union.js:74:9

Cannot compare `x.type` [1] to `D` [2], because `x.type` [1] is not a subtype of string literal `D` [3] and string
literal `D` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:74:9
   74|     if (x.type === D) {}; // error D is not included in 'A' | 'B'
               ^^^^^^^^^^^^

References:
   disjoint_union.js:74:9
   74|     if (x.type === D) {}; // error D is not included in 'A' | 'B'
               ^^^^^^ [1]
   disjoint_union.js:46:9
   46|   const D: 'D' = 'D';
               ^ [2]
   disjoint_union.js:46:12
   46|   const D: 'D' = 'D';
                  ^^^ [3]


Error ------------------------------------------------------------------------------------------- disjoint_union.js:81:7

Cannot compare `x.type` [1] to `C` [2], because `x.type` [1] is not a subtype of string literal `C` [3] and string
literal `C` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:81:7
   81|       case C: break; // error C is not included in 'A'
             ^^^^^^

References:
   disjoint_union.js:78:13
   78|     switch (x.type) {
                   ^^^^^^ [1]
   disjoint_union.js:45:9
   45|   const C: 'C' = 'C';
               ^ [2]
   disjoint_union.js:45:12
   45|   const C: 'C' = 'C';
                  ^^^ [3]


Error ------------------------------------------------------------------------------------------- disjoint_union.js:82:7

Cannot compare `x.type` [1] to `D` [2], because `x.type` [1] is not a subtype of string literal `D` [3] and string
literal `D` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:82:7
   82|       case D: break; // error D is not included in 'A'
             ^^^^^^

References:
   disjoint_union.js:78:13
   78|     switch (x.type) {
                   ^^^^^^ [1]
   disjoint_union.js:46:9
   46|   const D: 'D' = 'D';
               ^ [2]
   disjoint_union.js:46:12
   46|   const D: 'D' = 'D';
                  ^^^ [3]


Error ------------------------------------------------------------------------------------------- disjoint_union.js:89:9

Cannot compare `x.type` [1] to `C` [2], because `x.type` [1] is not a subtype of string literal `C` [3] and string
literal `C` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:89:9
   89|     if (x.type === C) {}; // error C is not included in 'A'
               ^^^^^^^^^^^^

References:
   disjoint_union.js:89:9
   89|     if (x.type === C) {}; // error C is not included in 'A'
               ^^^^^^ [1]
   disjoint_union.js:45:9
   45|   const C: 'C' = 'C';
               ^ [2]
   disjoint_union.js:45:12
   45|   const C: 'C' = 'C';
                  ^^^ [3]


Error ------------------------------------------------------------------------------------------- disjoint_union.js:90:9

Cannot compare `x.type` [1] to `D` [2], because `x.type` [1] is not a subtype of string literal `D` [3] and string
literal `D` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:90:9
   90|     if (x.type === D) {}; // error D is not included in 'A'
               ^^^^^^^^^^^^

References:
   disjoint_union.js:90:9
   90|     if (x.type === D) {}; // error D is not included in 'A'
               ^^^^^^ [1]
   disjoint_union.js:46:9
   46|   const D: 'D' = 'D';
               ^ [2]
   disjoint_union.js:46:12
   46|   const D: 'D' = 'D';
                  ^^^ [3]


Error ------------------------------------------------------------------------------------------ disjoint_union.js:100:7

Cannot compare `x.type` [1] to `C` [2], because `x.type` [1] is not a subtype of string literal `C` [3] and string
literal `C` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:100:7
   100|       case C: break; // error C is not included in 'A'|'B'
              ^^^^^^

References:
   disjoint_union.js:97:13
    97|     switch (x.type) {
                    ^^^^^^ [1]
   disjoint_union.js:45:9
    45|   const C: 'C' = 'C';
                ^ [2]
   disjoint_union.js:45:12
    45|   const C: 'C' = 'C';
                   ^^^ [3]


Error ------------------------------------------------------------------------------------------ disjoint_union.js:101:7

Cannot compare `x.type` [1] to `D` [2], because `x.type` [1] is not a subtype of string literal `D` [3] and string
literal `D` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:101:7
   101|       case D: break; // error D is not included in 'A'|'B'
              ^^^^^^

References:
   disjoint_union.js:97:13
    97|     switch (x.type) {
                    ^^^^^^ [1]
   disjoint_union.js:46:9
    46|   const D: 'D' = 'D';
                ^ [2]
   disjoint_union.js:46:12
    46|   const D: 'D' = 'D';
                   ^^^ [3]


Error ------------------------------------------------------------------------------------------ disjoint_union.js:108:9

Cannot compare `x.type` [1] to `C` [2], because `x.type` [1] is not a subtype of string literal `C` [3] and string
literal `C` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:108:9
   108|     if (x.type === C) {}; // error C is not included in 'A'|'B'
                ^^^^^^^^^^^^

References:
   disjoint_union.js:108:9
   108|     if (x.type === C) {}; // error C is not included in 'A'|'B'
                ^^^^^^ [1]
   disjoint_union.js:45:9
    45|   const C: 'C' = 'C';
                ^ [2]
   disjoint_union.js:45:12
    45|   const C: 'C' = 'C';
                   ^^^ [3]


Error ------------------------------------------------------------------------------------------ disjoint_union.js:109:9

Cannot compare `x.type` [1] to `D` [2], because `x.type` [1] is not a subtype of string literal `D` [3] and string
literal `D` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:109:9
   109|     if (x.type === D) {}; // error D is not included in 'A'|'B'
                ^^^^^^^^^^^^

References:
   disjoint_union.js:109:9
   109|     if (x.type === D) {}; // error D is not included in 'A'|'B'
                ^^^^^^ [1]
   disjoint_union.js:46:9
    46|   const D: 'D' = 'D';
                ^ [2]
   disjoint_union.js:46:12
    46|   const D: 'D' = 'D';
                   ^^^ [3]


Error ------------------------------------------------------------------------------------------ disjoint_union.js:126:7

Cannot compare `x.type` [1] to `C` [2], because `x.type` [1] is not a subtype of string literal `C` [3] and string
literal `C` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:126:7
   126|       case C: break; // error C is not included in 'A' | 'B'
              ^^^^^^

References:
   disjoint_union.js:123:13
   123|     switch (x.type) {
                    ^^^^^^ [1]
   disjoint_union.js:116:9
   116|   const C = 'C';
                ^ [2]
   disjoint_union.js:126:12
   126|       case C: break; // error C is not included in 'A' | 'B'
                   ^ [3]


Error ------------------------------------------------------------------------------------------ disjoint_union.js:127:7

Cannot compare `x.type` [1] to `D` [2], because `x.type` [1] is not a subtype of string literal `D` [3] and string
literal `D` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:127:7
   127|       case D: break; // error D is not included in 'A' | 'B'
              ^^^^^^

References:
   disjoint_union.js:123:13
   123|     switch (x.type) {
                    ^^^^^^ [1]
   disjoint_union.js:117:9
   117|   const D = 'D';
                ^ [2]
   disjoint_union.js:127:12
   127|       case D: break; // error D is not included in 'A' | 'B'
                   ^ [3]


Error ------------------------------------------------------------------------------------------ disjoint_union.js:134:9

Cannot compare `x.type` [1] to `C` [2], because `x.type` [1] is not a subtype of string literal `C` [3] and string
literal `C` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:134:9
   134|     if (x.type === C) {}; // error C is not included in 'A' | 'B'
                ^^^^^^^^^^^^

References:
   disjoint_union.js:134:9
   134|     if (x.type === C) {}; // error C is not included in 'A' | 'B'
                ^^^^^^ [1]
   disjoint_union.js:116:9
   116|   const C = 'C';
                ^ [2]
   disjoint_union.js:134:20
   134|     if (x.type === C) {}; // error C is not included in 'A' | 'B'
                           ^ [3]


Error ------------------------------------------------------------------------------------------ disjoint_union.js:135:9

Cannot compare `x.type` [1] to `D` [2], because `x.type` [1] is not a subtype of string literal `D` [3] and string
literal `D` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:135:9
   135|     if (x.type === D) {}; // error D is not included in 'A' | 'B'
                ^^^^^^^^^^^^

References:
   disjoint_union.js:135:9
   135|     if (x.type === D) {}; // error D is not included in 'A' | 'B'
                ^^^^^^ [1]
   disjoint_union.js:117:9
   117|   const D = 'D';
                ^ [2]
   disjoint_union.js:135:20
   135|     if (x.type === D) {}; // error D is not included in 'A' | 'B'
                           ^ [3]


Error ------------------------------------------------------------------------------------------ disjoint_union.js:142:7

Cannot compare `x.type` [1] to `C` [2], because `x.type` [1] is not a subtype of string literal `C` [3] and string
literal `C` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:142:7
   142|       case C: break; // error C is not included in 'A'
              ^^^^^^

References:
   disjoint_union.js:139:13
   139|     switch (x.type) {
                    ^^^^^^ [1]
   disjoint_union.js:116:9
   116|   const C = 'C';
                ^ [2]
   disjoint_union.js:142:12
   142|       case C: break; // error C is not included in 'A'
                   ^ [3]


Error ------------------------------------------------------------------------------------------ disjoint_union.js:143:7

Cannot compare `x.type` [1] to `D` [2], because `x.type` [1] is not a subtype of string literal `D` [3] and string
literal `D` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:143:7
   143|       case D: break; // error D is not included in 'A'
              ^^^^^^

References:
   disjoint_union.js:139:13
   139|     switch (x.type) {
                    ^^^^^^ [1]
   disjoint_union.js:117:9
   117|   const D = 'D';
                ^ [2]
   disjoint_union.js:143:12
   143|       case D: break; // error D is not included in 'A'
                   ^ [3]


Error ------------------------------------------------------------------------------------------ disjoint_union.js:150:9

Cannot compare `x.type` [1] to `C` [2], because `x.type` [1] is not a subtype of string literal `C` [3] and string
literal `C` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:150:9
   150|     if (x.type === C) {}; // error C is not included in 'A'
                ^^^^^^^^^^^^

References:
   disjoint_union.js:150:9
   150|     if (x.type === C) {}; // error C is not included in 'A'
                ^^^^^^ [1]
   disjoint_union.js:116:9
   116|   const C = 'C';
                ^ [2]
   disjoint_union.js:150:20
   150|     if (x.type === C) {}; // error C is not included in 'A'
                           ^ [3]


Error ------------------------------------------------------------------------------------------ disjoint_union.js:151:9

Cannot compare `x.type` [1] to `D` [2], because `x.type` [1] is not a subtype of string literal `D` [3] and string
literal `D` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:151:9
   151|     if (x.type === D) {}; // error D is not included in 'A'
                ^^^^^^^^^^^^

References:
   disjoint_union.js:151:9
   151|     if (x.type === D) {}; // error D is not included in 'A'
                ^^^^^^ [1]
   disjoint_union.js:117:9
   117|   const D = 'D';
                ^ [2]
   disjoint_union.js:151:20
   151|     if (x.type === D) {}; // error D is not included in 'A'
                           ^ [3]


Error ------------------------------------------------------------------------------------------ disjoint_union.js:161:7

Cannot compare `x.type` [1] to `C` [2], because `x.type` [1] is not a subtype of string literal `C` [3] and string
literal `C` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:161:7
   161|       case C: break; // error C is not included in 'A'|'B'
              ^^^^^^

References:
   disjoint_union.js:158:13
   158|     switch (x.type) {
                    ^^^^^^ [1]
   disjoint_union.js:116:9
   116|   const C = 'C';
                ^ [2]
   disjoint_union.js:161:12
   161|       case C: break; // error C is not included in 'A'|'B'
                   ^ [3]


Error ------------------------------------------------------------------------------------------ disjoint_union.js:162:7

Cannot compare `x.type` [1] to `D` [2], because `x.type` [1] is not a subtype of string literal `D` [3] and string
literal `D` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:162:7
   162|       case D: break; // error D is not included in 'A'|'B'
              ^^^^^^

References:
   disjoint_union.js:158:13
   158|     switch (x.type) {
                    ^^^^^^ [1]
   disjoint_union.js:117:9
   117|   const D = 'D';
                ^ [2]
   disjoint_union.js:162:12
   162|       case D: break; // error D is not included in 'A'|'B'
                   ^ [3]


Error ------------------------------------------------------------------------------------------ disjoint_union.js:169:9

Cannot compare `x.type` [1] to `C` [2], because `x.type` [1] is not a subtype of string literal `C` [3] and string
literal `C` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:169:9
   169|     if (x.type === C) {}; // error C is not included in 'A'|'B'
                ^^^^^^^^^^^^

References:
   disjoint_union.js:169:9
   169|     if (x.type === C) {}; // error C is not included in 'A'|'B'
                ^^^^^^ [1]
   disjoint_union.js:116:9
   116|   const C = 'C';
                ^ [2]
   disjoint_union.js:169:20
   169|     if (x.type === C) {}; // error C is not included in 'A'|'B'
                           ^ [3]


Error ------------------------------------------------------------------------------------------ disjoint_union.js:170:9

Cannot compare `x.type` [1] to `D` [2], because `x.type` [1] is not a subtype of string literal `D` [3] and string
literal `D` [3] is not a subtype of `x.type` [1]. In **rare** cases, these types may have overlapping values but lack a
subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   disjoint_union.js:170:9
   170|     if (x.type === D) {}; // error D is not included in 'A'|'B'
                ^^^^^^^^^^^^

References:
   disjoint_union.js:170:9
   170|     if (x.type === D) {}; // error D is not included in 'A'|'B'
                ^^^^^^ [1]
   disjoint_union.js:117:9
   117|   const D = 'D';
                ^ [2]
   disjoint_union.js:170:20
   170|     if (x.type === D) {}; // error D is not included in 'A'|'B'
                           ^ [3]


Error ----------------------------------------------------------------------------------------------------- enum.js:6:14

Cannot compare `binary` [1] to number literal `2` [2], because number literal `1` [3] is not a subtype of number literal
`2` [2] and number literal `2` [2] is not a subtype of number literal `1` [3]. In **rare** cases, these types may have
overlapping values but lack a subtyping relationship. If that happens, you can cast one side to the union of both types
to pass the flow check.  [invalid-compare]

   enum.js:6:14
   6|   } else if (binary === 2) { // oops
                   ^^^^^^^^^^^^

References:
   enum.js:6:14
   6|   } else if (binary === 2) { // oops
                   ^^^^^^ [1]
   enum.js:6:25
   6|   } else if (binary === 2) { // oops
                              ^ [2]
   enum.js:3:34
   3| function stringifyBinary(binary: Binary): string {
                                       ^^^^^^ [3]


Error -------------------------------------------------------------------------------------------------- generics.js:3:7

Cannot compare `mm.type` [1] to string literal `q` [2], because `T` [3] is not a subtype of string literal `q` [2] and
string literal `q` [2] is not a subtype of `T` [3]. In **rare** cases, these types may have overlapping values but lack
a subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow check. 
[invalid-compare]

   generics.js:3:7
   3|   if (mm.type === 'q'); // Error 'q' is not included in 's' | 'p'
            ^^^^^^^^^^^^^^^

References:
   generics.js:3:7
   3|   if (mm.type === 'q'); // Error 'q' is not included in 's' | 'p'
            ^^^^^^^ [1]
   generics.js:3:19
   3|   if (mm.type === 'q'); // Error 'q' is not included in 's' | 'p'
                        ^^^ [2]
   generics.js:1:39
   1| function f1<T: 's' | 'p'>(mm: { type: T }) {
                                            ^ [3]


Error ------------------------------------------------------------------------------------------------- generics.js:12:7

Cannot compare `mm.type` [1] to string literal `q` [2], because `mm.type` [1] is not a subtype of string literal `q` [2]
and string literal `q` [2] is not a subtype of `mm.type` [1]. In **rare** cases, these types may have overlapping values
but lack a subtyping relationship. If that happens, you can cast one side to the union of both types to pass the flow
check.  [invalid-compare]

   generics.js:12:7
   12|   if (mm.type === 'q'); // Error 'q' is not included in 's' | 'p'
             ^^^^^^^^^^^^^^^

References:
   generics.js:12:7
   12|   if (mm.type === 'q'); // Error 'q' is not included in 's' | 'p'
             ^^^^^^^ [1]
   generics.js:12:19
   12|   if (mm.type === 'q'); // Error 'q' is not included in 's' | 'p'
                         ^^^ [2]



Found 32 errors
