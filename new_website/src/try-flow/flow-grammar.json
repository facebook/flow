{
  "@generated": "copied from fbsource/vscode/vscode-extensions/flow/syntaxes",
  "name": "flow",
  "scopeName": "source.js",
  "foldingStartMarker": "(/\\*|{|\\()",
  "foldingEndMarker": "(\\*/|\\}|\\))",
  "firstLineMatch": "^#!\\s*/.*\\b(node|js)$\\n?",
  "limitLineLength": false,
  "fileTypes": ["js", "es6", "es", "babel", "jsx", "flow", "mjs"],
  "patterns": [
    {
      "include": "#core"
    }
  ],
  "repository": {
    "core": {
      "patterns": [
        {
          "include": "#ignore-long-lines"
        },
        {
          "include": "#flowtype-keywords"
        },
        {
          "include": "#literal-labels"
        },
        {
          "include": "#literal-for"
        },
        {
          "include": "#literal-switch"
        },
        {
          "include": "#enum-declaration"
        },
        {
          "include": "#expression"
        },
        {
          "include": "#literal-keywords"
        }
      ]
    },
    "expression": {
      "patterns": [
        {
          "include": "#ignore-long-lines"
        },
        {
          "include": "#multiline-arrow-function-generics"
        },
        {
          "include": "#jsx"
        },
        {
          "include": "#es7-decorators"
        },
        {
          "include": "#literal-js-label"
        },
        {
          "include": "#support"
        },
        {
          "include": "#literal-function"
        },
        {
          "include": "#literal-arrow-function"
        },
        {
          "include": "#literal-prototype",
          "comment": "after literal-function, which includes some prototype strings"
        },
        {
          "include": "#literal-regexp",
          "comment": "before operators to avoid abiguities"
        },
        {
          "include": "#literal-number"
        },
        {
          "include": "#literal-quasi"
        },
        {
          "include": "#literal-string"
        },
        {
          "include": "#literal-language-constant"
        },
        {
          "include": "#literal-language-variable"
        },
        {
          "include": "#literal-object",
          "comment": "before literal-module as it traps default {"
        },
        {
          "include": "#literal-module"
        },
        {
          "include": "#literal-class"
        },
        {
          "include": "#literal-method-call"
        },
        {
          "include": "#literal-function-call"
        },
        {
          "include": "#comments"
        },
        {
          "include": "#brackets"
        },
        {
          "include": "#flowtype-trap"
        },
        {
          "include": "#literal-operators"
        },
        {
          "include": "#literal-variable-flowtype"
        },
        {
          "include": "#literal-variable"
        },
        {
          "include": "#literal-punctuation"
        },
        {
          "include": "#fat-arrow"
        }
      ]
    },
    "ignore-long-lines": {
      "comment": "so set at arbitary 1000 chars to avoid parsing minified files",
      "patterns": [
        {
          "match": "^.{1000,}"
        }
      ]
    },
    "multiline-arrow-function-generics": {
      "patterns": [
        {
          "comment": "e.g. export default async <T>(",
          "name": "meta.function.arrow.js",
          "begin": "\\s*+(?:(\\basync)\\s+)(?=(<(?:(?>(?<==)>|[^<>]+)|\\g<-1>)*>)?+\\s*+\\(\\s*$)",
          "end": "((?<=})|(?:\\s*(=>)(?!\\s*{)))",
          "beginCaptures": {
            "1": {
              "name": "storage.type.js"
            }
          },
          "endCaptures": {
            "2": {
              "name": "storage.type.function.arrow.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype"
            },
            {
              "include": "#fat-arrow-braced-body"
            }
          ]
        },
        {
          "comment": "e.g. export default <T>(",
          "name": "meta.function.arrow.js",
          "begin": "\\s*+(?=(<(?:(?>(?<==)>|[^<>]+)|\\g<-1>)*+>)\\()",
          "end": "((?<=})|(?:\\s*(=>)(?!\\s*{)))",
          "endCaptures": {
            "2": {
              "name": "storage.type.function.arrow.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype"
            },
            {
              "include": "#fat-arrow-braced-body"
            }
          ]
        }
      ]
    },
    "literal-function-labels": {
      "patterns": [
        {
          "comment": "e.g. play: function(arg1, arg2) { }",
          "name": "meta.function.json.js",
          "begin": "(?<=^|{|,)\\s*+((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(:)\\s*+(?:(async)\\s+)?\\s*+((?<!\\.)\\bfunction\\b)\\s*+(?:(\\*)\\s*)?(?=\\s*(\\(|<))",
          "end": "(?<=})",
          "beginCaptures": {
            "1": {
              "name": "entity.name.function.js"
            },
            "2": {
              "name": "punctuation.separator.key-value.js"
            },
            "3": {
              "name": "storage.type.js"
            },
            "4": {
              "name": "storage.type.function.js"
            },
            "5": {
              "name": "keyword.generator.asterisk.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype"
            },
            {
              "include": "#curly-brackets"
            }
          ]
        },
        {
          "comment": "e.g. 'play': function(arg1, arg2) { }",
          "name": "meta.function.json.js",
          "begin": "(?<=^|{|,)\\s*+(('|\")([^\"']*)(\\k<-3>))\\s*+(:)\\s*+(async)?\\s*+((?<!\\.)\\bfunction\\b)\\s*(\\*\\s*)?(?=\\s*(\\(|<))",
          "end": "(?<=})",
          "beginCaptures": {
            "1": {
              "name": "string.quoted.js"
            },
            "2": {
              "name": "punctuation.definition.string.begin.js"
            },
            "3": {
              "name": "entity.name.function.js"
            },
            "4": {
              "name": "punctuation.definition.string.end.js"
            },
            "5": {
              "name": "punctuation.separator.key-value.js"
            },
            "6": {
              "name": "storage.type.js"
            },
            "7": {
              "name": "storage.type.function.js"
            },
            "8": {
              "name": "keyword.generator.asterisk.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype"
            },
            {
              "include": "#curly-brackets"
            }
          ]
        }
      ]
    },
    "literal-arrow-function-labels": {
      "patterns": [
        {
          "include": "#literal-async-arrow-function-labels"
        },
        {
          "comment": "e.g. play: async <T>(args) => { }",
          "name": "meta.function.json.arrow.js",
          "begin": "(?<=^|{|,)\\s*+((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(:)\\s*+(\\basync\\b)?\\s*+(?=(<(?:(?>(?<==)>|[^<>]+)|\\g<-1>)*>)?\\s*+(\\((?>[^()\"']|(\"(\\\\.|[^\"])*+\")++|('(\\\\.|[^'])*+')++|\\g<-5>)*+\\))\\s*+(((?::(?:(\\s*+(&|\\|)?(\\s*%checks\\b|\\s*(\\((?>[^()\"']|(\"(\\\\.|[^\"])*+\")++|('(\\\\.|[^'])*+')++|\\g<-5>)*+\\))+|\\s*+((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)|(<(?:(?>(?<==)>|[^<>]+)|\\g<-1>)*>)+|\\s*+({(?:(?>[^{}]+)|\\g<-1>)*\\})|\\s*+(\\[(?:(?>[^\\[\\]]+)|\\g<-1>)*\\])|\\s*+(\\s*([\"']).*?\\k<-1>(?<!\\\\.))|\\s*[+-x]?[0-9A-Fa-f]+))|(?:\\s*+/\\*.*?\\*/))*+)*)|(?:/\\*.*?\\*/))\\s*=>)",
          "end": "((?<=})|(?:\\s*(=>)(?!\\s*{)))",
          "beginCaptures": {
            "1": {
              "name": "entity.name.function.js"
            },
            "2": {
              "name": "punctuation.separator.key-value.js"
            },
            "3": {
              "name": "storage.type.js"
            }
          },
          "endCaptures": {
            "2": {
              "name": "storage.type.function.arrow.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype"
            },
            {
              "include": "#fat-arrow-braced-body"
            }
          ]
        },
        {
          "comment": "e.g. play: arg => { }",
          "name": "meta.function.json.arrow.js",
          "match": "(?<=^|{|,)\\s*+((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(:)\\s*+(\\basync\\b)?\\s*+(((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+))\\s*(=>)",
          "captures": {
            "1": {
              "name": "entity.name.function.js"
            },
            "2": {
              "name": "keyword.operator.assignment.js"
            },
            "3": {
              "name": "storage.type.js"
            },
            "4": {
              "name": "meta.function.parameters.js"
            },
            "5": {
              "name": "variable.other.readwrite.js"
            },
            "6": {
              "name": "storage.type.function.arrow.js"
            }
          }
        },
        {
          "comment": "e.g. 'play': (args) => { }",
          "name": "meta.function.json.arrow.js",
          "begin": "(?<=^|{|,)\\s*+(('|\")([^\"']*)(\\k<-3>))\\s*(:)\\s*+(\\basync\\b)?\\s*+(?=(<(?:(?>(?<==)>|[^<>]+)|\\g<-1>)*>)?\\s*+(\\((?>[^()\"']|(\"(\\\\.|[^\"])*+\")++|('(\\\\.|[^'])*+')++|\\g<-5>)*+\\))\\s*+(((?::(?:(\\s*+(&|\\|)?(\\s*%checks\\b|\\s*(\\((?>[^()\"']|(\"(\\\\.|[^\"])*+\")++|('(\\\\.|[^'])*+')++|\\g<-5>)*+\\))+|\\s*+((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)|(<(?:(?>(?<==)>|[^<>]+)|\\g<-1>)*>)+|\\s*+({(?:(?>[^{}]+)|\\g<-1>)*\\})|\\s*+(\\[(?:(?>[^\\[\\]]+)|\\g<-1>)*\\])|\\s*+(\\s*([\"']).*?\\k<-1>(?<!\\\\.))|\\s*[+-x]?[0-9A-Fa-f]+))|(?:\\s*+/\\*.*?\\*/))*+)*)|(?:/\\*.*?\\*/))\\s*=>)",
          "end": "((?<=})|(?:\\s*(=>)(?!\\s*{)))",
          "beginCaptures": {
            "1": {
              "name": "string.quoted.js"
            },
            "2": {
              "name": "punctuation.definition.string.begin.js"
            },
            "3": {
              "name": "entity.name.function.js"
            },
            "4": {
              "name": "punctuation.definition.string.end.js"
            },
            "5": {
              "name": "punctuation.separator.key-value.js"
            },
            "6": {
              "name": "storage.type.js"
            }
          },
          "endCaptures": {
            "2": {
              "name": "storage.type.function.arrow.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype"
            },
            {
              "include": "#fat-arrow-braced-body"
            }
          ]
        },
        {
          "comment": "e.g. 'play': arg => { }",
          "name": "meta.function.json.arrow.js",
          "match": "(?<=^|{|,)\\s*+(('|\")([^\"']*)(\\k<-3>))\\s*+(:)\\s*+(\\basync\\b)?\\s*+(((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+))\\s*(=>)",
          "captures": {
            "1": {
              "name": "string.quoted.js"
            },
            "2": {
              "name": "punctuation.definition.string.begin.js"
            },
            "3": {
              "name": "entity.name.function.js"
            },
            "4": {
              "name": "punctuation.definition.string.end.js"
            },
            "5": {
              "name": "keyword.operator.assignment.js"
            },
            "6": {
              "name": "storage.type.js"
            },
            "7": {
              "name": "meta.function.parameters.js"
            },
            "8": {
              "name": "variable.other.readwrite.js"
            },
            "9": {
              "name": "storage.type.function.arrow.js"
            }
          }
        }
      ]
    },
    "literal-async-arrow-function-labels": {
      "patterns": [
        {
          "comment": "e.g. play: async <T>(",
          "name": "meta.function.json.arrow.js",
          "begin": "(?<=^|{|,)\\s*+((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(:)\\s*+(?:(\\basync)\\s+)(?=(<(?:(?>(?<==)>|[^<>]+)|\\g<-1>)*>)?\\s*+\\()",
          "end": "((?<=})|(?:\\s*(=>)(?!\\s*{)))",
          "beginCaptures": {
            "1": {
              "name": "entity.name.function.js"
            },
            "2": {
              "name": "punctuation.separator.key-value.js"
            },
            "3": {
              "name": "storage.type.js"
            }
          },
          "endCaptures": {
            "2": {
              "name": "storage.type.function.arrow.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype"
            },
            {
              "include": "#fat-arrow-braced-body"
            }
          ]
        },
        {
          "comment": "e.g. 'play': async <T>(",
          "name": "meta.function.json.arrow.js",
          "begin": "(?<=^|{|,)\\s*+(('|\")([^\"']*)(\\k<-3>))\\s*(:)\\s*+(?:(\\basync)\\s+)(?=(<(?:(?>(?<==)>|[^<>]+)|\\g<-1>)*>)?\\s*+\\()",
          "end": "((?<=})|(?:\\s*(=>)(?!\\s*{)))",
          "beginCaptures": {
            "1": {
              "name": "string.quoted.js"
            },
            "2": {
              "name": "punctuation.definition.string.begin.js"
            },
            "3": {
              "name": "entity.name.function.js"
            },
            "4": {
              "name": "punctuation.definition.string.end.js"
            },
            "5": {
              "name": "punctuation.separator.key-value.js"
            },
            "6": {
              "name": "storage.type.js"
            }
          },
          "endCaptures": {
            "2": {
              "name": "storage.type.function.arrow.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype"
            },
            {
              "include": "#fat-arrow-braced-body"
            }
          ]
        }
      ]
    },
    "literal-labels": {
      "patterns": [
        {
          "comment": "string as a property name",
          "match": "(?<!\\.|\\?)\\s*+(((\")(\\\\.|[^\\\\\"])*(\"))|((')(\\\\.|[^\\\\'])*(')))\\s*+(:)((?=::)|(?!:))",
          "captures": {
            "1": {
              "name": "constant.other.object.key.js"
            },
            "2": {
              "name": "string.quoted.double.js"
            },
            "3": {
              "name": "punctuation.definition.string.begin.js"
            },
            "5": {
              "name": "punctuation.definition.string.end.js"
            },
            "6": {
              "name": "string.quoted.single.js"
            },
            "7": {
              "name": "punctuation.definition.string.begin.js"
            },
            "9": {
              "name": "punctuation.definition.string.end.js"
            },
            "10": {
              "name": "punctuation.separator.key-value.js"
            }
          }
        },
        {
          "comment": "[some expression] : as  property name",
          "begin": "(?<!\\.|\\?)\\s*+(?=(\\[(?:(?>[^\\[\\]]+)|\\g<-1>)*\\])\\s*+:\\s*+[\\S&&[^:]])",
          "end": "\\s*(:)((?=::)|(?!:))",
          "endCaptures": {
            "1": {
              "name": "punctuation.separator.key-value.js"
            }
          },
          "patterns": [
            {
              "include": "#expression"
            }
          ]
        },
        {
          "include": "#literal-js-label"
        },
        {
          "match": "(?<!\\.|\\?)\\s*+(((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+))\\s*+(:)((?=::)|(?!:))",
          "captures": {
            "1": {
              "name": "constant.other.object.key.js"
            },
            "2": {
              "name": "string.unquoted.js"
            },
            "3": {
              "name": "punctuation.separator.key-value.js"
            }
          }
        }
      ]
    },
    "literal-keywords": {
      "patterns": [
        {
          "include": "#literal-keyword-storage"
        },
        {
          "match": "(?<!\\.)\\s*+\\b(yield)\\b(?:\\s*+(\\*))?",
          "captures": {
            "1": {
              "name": "keyword.control.flow.js"
            },
            "2": {
              "name": "keyword.generator.asterisk.js"
            }
          }
        },
        {
          "match": "(?:(?<!\\.)|(?<=\\.\\.\\.))\\s*+\\b(await|return)\\b",
          "captures": {
            "1": {
              "name": "keyword.control.flow.js"
            }
          }
        },
        {
          "match": "(?<!\\.)\\s*+\\b(if|else)\\b",
          "captures": {
            "1": {
              "name": "keyword.control.conditional.js"
            }
          }
        },
        {
          "match": "(?<!\\.)\\s*+\\b(catch|finally|throw|try)\\b",
          "captures": {
            "1": {
              "name": "keyword.control.trycatch.js"
            }
          }
        },
        {
          "match": "(?<!\\.)\\s*+\\b(do|goto|while)\\b",
          "captures": {
            "1": {
              "name": "keyword.control.loop.js"
            }
          }
        },
        {
          "begin": "(?<!\\.)\\s*+\\b(break|continue)\\b",
          "end": "^\\s*|\\s*(?=;|//|$|\\b(if|switch|case|break|default|try|var|let|const|static|function|return|class|do|for|while|debugger|export|import|yield|type|declare|interface|enum)\\b)",
          "beginCaptures": {
            "1": {
              "name": "keyword.control.loop.js"
            }
          },
          "patterns": [
            {
              "include": "#comments"
            },
            {
              "match": "\\s*([$_[:alpha:]][$_[:alnum:]]*)\\s*(?=$|;|//|/\\*)",
              "captures": {
                "1": {
                  "name": "constant.other.label.js"
                }
              }
            }
          ]
        }
      ]
    },
    "literal-for": {
      "patterns": [
        {
          "name": "meta.for.js",
          "begin": "(?<!\\.)\\s*+\\b(for)\\b\\s*(await)?\\b",
          "end": "\\s*(\\))",
          "endCaptures": {
            "1": {
              "name": "meta.brace.round.js"
            }
          },
          "beginCaptures": {
            "1": {
              "name": "keyword.control.loop.js"
            },
            "2": {
              "name": "keyword.control.flow.js"
            }
          },
          "patterns": [
            {
              "begin": "\\s*+(\\()",
              "end": "\\s*(?=\\))",
              "beginCaptures": {
                "1": {
                  "name": "meta.brace.round.js"
                }
              },
              "patterns": [
                {
                  "include": "#literal-keyword-storage"
                },
                {
                  "include": "#expression"
                },
                {
                  "include": "#literal-punctuation"
                }
              ]
            }
          ]
        }
      ]
    },
    "literal-switch": {
      "patterns": [
        {
          "name": "meta.switch.js",
          "begin": "(?<!\\.)\\s*+\\b(switch)\\b",
          "end": "\\s*(\\})",
          "beginCaptures": {
            "1": {
              "name": "keyword.control.switch.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "meta.brace.curly.switchEnd.js"
            }
          },
          "patterns": [
            {
              "include": "#round-brackets"
            },
            {
              "begin": "\\s*+({)",
              "end": "\\s*(?=})",
              "beginCaptures": {
                "1": {
                  "name": "meta.brace.curly.switchStart.js"
                }
              },
              "patterns": [
                {
                  "begin": "(?<!\\.)\\s*+\\b(case|default)\\b",
                  "end": "\\s*(:)((?=::)|(?!:))",
                  "beginCaptures": {
                    "1": {
                      "name": "keyword.control.switch.js"
                    }
                  },
                  "endCaptures": {
                    "1": {
                      "name": "keyword.operator.js"
                    }
                  },
                  "patterns": [
                    {
                      "include": "#expression"
                    }
                  ]
                },
                {
                  "include": "$self"
                }
              ]
            }
          ]
        }
      ]
    },
    "brackets": {
      "patterns": [
        {
          "include": "#round-brackets"
        },
        {
          "include": "#square-brackets"
        },
        {
          "include": "#curly-brackets"
        }
      ]
    },
    "round-brackets": {
      "patterns": [
        {
          "begin": "\\s*+(\\()",
          "end": "\\s*(\\))",
          "endCaptures": {
            "1": {
              "name": "meta.brace.round.js"
            }
          },
          "beginCaptures": {
            "1": {
              "name": "meta.brace.round.js"
            }
          },
          "patterns": [
            {
              "include": "#expression"
            }
          ]
        }
      ]
    },
    "type-argument-brackets": {
      "patterns": [
        {
          "comment": "Type arguments. This is complicated since we don't want to match things like foo < 123 || bar > baz",
          "name": "meta.type-arguments.flowtype",
          "begin": "\\s*+(<)(?=((?:(?>[^<>]+)|<\\g<-1>>)*)>)",
          "end": "\\s*(>)",
          "endCaptures": {
            "1": { "name": "punctuation.flowtype" }
          },
          "beginCaptures": {
            "1": { "name": "punctuation.flowtype" }
          },
          "patterns": [
            {
              "include": "#flowtype-parse-types"
            },
            {
              "include": "#literal-comma"
            }
          ]
        }
      ]
    },
    "square-brackets": {
      "patterns": [
        {
          "begin": "\\s*+(\\[)",
          "end": "\\s*(\\])",
          "endCaptures": {
            "1": {
              "name": "meta.brace.square.js"
            }
          },
          "beginCaptures": {
            "1": {
              "name": "meta.brace.square.js"
            }
          },
          "patterns": [
            {
              "include": "#literal-object-brace"
            },
            {
              "include": "#expression"
            }
          ]
        }
      ]
    },
    "curly-brackets": {
      "patterns": [
        {
          "begin": "\\s*+({)",
          "end": "\\s*(\\})",
          "endCaptures": {
            "1": {
              "name": "meta.brace.curly.js"
            }
          },
          "beginCaptures": {
            "1": {
              "name": "meta.brace.curly.js"
            }
          },
          "patterns": [
            {
              "include": "$self"
            }
          ]
        }
      ]
    },
    "jsdoc": {
      "patterns": [
        {
          "include": "#jsdoc-inline-tags"
        },
        {
          "include": "#jsdoc-access"
        },
        {
          "include": "#jsdoc-as-namepath"
        },
        {
          "include": "#jsdoc-simple"
        },
        {
          "include": "#jsdoc-simple-namepath"
        },
        {
          "include": "#jsdoc-module"
        },
        {
          "include": "#jsdoc-type-name"
        },
        {
          "include": "#jsdoc-type-noname"
        },
        {
          "comment": "additional jsdoc V2 keywords",
          "match": "(?<!\\w)@(add|api|body|codeend|codestart|demo|download|group|hide|iframe|image|inherits|option|outline|page|parent|signature|tag)\\b",
          "name": "storage.type.class.jsduck"
        },
        {
          "comment": "additional jsduck keywords",
          "match": "(?<!\\w)@(accessor|alternateClassName|aside|cfg|chainable|docauthor|evented|experimental|ftype|hide|inheritable|localdoc|markdown|mixins|new|override|preventable|ptype|removed|scss mixin|singleton|template|uses|xtype)\\b",
          "name": "storage.type.class.jsduck"
        }
      ]
    },
    "jsdoc-access": {
      "comment": "@tag protected....",
      "match": "(?:^[\\s*]*|(?<=/\\*\\*)\\s*)(@(access))\\s*(private|protected|public)?(?=\\s|$)",
      "captures": {
        "1": {
          "name": "storage.type.class.jsdoc"
        },
        "3": {
          "name": "storage.modifier.jsdoc"
        }
      }
    },
    "jsdoc-module": {
      "comment": "@tag {optional type} module:file",
      "begin": "(?:^[\\s*]*|(?<=/\\*\\*)\\s*)(@(exports|module|listens|requires)\\b)\\s*(?=({(?:(?>[^{}]+)|\\g<-1>)*\\})?\\s*(\\S*)([\\S\\s]*))",
      "end": "^|(?=\\*/)|(?=\\5$)",
      "beginCaptures": {
        "1": {
          "name": "storage.type.class.jsdoc"
        }
      },
      "patterns": [
        {
          "include": "#jsdoc-typedef-scopes"
        },
        {
          "match": "(?:(module)(:))?(((?!\\*/)\\S)+)",
          "captures": {
            "1": {
              "name": "keyword.module.jsdoc"
            },
            "2": {
              "name": "punctuation.jsdoc"
            },
            "3": {
              "name": "string.modulename.jsdoc"
            }
          }
        }
      ]
    },
    "jsdoc-as-namepath": {
      "comment": "to terminate the block",
      "begin": "(?:^[\\s*]*|(?<=/\\*\\*)\\s*)(@(borrows|lends)\\b)\\s*(?=(?!\\*/)\\S+(?:(?:\\s*\\bas\\b\\s*(?!\\*/)\\S+)?)?([\\S\\s]*))",
      "end": "^|(?=\\*/)|(?=\\3$)",
      "beginCaptures": {
        "1": {
          "name": "storage.type.class.jsdoc"
        }
      },
      "patterns": [
        {
          "include": "#jsdoc-namepath-scopes"
        }
      ]
    },
    "jsdoc-simple": {
      "comment": "@tag",
      "match": "(?:^[\\s*]*|(?<=/\\*\\*)\\s*)(@(abstract|author|classdesc|copyright|default|defaultvalue|deprecated|description|desc|example|external|fileoverview|file|global|host|ignore|inheritdoc|inner|instance|license|override|overview|readonly|see|since|static|summary|todo|tutorial|virtual|variation|version)\\b)(?=$|\\s)",
      "captures": {
        "1": {
          "name": "storage.type.class.jsdoc"
        }
      }
    },
    "jsdoc-simple-namepath": {
      "comment": "@tag {opt type} Class#xxx or Class#Event:aaaa etc",
      "begin": "(?:^[\\s*]*|(?<=/\\*\\*)\\s*)(@(alias|augments|callback|extends|emits|event|fires|interface|memberof|mixes|name|property|prop|this|typedef)\\b)\\s*(?=({(?:(?>[^{}]+)|\\g<-1>)*\\})?\\s*\\S*([\\S*\\s]*))",
      "end": "^|(?=\\*/)|(?=\\4$)",
      "beginCaptures": {
        "1": {
          "name": "storage.type.class.jsdoc"
        }
      },
      "patterns": [
        {
          "include": "#jsdoc-typedef-scopes"
        },
        {
          "include": "#jsdoc-namepath-scopes"
        }
      ]
    },
    "jsdoc-type-name": {
      "comment": "@tag {optional type} name",
      "begin": "(?:^[\\s*]*|(?<=/\\*\\*)\\s*)(@(arg|argument|class|constant|constructor|constructs|const|function|func|kind|member|method|mixin|namespace|param|var)\\b)\\s*(?=({(?:(?>[^{}]+)|\\g<-1>)*\\})?\\s*(((\\[(?:(?>[^\\[\\]]+)|\\g<-1>)*\\])|\\S)+)?([\\S\\s]*))",
      "end": "^|(?=\\*/)|(?=\\7$)",
      "beginCaptures": {
        "1": {
          "name": "storage.type.class.jsdoc"
        }
      },
      "patterns": [
        {
          "include": "#jsdoc-typedef-scopes"
        },
        {
          "include": "#jsdoc-name-scopes"
        }
      ]
    },
    "jsdoc-type-noname": {
      "comment": "@tag {types}",
      "begin": "(?:^[\\s*]*|(?<=/\\*\\*)\\s*)(@(enum|exception|implements|private|protected|public|returns|return|throws|type)\\b)\\s*(?=({(?:(?>[^{}]+)|\\g<-1>)*\\})?\\s*([\\S\\s]*))",
      "end": "^|(?=\\*/)|(?=\\4$)",
      "beginCaptures": {
        "1": {
          "name": "storage.type.class.jsdoc"
        }
      },
      "patterns": [
        {
          "include": "#jsdoc-typedef-scopes"
        }
      ]
    },
    "jsdoc-inline-tags": {
      "name": "meta.tag.inline.jsdoc",
      "begin": "(\\[(?:(?>[^\\[\\]]+)|\\g<-1>)*\\])?({)(?=@)",
      "end": "(})",
      "beginCaptures": {
        "1": {
          "name": "string.linktext.jsdoc"
        },
        "2": {
          "name": "meta.brace.curly.jsdoc"
        }
      },
      "endCaptures": {
        "1": {
          "name": "meta.brace.curly.jsdoc"
        }
      },
      "patterns": [
        {
          "match": "(@(link|tutorial))\\b([^}]*)",
          "captures": {
            "1": {
              "name": "storage.type.class.jsdoc"
            },
            "3": {
              "name": "string.jsdoc"
            }
          }
        }
      ]
    },
    "jsdoc-typedef-scopes": {
      "name": "entity.name.type.instance.jsdoc",
      "begin": "{",
      "end": "}|^",
      "captures": {
        "0": {
          "name": "meta.brace.curly.jsdoc"
        }
      },
      "patterns": [
        {
          "include": "#jsdoc-typedef-primitives"
        },
        {
          "include": "#jsdoc-namepath-scopes"
        },
        {
          "include": "#jsdoc-typedef-obj"
        }
      ]
    },
    "jsdoc-typedef-primitives": {
      "match": "\\b(null|undefined|boolean|string|number)\\b",
      "captures": {
        "1": {
          "name": "support.type.builtin.primitive.jsdoc"
        }
      }
    },
    "jsdoc-typedef-obj": {
      "comment": "typedef object",
      "begin": "{",
      "end": "}|^",
      "captures": {
        "0": {
          "name": "meta.brace.curly.jsdoc"
        }
      },
      "patterns": [
        {
          "include": "#jsdoc-typedef-primitives"
        },
        {
          "match": "\\b([$_A-Za-z][$_A-Za-z0-9]*)\\s*(:)",
          "captures": {
            "1": {
              "name": "variable.other.readwrite.jsdoc"
            }
          }
        },
        {
          "include": "#jsdoc-namepath-scopes"
        },
        {
          "include": "#jsdoc-typedef-obj"
        }
      ]
    },
    "jsdoc-name-scopes": {
      "patterns": [
        {
          "match": "((?!\\*/)[\\S&&[^\\[\\]\"']])+",
          "captures": {
            "0": {
              "name": "variable.other.jsdoc"
            }
          }
        },
        {
          "name": "variable.other.jsdoc",
          "begin": "\\[",
          "end": "\\]|^",
          "patterns": [
            {
              "include": "#jsdoc-string"
            },
            {
              "include": "#jsdoc-name-scopes"
            }
          ]
        }
      ]
    },
    "jsdoc-namepath-scopes": {
      "patterns": [
        {
          "match": "\\s*\\b(as)\\b\\s*(?=[$_A-Za-z])",
          "captures": {
            "1": {
              "name": "keyword.as.jsdoc"
            }
          }
        },
        {
          "match": "\\s*(?:([A-Z][$_A-Za-z0-9]*)|([$_A-Za-z][$_A-Za-z0-9]*))(?=[\\s\\-~.#]|$)",
          "captures": {
            "1": {
              "name": "entity.name.class.jsdoc"
            },
            "2": {
              "name": "entity.name.function.jsdoc"
            }
          }
        },
        {
          "match": "(\\.)([$_A-Za-z][$_A-Za-z0-9]*)(?=\\s|$|\\\")",
          "captures": {
            "1": {
              "name": "keyword.operator.accessor.jsdoc"
            },
            "2": {
              "name": "entity.name.function.method.static.jsdoc"
            }
          }
        },
        {
          "match": "(\\#)([$_A-Za-z][$_A-Za-z0-9]*)(?=\\s|$|\\\")",
          "captures": {
            "1": {
              "name": "keyword.operator.accessor.jsdoc"
            },
            "2": {
              "name": "entity.name.function.method.instance.jsdoc"
            }
          }
        },
        {
          "match": "(~|-)([$_A-Za-z][$_A-Za-z0-9]*)(?=\\s|$|\\\")",
          "captures": {
            "1": {
              "name": "keyword.operator.accessor.jsdoc"
            },
            "2": {
              "name": "entity.name.function.method.inner.jsdoc"
            }
          }
        },
        {
          "match": "(\\#)(event)(:)",
          "captures": {
            "1": {
              "name": "keyword.operator.accessor.jsdoc"
            },
            "2": {
              "name": "keyword.event.jsdoc"
            },
            "3": {
              "name": "keyword.operator.jsdoc"
            }
          }
        },
        {
          "name": "string.method.jsdoc",
          "begin": "\\.(?=\"|')",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "patterns": [
            {
              "include": "#jsdoc-string"
            }
          ]
        }
      ]
    },
    "jsdoc-string": {
      "name": "string.jsdoc",
      "match": "\"(\\\\\"|[^\"])*\"|'(\\\\'|[^'])*'"
    },
    "comments": {
      "patterns": [
        {
          "include": "#flowtype-comments"
        },
        {
          "include": "#special-comments-conditional-compilation"
        },
        {
          "contentName": "comment.block.documentation.js",
          "begin": "\\s*+((/\\*\\*))(?!/|\\*)",
          "end": "(\\s*(\\*/))",
          "captures": {
            "1": {
              "name": "comment.block.documentation.js"
            },
            "2": {
              "name": "punctuation.definition.comment.js"
            }
          },
          "patterns": [
            {
              "include": "#jsdoc"
            }
          ]
        },
        {
          "contentName": "comment.block.js",
          "begin": "\\s*+((/\\*))",
          "end": "(\\s*(\\*/))",
          "captures": {
            "1": {
              "name": "comment.block.js"
            },
            "2": {
              "name": "punctuation.definition.comment.js"
            }
          }
        },
        {
          "match": "\\s*+((<!--|-->))",
          "captures": {
            "1": {
              "name": "comment.block.html.js"
            },
            "2": {
              "name": "punctuation.definition.comment.js"
            }
          }
        },
        {
          "comment": "leading whitespace on a new line comment is scoped so Atom reflow works",
          "contentName": "comment.line.double-slash.js",
          "begin": "((^\\s*)|\\s*)((//))",
          "end": "\\s*$",
          "beginCaptures": {
            "2": {
              "name": "punctuation.whitespace.comment.leading.js"
            },
            "3": {
              "name": "comment.line.double-slash.js"
            },
            "4": {
              "name": "punctuation.definition.comment.js"
            }
          },
          "endCaptures": {
            "0": {
              "name": "comment.line.double-slash.js"
            }
          }
        },
        {
          "name": "comment.line.shebang.js",
          "match": "^(\\#!).*$\\n?",
          "captures": {
            "1": {
              "name": "punctuation.definition.comment.js"
            }
          }
        }
      ]
    },
    "special-comments-conditional-compilation": {
      "patterns": [
        {
          "contentName": "comment.block.conditional.js",
          "begin": "\\s*+((/\\*))(?=@)",
          "end": "\\s*\\*/",
          "captures": {
            "1": {
              "name": "comment.block.conditional.js"
            },
            "2": {
              "name": "punctuation.definition.comment.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "keyword.control.conditional.js"
            },
            "2": {
              "name": "punctuation.definition.keyword.js"
            }
          },
          "patterns": [
            {
              "name": "punctuation.definition.comment.js",
              "match": "\\s*+/\\*"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "name": "keyword.control.conditional.js",
          "match": "\\s*+(?!@)(@)(if|elif|else|end|ifdef|endif|cc_on|set)\\b",
          "captures": {
            "1": {
              "name": "punctuation.definition.keyword.js"
            }
          }
        },
        {
          "name": "variable.other.conditional.js",
          "match": "\\s*+(?!@)(@)(_win32|_win16|_mac|_alpha|_x86|_mc680x0|_PowerPC|_jscript|_jscript_build|_jscript_version|_debug|_fast|[a-zA-Z]\\w+)",
          "captures": {
            "1": {
              "name": "punctuation.definition.variable.js"
            }
          }
        }
      ]
    },
    "literal-punctuation": {
      "patterns": [
        {
          "include": "#literal-semi-colon"
        },
        {
          "include": "#literal-comma"
        }
      ]
    },
    "literal-semi-colon": {
      "patterns": [
        {
          "match": "\\s*+(;)",
          "captures": {
            "1": {
              "name": "punctuation.terminator.statement.js"
            }
          }
        }
      ]
    },
    "literal-comma": {
      "patterns": [
        {
          "match": "\\s*+(,)",
          "captures": {
            "1": {
              "name": "meta.delimiter.comma.js"
            }
          }
        }
      ]
    },
    "literal-keyword-storage": {
      "patterns": [
        {
          "begin": "(?<!\\.)\\s*+\\b(const|let|var)\\b",
          "end": "(?=^\\s*[$_[:alpha:]][$_[:alnum:]]*:\\s*($|\\b(do|for|while)\\b))|\\s*(?=;|\\*/|\\b(if|switch|case|break|default|try|var|let|const|static|function|return|class|do|for|while|debugger|export|import|yield|type|declare|interface|enum)\\b|\\)|})",
          "beginCaptures": {
            "1": {
              "name": "storage.type.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype-variable"
            }
          ]
        }
      ]
    },
    "literal-function": {
      "patterns": [
        {
          "comment": "e.g. function play<T>(arg1, arg2) { }",
          "name": "meta.function.js",
          "begin": "\\s*+(?:\\b(async)\\b\\s+)?\\s*+(?:(?<=\\.\\.\\.)|(?<!\\.))(\\bfunction\\b)\\s*+(\\*?)\\s*+((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)?(?=\\s*+(\\(|<))",
          "end": "(?<=})|\\s*(?=,|;|:|{|\\*/|\\b(if|switch|case|break|default|try|var|let|const|static|function|return|class|do|for|while|debugger|export|import|yield|type|declare|interface|enum)\\b|\\)|})",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "storage.type.js"
            },
            "2": {
              "name": "storage.type.function.js"
            },
            "3": {
              "name": "keyword.generator.asterisk.js"
            },
            "4": {
              "name": "entity.name.function.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype"
            },
            {
              "include": "#curly-brackets"
            }
          ]
        },
        {
          "comment": "e.g. play = function(arg1, arg2) { }",
          "name": "meta.function.js",
          "begin": "\\s*+(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(=)\\s*+(?:(async)\\s+)?\\s*+((?<!\\.)\\bfunction\\b)\\s*+(\\*?)\\s*+((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)?(?=\\s*+(\\(|<))",
          "end": "(?<=})|\\s*(?=,|;|{|\\*/|\\b(if|switch|case|break|default|try|var|let|const|static|function|return|class|do|for|while|debugger|export|import|yield|type|declare|interface|enum)\\b|\\)|})",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "entity.name.function.js"
            },
            "3": {
              "name": "keyword.operator.assignment.js"
            },
            "4": {
              "name": "storage.type.js"
            },
            "5": {
              "name": "storage.type.function.js"
            },
            "6": {
              "name": "keyword.generator.asterisk.js"
            },
            "7": {
              "name": "entity.name.function.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype"
            },
            {
              "include": "#curly-brackets"
            }
          ]
        },
        {
          "comment": "e.g. Sound.prototype.play = function(arg1, arg2) { }",
          "name": "meta.prototype.function.js",
          "begin": "\\s*+(\\#?)((?:[_\\p{Lu}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)(?:(\\?\\.)|(\\.))(prototype)(?:(\\?\\.)|(\\.))(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(=)\\s*+(?:(async)\\s+)?\\s*+((?<!\\.)\\bfunction\\b)\\s*+(\\*?)\\s*+((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)?(?=\\s*+(\\(|<))",
          "end": "(?<=})|\\s*(?=,|;|{|\\*/|\\b(if|switch|case|break|default|try|var|let|const|static|function|return|class|do|for|while|debugger|export|import|yield|type|declare|interface|enum)\\b|\\)|})",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "entity.name.class.js"
            },
            "3": {
              "name": "keyword.operator.existential.js"
            },
            "4": {
              "name": "keyword.operator.accessor.js"
            },
            "5": {
              "name": "variable.language.prototype.js"
            },
            "6": {
              "name": "keyword.operator.existential.js"
            },
            "7": {
              "name": "keyword.operator.accessor.js"
            },
            "8": {
              "name": "keyword.operator.private.js"
            },
            "9": {
              "name": "entity.name.function.js"
            },
            "10": {
              "name": "keyword.operator.assignment.js"
            },
            "11": {
              "name": "storage.type.js"
            },
            "12": {
              "name": "storage.type.function.js"
            },
            "13": {
              "name": "keyword.generator.asterisk.js"
            },
            "14": {
              "name": "entity.name.function.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype"
            },
            {
              "include": "#curly-brackets"
            }
          ]
        },
        {
          "comment": "e.g. Sound.play = function(arg1, arg2) { }",
          "name": "meta.function.static.js",
          "begin": "\\s*+(\\#?)((?:[_\\p{Lu}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)(?:(\\?\\.)|(\\.))(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(=)\\s*+(?:(async)\\s+)?\\s*+((?<!\\.)\\bfunction\\b)\\s*+(\\*?)\\s*+((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)?(?=\\s*+(\\(|<))",
          "end": "(?<=})|\\s*(?=,|;|{|\\*/|\\b(if|switch|case|break|default|try|var|let|const|static|function|return|class|do|for|while|debugger|export|import|yield|type|declare|interface|enum)\\b|\\)|})",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "entity.name.class.js"
            },
            "3": {
              "name": "keyword.operator.existential.js"
            },
            "4": {
              "name": "keyword.operator.accessor.js"
            },
            "5": {
              "name": "keyword.operator.private.js"
            },
            "6": {
              "name": "entity.name.function.js"
            },
            "7": {
              "name": "keyword.operator.assignment.js"
            },
            "8": {
              "name": "storage.type.js"
            },
            "9": {
              "name": "storage.type.function.js"
            },
            "10": {
              "name": "keyword.generator.asterisk.js"
            },
            "11": {
              "name": "entity.name.function.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype"
            },
            {
              "include": "#curly-brackets"
            }
          ]
        }
      ]
    },
    "literal-quasi": {
      "patterns": [
        {
          "comment": "GraphQL ( Relay.QL ) supprt. Use two forms of scopes! fixes some themes",
          "begin": "\\s*+(?:((Relay)(?:(\\?\\.)|(\\.))(QL))|(gql|graphql|graphql\\.experimental)|(/\\* GraphQL \\*/))\\s*((`))",
          "end": "\\s*((`))",
          "beginCaptures": {
            "2": {
              "name": "variable.other.class.js"
            },
            "3": {
              "name": "keyword.operator.existential.js"
            },
            "4": {
              "name": "keyword.operator.accessor.js"
            },
            "5": {
              "name": "entity.name.tag.grapahql.js"
            },
            "6": {
              "name": "entity.name.tag.grapahql.js"
            },
            "7": {
              "name": "entity.name.tag.grapahql.js"
            },
            "8": {
              "name": "string.quoted.template.js"
            },
            "9": {
              "name": "punctuation.definition.quasi.begin.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "string.quoted.template.graphql.js"
            },
            "2": {
              "name": "punctuation.definition.quasi.end.js"
            }
          },
          "patterns": [
            {
              "include": "#graphql"
            }
          ]
        },
        {
          "comment": "Use two forms of scopes! fixes some themes",
          "name": "string.quasi.js",
          "contentName": "string.quoted.template.js",
          "begin": "\\s*+(?!\\b(?:return|void)\\b)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)?\\s*((`))",
          "end": "\\s*((`))",
          "beginCaptures": {
            "1": {
              "name": "entity.name.tag.js"
            },
            "2": {
              "name": "string.quoted.template.js"
            },
            "3": {
              "name": "punctuation.definition.quasi.begin.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "string.quoted.template.js"
            },
            "2": {
              "name": "punctuation.definition.quasi.end.js"
            }
          },
          "patterns": [
            {
              "include": "#literal-quasi-embedded"
            },
            {
              "include": "#string-content"
            }
          ]
        }
      ]
    },
    "literal-quasi-embedded": {
      "name": "entity.quasi.element.js",
      "begin": "(?<!\\\\)(\\${)",
      "end": "}",
      "beginCaptures": {
        "1": {
          "name": "punctuation.quasi.element.begin.js"
        }
      },
      "endCaptures": {
        "0": {
          "name": "punctuation.quasi.element.end.js"
        }
      },
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "literal-js-label": {
      "comment": "jslabel: $|for|while|do",
      "match": "(?:^|(?<=;))\\s*([$_[:alpha:]][$_[:alnum:]]*)(:)\\s*(?=(/\\*.*?\\*/\\s*$|//|$|;|\\b(for|while|do)\\b))",
      "captures": {
        "1": {
          "name": "constant.other.label.js"
        },
        "2": {
          "name": "punctuation.separator.label.js"
        }
      }
    },
    "literal-object": {
      "comment": "obj lteral ({ or ,{ or [{ or ={ or return { or default {",
      "begin": "(?:(?<=\\(|\\[|,)|(?:\\s*(?:(=)|\\b(default)\\b|\\b(return)\\b|(,))))\\s*({)",
      "end": "\\s*+(})",
      "beginCaptures": {
        "1": {
          "name": "keyword.operator.assignment.js"
        },
        "2": {
          "name": "keyword.control.module.js"
        },
        "3": {
          "name": "keyword.control.flow.js"
        },
        "4": {
          "name": "meta.delimiter.comma.js"
        },
        "5": {
          "name": "meta.brace.curly.litobj.js"
        }
      },
      "endCaptures": {
        "1": {
          "name": "meta.brace.curly.litobj.js"
        }
      },
      "patterns": [
        {
          "include": "#literal-object-body"
        }
      ]
    },
    "literal-object-brace": {
      "comment": "nested obj literal found inside other objects like arrays",
      "begin": "\\s*({)",
      "end": "\\s*+(})",
      "beginCaptures": {
        "1": {
          "name": "meta.brace.curly.litobj.js"
        }
      },
      "endCaptures": {
        "1": {
          "name": "meta.brace.curly.litobj.js"
        }
      },
      "patterns": [
        {
          "include": "#literal-object-body"
        }
      ]
    },
    "literal-object-brace-property": {
      "comment": "nested obj literal key: {object} ",
      "begin": "(?<=:)\\s*({)",
      "end": "\\s*+(})",
      "beginCaptures": {
        "1": {
          "name": "meta.brace.curly.litobj.js"
        }
      },
      "endCaptures": {
        "1": {
          "name": "meta.brace.curly.litobj.js"
        }
      },
      "patterns": [
        {
          "include": "#literal-object-body"
        }
      ]
    },
    "literal-object-body": {
      "patterns": [
        {
          "include": "#html-template"
        },
        {
          "include": "#literal-object-brace-property"
        },
        {
          "include": "#literal-function-labels"
        },
        {
          "include": "#literal-arrow-function-labels"
        },
        {
          "include": "#literal-arrow-function"
        },
        {
          "include": "#literal-method"
        },
        {
          "include": "#arrow-expression"
        },
        {
          "include": "#literal-object-prop-shorthand"
        },
        {
          "include": "#literal-labels"
        },
        {
          "include": "#expression"
        },
        {
          "include": "#literal-punctuation"
        }
      ]
    },
    "literal-object-prop-shorthand": {
      "comment": "give an alternate scope name to shorthand object literals",
      "patterns": [
        {
          "match": "(?<=^|,|{)(?<!:|\\.)\\s*+(((?:[$_\\p{Lu}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{Lu}\\p{Nl}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+))\\s*+(?=$|,|})",
          "captures": {
            "1": {
              "name": "constant.other.object.key.js"
            },
            "2": {
              "name": "variable.other.constant.shorthandpropertyname.js"
            }
          }
        },
        {
          "match": "(?<=^|,|{)(?<!:|\\.)\\s*+(((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+))\\s*+(?=$|,|})",
          "captures": {
            "1": {
              "name": "variable.other.readwrite.shorthandpropertyname.js"
            }
          }
        }
      ]
    },
    "arrow-expression": {
      "comment": "or inside a class def on a ; or braced block } end of line or ;",
      "begin": "(?<==>)\\s*$",
      "end": "(?=\\s*([,;}]|$))|(?<=})",
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "literal-operators": {
      "patterns": [
        {
          "include": "#esnext-pipeline"
        },
        {
          "include": "#es7-function-bind"
        },
        {
          "match": "(?<!\\.)\\s*+\\b(delete|in|instanceof|new|of|typeof|void|with)\\b",
          "captures": {
            "1": {
              "name": "keyword.operator.$1.js"
            }
          }
        },
        {
          "match": "\\?\\?",
          "name": "keyword.operator.nullcoalesce.js"
        },
        {
          "match": "!(?!=)|&&|\\|\\|",
          "name": "keyword.operator.logical.js"
        },
        {
          "match": "=(?!(=|>))",
          "name": "keyword.operator.assignment.js"
        },
        {
          "match": "%=|&=|\\*=|\\+=|-=|/=|\\^=|\\|=|<<=|>>=|>>>=",
          "name": "keyword.operator.assignment.augmented.js"
        },
        {
          "match": "~|<<|>>>|>>|&|\\^|\\|",
          "name": "keyword.operator.bitwise.js"
        },
        {
          "match": "<=|>=|<>|<|>",
          "name": "keyword.operator.relational.js"
        },
        {
          "match": "===|!==|==|!=",
          "name": "keyword.operator.comparison.js"
        },
        {
          "match": "--|\\+\\+|(?<!/)\\*\\*|(?<!\\*)/(?!/|\\*)|%|\\*(?<!/\\*)(?!/([^\\*]|$))|\\+|-",
          "name": "keyword.operator.arithmetic.js"
        },
        {
          "comment": "ternary operator - make sure end : is consumed to avoid mistake as flow type",
          "begin": "\\s*+(\\?)(?!\\.[^\\d]|\\?)",
          "end": "\\s*(:)((?=::)|(?!:))",
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.ternary.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "keyword.operator.ternary.js"
            }
          },
          "patterns": [
            {
              "begin": "\\s*+(?=((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*:)",
              "end": "\\s*(?=:)",
              "patterns": [
                {
                  "include": "#literal-language-constant"
                },
                {
                  "include": "#literal-variable"
                }
              ]
            },
            {
              "include": "#expression"
            }
          ]
        },
        {
          "match": "(?<!\\.)\\s*+(\\.\\.\\.)",
          "captures": {
            "1": {
              "name": "keyword.operator.spread.js"
            }
          }
        },
        {
          "match": "(?:(\\?\\.)|(\\.))",
          "captures": {
            "1": {
              "name": "keyword.operator.existential.js"
            },
            "2": {
              "name": "keyword.operator.accessor.js"
            }
          }
        }
      ]
    },
    "literal-function-call": {
      "patterns": [
        {
          "include": "#comments"
        },
        {
          "include": "#literal-keywords"
        },
        {
          "comment": "A new expression with no type params or arguments, like new Foo()",
          "name": "meta.new-class.without-arguments.js",
          "match": "(?<!\\.)\\s*+(\\bnew\\b)\\s*+((\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(\\?\\.)?(\\()\\s*+(\\)))",
          "captures": {
            "1": {
              "name": "keyword.operator.new.js"
            },
            "2": {
              "name": "meta.function-call.without-arguments.js"
            },
            "3": {
              "name": "keyword.operator.private.js"
            },
            "4": {
              "name": "entity.name.type.instance.js"
            },
            "5": {
              "name": "keyword.operator.existential.js"
            },
            "6": {
              "name": "meta.brace.round.js"
            },
            "7": {
              "name": "meta.brace.round.js"
            }
          }
        },
        {
          "comment": "A new expression with type params and no arguments, like new Foo<string>()",
          "name": "meta.new-class.without-arguments.js",
          "begin": "(?<!\\.)\\s*+(\\bnew\\b)\\s*+((\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(\\?\\.)?\\s*+(?=(<(?:(?>[^<>]+)|\\g<-1>)*>)\\s*+(\\()\\s*+(\\))))",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": { "name": "keyword.operator.new.js" },
            "2": { "name": "meta.function-call.without-arguments.js" },
            "3": { "name": "keyword.operator.private.js" },
            "4": { "name": "entity.name.type.instance.js" },
            "5": { "name": "keyword.operator.existential.js" }
          },
          "patterns": [
            { "include": "#type-argument-brackets" },
            { "include": "#round-brackets" }
          ]
        },
        {
          "comment": "A new expression with arguments and maybe type params, like new Foo<string>(123)",
          "name": "meta.new-class.with-arguments.js",
          "begin": "(?<!\\.)\\s*+(\\bnew\\b)\\s*+((\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(\\?\\.)?\\s*+(?=(<(?:(?>[^<>]+)|\\g<-1>)*>)?\\s*+\\())",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.new.js"
            },
            "2": {
              "name": "meta.function-call.with-arguments.js"
            },
            "3": {
              "name": "keyword.operator.private.js"
            },
            "4": {
              "name": "entity.name.type.instance.js"
            },
            "5": {
              "name": "keyword.operator.existential.js"
            }
          },
          "patterns": [
            {
              "include": "#type-argument-brackets"
            },
            {
              "include": "#round-brackets"
            }
          ]
        },
        {
          "include": "#literal-operators"
        },
        {
          "comment": "A call expression with no type params or arguments, like foo()",
          "name": "meta.function-call.without-arguments.js",
          "match": "(?<!\\.)\\s*+(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(\\?\\.)?(\\()\\s*+(\\))",
          "captures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "entity.name.function.js"
            },
            "3": {
              "name": "keyword.operator.existential.js"
            },
            "4": {
              "name": "meta.brace.round.js"
            },
            "5": {
              "name": "meta.brace.round.js"
            }
          }
        },
        {
          "comment": "A call expression with type params and no arguments, like foo<string>()",
          "name": "meta.function-call.without-arguments.js",
          "begin": "(?<!\\.)\\s*+(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(\\?\\.)?\\s*+(?=(<(?:(?>[^<>]+)|\\g<-1>)*>)\\s*+(\\()\\s*+(\\)))",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": { "name": "keyword.operator.private.js" },
            "2": { "name": "entity.name.function.js" },
            "3": { "name": "keyword.operator.existential.js" }
          },
          "patterns": [
            { "include": "#type-argument-brackets" },
            { "include": "#round-brackets" }
          ]
        },
        {
          "comment": "maybe in array form e.g. foo[bar]() or foo[bar]<string>()",
          "name": "meta.function-call.without-arguments.js",
          "begin": "(?<!\\.)\\s*+((\\bnew\\b)*)\\s*+(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)(?=\\s*(\\[(?:(?>[^\\[\\]]+)|\\g<-1>)*\\])\\s*+(<(?:(?>[^<>]+)|\\g<-1>)*>)?\\s*+\\(\\s*+\\))",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "2": {
              "name": "keyword.operator.new.js"
            },
            "3": {
              "name": "keyword.operator.private.js"
            },
            "4": {
              "name": "variable.other.object.js"
            }
          },
          "patterns": [
            {
              "include": "#square-brackets"
            },
            {
              "include": "#type-argument-brackets"
            },
            {
              "include": "#round-brackets"
            }
          ]
        },
        {
          "comment": "A call expression with arguments and maybe type params, like foo(123) or foo<string>(123)",
          "name": "meta.function-call.with-arguments.js",
          "begin": "(?<!\\.)\\s*+(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(\\?\\.)?\\s*+(?=(<(?:(?>[^<>]+)|\\g<-1>)*>)?\\s*+\\()",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "entity.name.function.js"
            },
            "3": {
              "name": "keyword.operator.existential.js"
            }
          },
          "patterns": [
            {
              "include": "#type-argument-brackets"
            },
            {
              "include": "#round-brackets"
            }
          ]
        },
        {
          "comment": "maybe in array form e.g. foo[bar](123)",
          "name": "meta.function-call.with-arguments.js",
          "begin": "(?<!\\.)\\s*+((\\bnew\\b)*)\\s*+(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(?=(\\[(?:(?>[^\\[\\]]+)|\\g<-1>)*\\])\\s*+(<(?:(?>[^<>]+)|\\g<-1>)*>)?\\s*+\\()",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "2": {
              "name": "keyword.operator.new.js"
            },
            "3": {
              "name": "keyword.operator.private.js"
            },
            "4": {
              "name": "variable.other.object.js"
            }
          },
          "patterns": [
            {
              "include": "#square-brackets"
            },
            {
              "include": "#type-argument-brackets"
            },
            {
              "include": "#round-brackets"
            }
          ]
        }
      ]
    },
    "literal-language-constant": {
      "patterns": [
        {
          "match": "(?<!\\.)\\s*+\\b((true)|(false)|(null)|(undefined)|(NaN))\\b",
          "captures": {
            "2": {
              "name": "constant.language.boolean.true.js"
            },
            "3": {
              "name": "constant.language.boolean.false.js"
            },
            "4": {
              "name": "constant.language.null.js"
            },
            "5": {
              "name": "constant.language.undefined.js"
            },
            "6": {
              "name": "constant.language.nan.js"
            }
          }
        }
      ]
    },
    "support": {
      "patterns": [
        {
          "begin": "\\s*+\\b(WeakSet|WeakMap|URIError|Uint8ClampedArray|Uint8Array|Uint32Array|Uint16Array|TypeError|TypedArray|SyntaxError|Symbol|String|SharedArrayBuffer|Set|RegExp|Reflect|ReferenceError|RangeError|Proxy|Promise|Object|Number|NaN|Math|Map|JSON|InternalError|Int8Array|Int32Array|Int16Array|Infinity|GeneratorFunction|Generator|Function|Float64Array|Float32Array|EvalError|Error|Date|DataView|Boolean|Atomics|ArrayBuffer|Array)\\b",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "support.class.builtin.js"
            }
          },
          "patterns": [
            {
              "include": "#round-brackets"
            }
          ]
        },
        {
          "begin": "\\s*+\\b((SIMD)((\\.)(Uint8x16|Uint32x4|Uint16x8|Int8x16|Int32x4|Int16x8|Float64x2|Float32x4|Bool8x16|Bool64x2|Bool32x4|Bool16x8))?)\\b",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "2": {
              "name": "support.class.builtin.js"
            },
            "4": {
              "name": "keyword.operator.accessor.js"
            },
            "5": {
              "name": "support.class.builtin.js"
            }
          },
          "patterns": [
            {
              "include": "#round-brackets"
            }
          ]
        },
        {
          "begin": "\\s*+\\b((Intl)((\\.)(NumberFormat|DateTimeFormat|Collator))?)\\b",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "2": {
              "name": "support.class.builtin.js"
            },
            "4": {
              "name": "keyword.operator.accessor.js"
            },
            "5": {
              "name": "support.class.builtin.js"
            }
          },
          "patterns": [
            {
              "include": "#round-brackets"
            }
          ]
        },
        {
          "begin": "(?<!\\.)\\s*+\\b(decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|escape|eval|isFinite|isNaN|parseFloat|parseInt|unescape)\\b",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "support.function.js"
            }
          },
          "patterns": [
            {
              "include": "#round-brackets"
            }
          ]
        },
        {
          "begin": "(?<=\\.)\\s*+(shift|sort|splice|unshift|pop|push|reverse)\\b",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "support.function.mutator.js"
            }
          },
          "patterns": [
            {
              "include": "#round-brackets"
            }
          ]
        },
        {
          "begin": "(?<!\\.)\\s*+\\b((Eval|Range|Reference|Syntax|Type|URI)?Error)\\b",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "support.class.error.js"
            }
          },
          "patterns": [
            {
              "include": "#round-brackets"
            }
          ]
        },
        {
          "match": "(?<!\\.)\\s*+\\b(debugger)\\b",
          "captures": {
            "1": {
              "name": "keyword.other.js"
            }
          }
        },
        {
          "match": "(?<!\\.)\\s*+\\b(document|window)\\b",
          "captures": {
            "1": {
              "name": "support.type.object.dom.js"
            }
          }
        },
        {
          "match": "\\s*+\\b(ELEMENT_NODE|ATTRIBUTE_NODE|TEXT_NODE|CDATA_SECTION_NODE|ENTITY_REFERENCE_NODE|ENTITY_NODE|PROCESSING_INSTRUCTION_NODE|COMMENT_NODE|DOCUMENT_NODE|DOCUMENT_TYPE_NODE|DOCUMENT_FRAGMENT_NODE|NOTATION_NODE|INDEX_SIZE_ERR|DOMSTRING_SIZE_ERR|HIERARCHY_REQUEST_ERR|WRONG_DOCUMENT_ERR|INVALID_CHARACTER_ERR|NO_DATA_ALLOWED_ERR|NO_MODIFICATION_ALLOWED_ERR|NOT_FOUND_ERR|NOT_SUPPORTED_ERR|INUSE_ATTRIBUTE_ERR)\\b",
          "captures": {
            "1": {
              "name": "support.constant.dom.js"
            }
          }
        },
        {
          "begin": "(?<!\\.)\\s*+\\b(console)(?:(\\.)(warn|info|log|error|time|timeEnd|assert))?\\b",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "support.type.object.console.js"
            },
            "2": {
              "name": "keyword.operator.accessor.js"
            },
            "3": {
              "name": "support.function.console.js"
            }
          },
          "patterns": [
            {
              "include": "#round-brackets"
            }
          ]
        },
        {
          "match": "(?<!\\.)\\s*+\\b(process)(?:(\\.)(stdout|stderr|stdin|argv|execPath|execArgv|env|exitCode|version|versions|config|pid|title|arch|platform|mainModule))?\\b",
          "captures": {
            "1": {
              "name": "support.type.object.process.js"
            },
            "2": {
              "name": "keyword.operator.accessor.js"
            },
            "3": {
              "name": "support.type.object.process.js"
            }
          }
        },
        {
          "begin": "(?<!\\.)\\s*+\\b(process)(?:(\\.)(abort|chdir|cwd|exit|getgid|setgid|getuid|setuid|setgroups|getgroups|initgroups|kill|memoryUsage|nextTick|umask|uptime|hrtime))?\\b",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "support.type.object.process.js"
            },
            "2": {
              "name": "keyword.operator.accessor.js"
            },
            "3": {
              "name": "support.function.process.js"
            }
          },
          "patterns": [
            {
              "include": "#round-brackets"
            }
          ]
        },
        {
          "match": "(((?<!\\.)\\s*+\\bmodule\\.((?<!\\,)exports|id|require|parent|filename|loaded|children)|exports))\\b",
          "captures": {
            "1": {
              "name": "support.type.object.module.js"
            },
            "2": {
              "name": "keyword.operator.accessor.js"
            },
            "3": {
              "name": "support.type.object.module.js"
            }
          }
        },
        {
          "match": "(?<!\\.)\\s*+\\b(global|GLOBAL|root|__dirname|__filename)\\b",
          "captures": {
            "1": {
              "name": "support.type.object.node.js"
            }
          }
        },
        {
          "begin": "\\s*+\\b(Buffer|EventEmitter|Server|Pipe|Socket|REPLServer|ReadStream|WriteStream|Stream|Inflate|Deflate|InflateRaw|DeflateRaw|GZip|GUnzip|Unzip|Zip)\\b",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "support.class.node.js"
            }
          },
          "patterns": [
            {
              "include": "#round-brackets"
            }
          ]
        }
      ]
    },
    "literal-class": {
      "patterns": [
        {
          "comment": "Classes",
          "begin": "(?<!\\.)\\s*+\\b((class))\\s+",
          "end": "\\s*(?<=})",
          "beginCaptures": {
            "1": {
              "name": "meta.class.js"
            },
            "2": {
              "name": "storage.type.class.js"
            }
          },
          "patterns": [
            {
              "match": "\\s*+\\b((extends)|(implements))\\b\\s*+",
              "captures": {
                "1": {
                  "name": "meta.class.extends.js"
                },
                "2": {
                  "name": "storage.type.extends.js"
                },
                "3": {
                  "name": "storage.type.implements.js"
                }
              }
            },
            {
              "comment": "look for class names but dont assume uppercase start char",
              "match": "\\s*+((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)",
              "captures": {
                "1": {
                  "name": "entity.name.class.js"
                }
              }
            },
            {
              "include": "#flowtype-polymorphs"
            },
            {
              "begin": "\\s*+({)",
              "end": "\\s*(})",
              "contentName": "meta.class.body.js",
              "beginCaptures": {
                "1": {
                  "name": "punctuation.section.class.begin.js"
                }
              },
              "endCaptures": {
                "1": {
                  "name": "punctuation.section.class.end.js"
                }
              },
              "patterns": [
                {
                  "include": "#class-body"
                }
              ]
            },
            {
              "include": "#expression"
            }
          ]
        }
      ]
    },
    "punctuation-semicolon": {
      "name": "punctuation.terminator.statement.js",
      "match": ";"
    },
    "class-body": {
      "patterns": [
        {
          "include": "#flowtype-keywords"
        },
        {
          "include": "#literal-method"
        },
        {
          "include": "#arrow-expression"
        },
        {
          "include": "#literal-arrow-function-simple-assignments"
        },
        {
          "include": "#literal-arrow-function"
        },
        {
          "include": "#brackets"
        },
        {
          "include": "#es7-decorators"
        },
        {
          "include": "#comments"
        },
        {
          "comment": "handle class fields with no flow types like var = ",
          "match": "(?<!:)\\s*+(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*(?==)(?!=>|==)",
          "captures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "variable.other.readwrite.js"
            }
          }
        },
        {
          "comment": "a line starts with a static, [, name(, name:, name=, } or a semi-colon anywhere",
          "begin": "\\s*+(?==[^=>])",
          "end": "((?=^\\s*(\\#?)(((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+\\??\\s*+(:|=(?!^==|=>))|\\[|((?:(\\#?)[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[(\\#?)$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+\\(|\\b(static|async)\\b)|}))|\\s*(;)",
          "endCaptures": {
            "9": {
              "name": "punctuation.terminator.statement.js"
            }
          },
          "patterns": [
            {
              "include": "#literal-method"
            },
            {
              "include": "#expression"
            }
          ]
        },
        {
          "match": "(?<!\\.)\\s*+\\b(static)\\b(?!\\.)",
          "captures": {
            "1": {
              "name": "storage.modifier.js"
            }
          }
        },
        {
          "include": "#flowtype-variable"
        },
        {
          "include": "#literal-semi-colon"
        }
      ]
    },
    "literal-method-call": {
      "patterns": [
        {
          "name": "meta.method-call.without-arguments.js",
          "comment": "e.g CONSTNAME.method() or CONST.method[p]()",
          "begin": "\\s*+(\\#?)((?:[\\p{Lu}])(?:[$_\\p{Lu}\\p{Nd}])*+)\\s*+(?:(\\?\\.)|(\\.))\\s*+(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(?=(\\[(?:(?>[^\\[\\]]+)|\\\\g<-1>)*\\])?+\\s*+(<(?:(?>[^<>]+)|\\g<-1>)*>)?\\s*+(\\(\\s*+\\)))",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "variable.other.constant.js"
            },
            "3": {
              "name": "keyword.operator.existential.js"
            },
            "4": {
              "name": "keyword.operator.accessor.js"
            },
            "5": {
              "name": "keyword.operator.private.js"
            },
            "6": {
              "name": "entity.name.function.js"
            }
          },
          "patterns": [
            {
              "include": "#square-brackets"
            },
            {
              "include": "#type-argument-brackets"
            },
            {
              "include": "#round-brackets"
            }
          ]
        },
        {
          "name": "meta.method-call.without-arguments.js",
          "comment": "e.g Abc.aaa()",
          "begin": "\\s*+(\\#?)((?:[\\p{Lu}])(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(?:(\\?\\.)|(\\.))\\s*+(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(?=(\\[(?:(?>[^\\[\\]]+)|\\\\g<-1>)*\\])?+\\s*+(\\(\\s*+\\)))",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "variable.other.class.js"
            },
            "3": {
              "name": "keyword.operator.existential.js"
            },
            "4": {
              "name": "keyword.operator.accessor.js"
            },
            "5": {
              "name": "keyword.operator.private.js"
            },
            "6": {
              "name": "entity.name.function.js"
            }
          },
          "patterns": [
            {
              "include": "#square-brackets"
            },
            {
              "include": "#round-brackets"
            }
          ]
        },
        {
          "name": "meta.method-call.with-arguments.js",
          "comment": "e.g CONSTNAME.method()",
          "begin": "\\s*+(\\#?)((?:[\\p{Lu}])(?:[$_\\p{Lu}\\p{Nd}])*+)\\s*+(?:(\\?\\.)|(\\.))\\s*+(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(?=(\\[(?:(?>[^\\[\\]]+)|\\\\g<-1>)*\\])?+\\s*+(<(?:(?>[^<>]+)|\\g<-1>)*>)?\\s*+\\()",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "variable.other.constant.js"
            },
            "3": {
              "name": "keyword.operator.existential.js"
            },
            "4": {
              "name": "keyword.operator.accessor.js"
            },
            "5": {
              "name": "keyword.operator.private.js"
            },
            "6": {
              "name": "entity.name.function.js"
            }
          },
          "patterns": [
            {
              "include": "#square-brackets"
            },
            {
              "include": "#type-argument-brackets"
            },
            {
              "include": "#round-brackets"
            }
          ]
        },
        {
          "name": "meta.method-call.with-arguments.js",
          "comment": "e.g Abc.aaa()",
          "begin": "\\s*+(\\#?)((?:[\\p{Lu}])(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(?:(\\?\\.)|(\\.))\\s*+(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(?=(\\[(?:(?>[^\\[\\]]+)|\\\\g<-1>)*\\])?+\\s*+(<(?:(?>[^<>]+)|\\g<-1>)*>)?\\s*+\\()",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "variable.other.class.js"
            },
            "3": {
              "name": "keyword.operator.existential.js"
            },
            "4": {
              "name": "keyword.operator.accessor.js"
            },
            "5": {
              "name": "keyword.operator.private.js"
            },
            "6": {
              "name": "entity.name.function.js"
            }
          },
          "patterns": [
            {
              "include": "#round-brackets"
            },
            {
              "include": "#type-argument-brackets"
            }
          ]
        },
        {
          "name": "meta.method-call.without-arguments.js",
          "comment": "e.g .aaa()",
          "begin": "(?<=\\.)\\s*+(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(?=(\\[(?:(?>[^\\[\\]]+)|\\\\g<-1>)*\\])?+\\s*+(<(?:(?>[^<>]+)|\\g<-1>)*>)?\\s*+(\\(\\s*+\\)))",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "entity.name.function.js"
            },
            "3": {
              "name": "meta.group.braces.round.function.arguments.js"
            }
          },
          "patterns": [
            {
              "include": "#square-brackets"
            },
            {
              "include": "#type-argument-brackets"
            },
            {
              "include": "#round-brackets"
            }
          ]
        },
        {
          "name": "meta.method-call.with-arguments.js",
          "comment": "e.g .aaa()",
          "begin": "(?<=\\.)\\s*+(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(?=(\\[(?:(?>[^\\[\\]]+)|\\\\g<-1>)*\\])?+\\s*+(<(?:(?>[^<>]+)|\\g<-1>)*>)?\\s*+\\()",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "entity.name.function.js"
            }
          },
          "patterns": [
            {
              "include": "#square-brackets"
            },
            {
              "include": "#type-argument-brackets"
            },
            {
              "include": "#round-brackets"
            }
          ]
        }
      ]
    },
    "literal-language-variable": {
      "patterns": [
        {
          "match": "(?<!(?<!\\.\\.)\\.)\\s*+\\b(arguments)\\b",
          "captures": {
            "1": {
              "name": "variable.language.arguments.js"
            }
          }
        },
        {
          "match": "(?<!(?<!\\.\\.)\\.)\\s*+\\b(super)\\b\\s*+(?!\\()",
          "captures": {
            "1": {
              "name": "variable.language.super.js"
            }
          }
        },
        {
          "match": "(?<!(?<!\\.\\.)\\.)\\s*+\\b(this)\\b",
          "captures": {
            "1": {
              "name": "variable.language.this.js"
            }
          }
        },
        {
          "match": "(?<!(?<!\\.\\.)\\.)\\s*+\\b(self)\\b\\s*+(?!\\()",
          "captures": {
            "1": {
              "name": "variable.language.self.js"
            }
          }
        },
        {
          "match": "(?<=\\.)\\s*+\\b(__proto__)\\b",
          "captures": {
            "1": {
              "name": "variable.language.proto.js"
            }
          }
        },
        {
          "match": "(?<=\\.)\\s*+\\b(constructor)\\b\\s*+(?!\\()",
          "captures": {
            "1": {
              "name": "variable.language.constructor.js"
            }
          }
        },
        {
          "match": "(?<=\\.)\\s*+\\b(prototype)\\b",
          "captures": {
            "1": {
              "name": "variable.language.prototype.js"
            }
          }
        }
      ]
    },
    "string-content": {
      "patterns": [
        {
          "name": "constant.character.escape.newline.js",
          "match": "\\\\\n"
        },
        {
          "name": "constant.character.escape",
          "match": "\\\\['\"\\\\nrtbfv0`]"
        },
        {
          "name": "constant.character.escape",
          "match": "\\\\u(({[0-9a-fA-F]+\\})|[0-9a-fA-F]{4})"
        },
        {
          "name": "constant.character.escape",
          "match": "\\\\x[0-9a-fA-F]{2}"
        }
      ]
    },
    "literal-number": {
      "patterns": [
        {
          "match": "\\s*+((?:\\B[-+])?(?:\\b0[bB][_0-1]*|\\b0[oO][_0-7]*|\\b0[xX][_0-9a-fA-F]*|(\\B\\.[_0-9]+|\\b[0-9]+(\\.[_0-9]*)?)([eE][-+]?[_0-9]+)?))(n\\b)?",
          "captures": {
            "1": {
              "name": "constant.numeric.js"
            },
            "5": {
              "name": "constant.numeric.bigint.js"
            }
          }
        }
      ]
    },
    "literal-arrow-function": {
      "patterns": [
        {
          "comment": "e.g. (args) => { }",
          "name": "meta.function.arrow.js",
          "begin": "\\s*+(\\basync\\b)?(?=\\s*(<(?:(?>(?<==)>|[^<>]+)|\\g<-1>)*>)?\\s*+(\\((?>[^()\"']|(\"(\\\\.|[^\"])*+\")++|('(\\\\.|[^'])*+')++|\\g<-5>)*+\\))\\s*+(((?::(?:(\\s*+(&|\\|)?(\\s*+((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)(<(?:(?>(?<==)>|[^<>]+)|\\g<-1>)*>)?|\\s*+({(?:(?>[^{}]+)|\\g<-1>)*\\})|\\s*+(\\[(?:(?>[^\\[\\]]+)|\\g<-1>)*\\])|\\s*+(\\s*([\"']).*?\\k<-1>(?<!\\\\.))|\\s*[+-x]?[0-9A-Fa-f]+))|(?:\\s*+/\\*.*?\\*/))*+)*)|(?:/\\*.*?\\*/))\\s*=>)",
          "end": "((?<=})|(?:\\s*(=>)(?!\\s*{)))",
          "beginCaptures": {
            "1": {
              "name": "storage.type.js"
            }
          },
          "endCaptures": {
            "2": {
              "name": "storage.type.function.arrow.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype"
            },
            {
              "include": "#fat-arrow-braced-body"
            }
          ]
        },
        {
          "comment": "e.g. arg => { }",
          "name": "meta.function.arrow.js",
          "match": "\\s*+(\\basync\\b)?\\s*+(((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+))\\s*(=>)",
          "captures": {
            "1": {
              "name": "storage.type.js"
            },
            "2": {
              "name": "meta.function.parameters.js"
            },
            "3": {
              "name": "variable.other.readwrite.js"
            },
            "4": {
              "name": "storage.type.function.arrow.js"
            }
          }
        },
        {
          "include": "#literal-arrow-function-simple-assignments"
        },
        {
          "comment": "Sound.prototype.play = (args) => { }",
          "name": "meta.prototype.function.arrow.js",
          "begin": "\\s*+(\\#?)(\\b(?:[$_\\p{Lu}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)?(?:(\\?\\.)|(\\.))(prototype)(?:(\\?\\.)|(\\.))(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(=)\\s*+(\\basync\\b)?(?=\\s*(<(?:(?>(?<==)>|[^<>]+)|\\g<-1>)*>)?\\s*+(\\((?>[^()\"']|(\"(\\\\.|[^\"])*+\")++|('(\\\\.|[^'])*+')++|\\g<-5>)*+\\))\\s*+(((?::(?:(\\s*+(&|\\|)?(\\s*%checks\\b|\\s*(\\((?>[^()\"']|(\"(\\\\.|[^\"])*+\")++|('(\\\\.|[^'])*+')++|\\g<-5>)*+\\))+|\\s*+((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)|(<(?:(?>(?<==)>|[^<>]+)|\\g<-1>)*>)+|\\s*+({(?:(?>[^{}]+)|\\g<-1>)*\\})|\\s*+(\\[(?:(?>[^\\[\\]]+)|\\g<-1>)*\\])|\\s*+(\\s*([\"']).*?\\k<-1>(?<!\\\\.))|\\s*[+-x]?[0-9A-Fa-f]+))|(?:\\s*+/\\*.*?\\*/))*+)*)|(?:/\\*.*?\\*/))\\s*=>)",
          "end": "((?<=})|(?:\\s*(=>)(?!\\s*{)))",
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "entity.name.class.js"
            },
            "3": {
              "name": "keyword.operator.existential.js"
            },
            "4": {
              "name": "keyword.operator.accessor.js"
            },
            "5": {
              "name": "variable.language.prototype.js"
            },
            "6": {
              "name": "keyword.operator.existential.js"
            },
            "7": {
              "name": "keyword.operator.accessor.js"
            },
            "8": {
              "name": "keyword.operator.private.js"
            },
            "9": {
              "name": "entity.name.function.js"
            },
            "10": {
              "name": "keyword.operator.assignment.js"
            },
            "11": {
              "name": "storage.type.js"
            }
          },
          "endCaptures": {
            "2": {
              "name": "storage.type.function.arrow.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype"
            },
            {
              "include": "#fat-arrow-braced-body"
            }
          ]
        },
        {
          "comment": "e.g. Sound.prototype.play = arg => { }",
          "name": "meta.prototype.function.arrow.js",
          "match": "\\s*+(\\#?)(\\b(?:[$_\\p{Lu}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)?\\s*(?:(\\?\\.)|(\\.))(prototype)(?:(\\?\\.)|(\\.))(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(=)\\s*+(\\basync\\b)?\\s*+((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*(=>)",
          "captures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "entity.name.class.js"
            },
            "3": {
              "name": "keyword.operator.existential.js"
            },
            "4": {
              "name": "keyword.operator.accessor.js"
            },
            "5": {
              "name": "variable.language.prototype.js"
            },
            "6": {
              "name": "keyword.operator.existential.js"
            },
            "7": {
              "name": "keyword.operator.accessor.js"
            },
            "8": {
              "name": "keyword.operator.private.js"
            },
            "9": {
              "name": "entity.name.function.js"
            },
            "10": {
              "name": "keyword.operator.assignment.js"
            },
            "11": {
              "name": "storage.type.js"
            },
            "12": {
              "name": "variable.other.readwrite.js"
            },
            "13": {
              "name": "storage.type.function.arrow.js"
            }
          }
        },
        {
          "comment": "e.g. Sound.play = (args) => { }",
          "name": "meta.function.static.arrow.js",
          "begin": "\\s*+(\\#?)(\\b(?:[$_\\p{Lu}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)?(?:(\\?\\.)|(\\.))(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(=)\\s*+(\\basync\\b)?(?=\\s*+(<(?:(?>(?<==)>|[^<>]+)|\\g<-1>)*>)?\\s*+(\\((?>[^()\"']|(\"(\\\\.|[^\"])*+\")++|('(\\\\.|[^'])*+')++|\\g<-5>)*+\\))\\s*+(((?::(?:(\\s*+(&|\\|)?(\\s*%checks\\b|\\s*(\\((?>[^()\"']|(\"(\\\\.|[^\"])*+\")++|('(\\\\.|[^'])*+')++|\\g<-5>)*+\\))+|\\s*+((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)|(<(?:(?>(?<==)>|[^<>]+)|\\g<-1>)*>)+|\\s*+({(?:(?>[^{}]+)|\\g<-1>)*\\})|\\s*+(\\[(?:(?>[^\\[\\]]+)|\\g<-1>)*\\])|\\s*+(\\s*([\"']).*?\\k<-1>(?<!\\\\.))|\\s*[+-x]?[0-9A-Fa-f]+))|(?:\\s*+/\\*.*?\\*/))*+)*)|(?:/\\*.*?\\*/))\\s*=>)",
          "end": "((?<=})|(?:\\s*(=>)(?!\\s*{)))",
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "entity.name.class.js"
            },
            "3": {
              "name": "keyword.operator.existential.js"
            },
            "4": {
              "name": "keyword.operator.accessor.js"
            },
            "5": {
              "name": "keyword.operator.private.js"
            },
            "6": {
              "name": "entity.name.function.js"
            },
            "7": {
              "name": "keyword.operator.assignment.js"
            },
            "8": {
              "name": "storage.type.js"
            }
          },
          "endCaptures": {
            "2": {
              "name": "storage.type.function.arrow.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype"
            },
            {
              "include": "#fat-arrow-braced-body"
            }
          ]
        },
        {
          "comment": "e.g. Sound.play = arg => { }",
          "name": "meta.function.static.arrow.js",
          "match": "\\s*+(\\#?)(\\b(?:[$_\\p{Lu}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)?(?:(\\?\\.)|(\\.))(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(=)\\s*+(\\basync\\b)?\\s*+((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*(=>)",
          "captures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "entity.name.class.js"
            },
            "3": {
              "name": "keyword.operator.existential.js"
            },
            "4": {
              "name": "keyword.operator.accessor.js"
            },
            "5": {
              "name": "keyword.operator.private.js"
            },
            "6": {
              "name": "entity.name.function.js"
            },
            "7": {
              "name": "keyword.operator.assignment.js"
            },
            "8": {
              "name": "storage.type.js"
            },
            "9": {
              "name": "variable.other.readwrite.js"
            },
            "10": {
              "name": "storage.type.function.arrow.js"
            }
          }
        }
      ]
    },
    "literal-arrow-function-simple-assignments": {
      "patterns": [
        {
          "include": "#literal-async-arrow-function-simple-assignments"
        },
        {
          "comment": "e.g. play = (args) => { }",
          "name": "meta.function.arrow.js",
          "begin": "\\s*+(\\#?)(\\b(?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(=)\\s*+(\\basync\\b)?(?=(\\s*+<(?:(?>[^<>]+)|\\g<-1>)*>)?\\s*+(\\((?>[^()\"']|(\"(\\\\.|[^\"])*+\")++|('(\\\\.|[^'])*+')++|\\g<-5>)*+\\))\\s*+(((?::(?:(\\s*+(&|\\|)?(\\s*%checks\\b|\\s*(\\((?>[^()\"']|(\"(\\\\.|[^\"])*+\")++|('(\\\\.|[^'])*+')++|\\g<-5>)*+\\))+|\\s*+((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)|(<(?:(?>(?<==)>|[^<>]+)|\\g<-1>)*>)+|\\s*+({(?:(?>[^{}]+)|\\g<-1>)*\\})|\\s*+(\\[(?:(?>[^\\[\\]]+)|\\g<-1>)*\\])|\\s*+(\\s*([\"']).*?\\k<-1>(?<!\\\\.))|\\s*[+-x]?[0-9A-Fa-f]+))|(?:\\s*+/\\*.*?\\*/))*+)*)|(?:/\\*.*?\\*/))\\s*=>)",
          "end": "((?<=})|(?:\\s*(=>)(?!\\s*{)))",
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "entity.name.function.js"
            },
            "3": {
              "name": "keyword.operator.assignment.js"
            },
            "4": {
              "name": "storage.type.js"
            }
          },
          "endCaptures": {
            "2": {
              "name": "storage.type.function.arrow.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype"
            },
            {
              "include": "#fat-arrow-braced-body"
            }
          ]
        },
        {
          "comment": "e.g. play = arg => { }",
          "name": "meta.function.arrow.js",
          "match": "\\s*+(\\#?)(\\b(?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(=)\\s*+\\s*+(\\basync\\b)?\\s*+(((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+))\\s*(=>)",
          "captures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "entity.name.function.js"
            },
            "3": {
              "name": "keyword.operator.assignment.js"
            },
            "4": {
              "name": "storage.type.js"
            },
            "5": {
              "name": "meta.function.parameters.js"
            },
            "6": {
              "name": "variable.other.readwrite.js"
            },
            "7": {
              "name": "storage.type.function.arrow.js"
            }
          }
        }
      ]
    },
    "literal-async-arrow-function-simple-assignments": {
      "patterns": [
        {
          "comment": "e.g. play = (args) => { }",
          "name": "meta.function.arrow.js",
          "begin": "\\s*+(\\#?)(\\b(?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(=)\\s*+(?:(\\basync)\\s+)(?=\\s*(<(?:(?>(?<==)>|[^<>]+)|\\g<-1>)*>)?\\s*+\\()",
          "end": "((?<=})|(?:\\s*(=>)(?!\\s*{)))",
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "entity.name.function.js"
            },
            "3": {
              "name": "keyword.operator.assignment.js"
            },
            "4": {
              "name": "storage.type.js"
            }
          },
          "endCaptures": {
            "2": {
              "name": "storage.type.function.arrow.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype"
            },
            {
              "include": "#fat-arrow-braced-body"
            }
          ]
        }
      ]
    },
    "literal-method": {
      "patterns": [
        {
          "comment": "e.g. play<T,T>(arg1, arg2): Type<T> { }",
          "name": "meta.function.method.js",
          "begin": "(?<!:)(?<=^|;|,|@@|}|{)\\s*+(\\bstatic\\b)?\\s*+(\\basync\\b)?\\s*+(\\*?)\\s*+(?<!\\.)(\\#?)(?!\\bstatic\\b)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)(?=\\s*+(<(?:(?>(?<==)>|[^<>]+)|\\g<-1>)*>)?\\s*(\\())",
          "end": "(?<=})|(?=;|}|,)",
          "beginCaptures": {
            "1": {
              "name": "storage.modifier.js"
            },
            "2": {
              "name": "storage.type.js"
            },
            "3": {
              "name": "keyword.generator.asterisk.js"
            },
            "4": {
              "name": "keyword.operator.private.js"
            },
            "5": {
              "name": "entity.name.function.method.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype"
            },
            {
              "include": "#curly-brackets"
            },
            {
              "include": "#class-body"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "comment": "e.g. 'play'<T,T>(arg1, arg2): Type<T> { }",
          "name": "meta.function.method.js",
          "begin": "(?<!:)(?<=^|;|,|@@|}|{)\\s*+(\\bstatic\\b)?\\s*+(\\basync\\b)?\\s*+(\\*?)\\s*+(?<!\\.)(('|\")([^\"']*)(\\k<-3>))(?=\\s*+(<(?:(?>(?<==)>|[^<>]+)|\\g<-1>)*>)?(\\())",
          "end": "(?<=})|(?=;|}|,)",
          "beginCaptures": {
            "1": {
              "name": "storage.modifier.js"
            },
            "2": {
              "name": "storage.type.js"
            },
            "3": {
              "name": "keyword.generator.asterisk.js"
            },
            "4": {
              "name": "entity.name.function.method.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype"
            },
            {
              "include": "#curly-brackets"
            },
            {
              "include": "#class-body"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "comment": "e.g. [expression]<T,T>(arg1, arg2): Type<T> { } or 'literal-text'<T,T>(arg1, arg2)",
          "name": "meta.function.method.js",
          "begin": "(?<!:)(?<=^|;|,|@@|}|{)\\s*+(\\bstatic\\b)?\\s*+(\\basync\\b)?\\s*+(\\*?)\\s*+(?=((\\[(?:(?>[^\\[\\]]+)|\\g<-1>)*\\]))\\s*+(<(?:(?>(?<==)>|[^<>]+)|\\g<-1>)*>)?\\s*+(\\())",
          "end": "(?<=})|(?=;|}|,)",
          "beginCaptures": {
            "1": {
              "name": "storage.modifier.js"
            },
            "2": {
              "name": "storage.type.js"
            },
            "3": {
              "name": "keyword.generator.asterisk.js"
            },
            "4": {
              "name": "entity.name.function.method.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype"
            },
            {
              "include": "#square-brackets"
            },
            {
              "include": "#curly-brackets"
            },
            {
              "include": "#class-body"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "comment": "getter/setter",
          "name": "meta.accessor.js",
          "begin": "(?<=^|;|,|@@|}|{)\\s*+\\b(?:(static)\\s+)?(get|set)\\s++(\\#?)(?!\\bstatic\\b)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)(?=\\s*+\\()",
          "end": "(?<=})|(?=;|}|,)",
          "beginCaptures": {
            "1": {
              "name": "storage.modifier.js"
            },
            "2": {
              "name": "storage.type.accessor.js"
            },
            "3": {
              "name": "keyword.operator.private.js"
            },
            "4": {
              "name": "entity.name.function.accessor.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype"
            },
            {
              "include": "#curly-brackets"
            },
            {
              "include": "#class-body"
            },
            {
              "include": "$self"
            }
          ]
        },
        {
          "comment": "getter/setter set [expresion]() or get 'literal-text'()",
          "name": "meta.accessor.js",
          "begin": "(?<=^|;|,|@@|}|{)\\s*+\\b(?:(static)\\s+)?(get|set)\\s+(?=((\\[(?:(?>[^\\[\\]]+)|\\g<-1>)*\\])|\\s*+(((')((?:[^']|\\\\')*)('))|\\s*+((\")((?:[^\"]|\\\\\")*)(\"))))\\s*+(\\())",
          "end": "\\s*(?={)|(?=;|}|,)",
          "beginCaptures": {
            "1": {
              "name": "storage.modifier.js"
            },
            "2": {
              "name": "storage.type.accessor.js"
            },
            "3": {
              "name": "entity.name.function.accessor.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype-parse-array"
            },
            {
              "include": "#literal-string"
            },
            {
              "include": "#flowtype"
            },
            {
              "include": "#square-brackets"
            },
            {
              "include": "#class-body"
            },
            {
              "include": "$self"
            }
          ]
        }
      ]
    },
    "literal-regexp": {
      "patterns": [
        {
          "name": "string.regexp.js",
          "begin": "(?<=^|\\.|\\(|,|{|}|\\[|;|,|<|>|<=|>=|==|!=|===|!==|\\+|-|\\*|%|\\+\\+|--|<<|>>|>>>|&|\\||\\^|!|~|&&|\\|\\||\\?|:|=|\\+=|-=|\\*=|%=|<<=|>>=|>>>=|&=|\\|=|\\^=|/|/=|\\Wnew|\\Wdelete|\\Wvoid|\\Wtypeof|\\Winstanceof|\\Win|\\Wdo|\\Wreturn|\\Wcase|\\Wthrow|^new|^delete|^void|^typeof|^instanceof|^in|^do|^return|^case|^throw)\\s*+(/)(?!\\*|/)(?=.*/[gimuy]*\\s*($|[,;)}\\]]|\\.[$_A-Za-z]))",
          "end": "(/)([gimyu]*)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.definition.string.begin.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.definition.string.end.js"
            },
            "2": {
              "name": "keyword.other.js"
            }
          },
          "patterns": [
            {
              "include": "source.regexp.flow"
            }
          ]
        }
      ]
    },
    "literal-string": {
      "patterns": [
        {
          "contentName": "string.quoted.single.js",
          "begin": "\\s*+(('))",
          "end": "\\s*+(?:(('))|(\n))",
          "beginCaptures": {
            "1": {
              "name": "string.quoted.single.js"
            },
            "2": {
              "name": "punctuation.definition.string.begin.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "string.quoted.single.js"
            },
            "2": {
              "name": "punctuation.definition.string.end.js"
            },
            "3": {
              "name": "invalid.illegal.newline.js"
            }
          },
          "patterns": [
            {
              "include": "#string-content"
            }
          ]
        },
        {
          "contentName": "string.quoted.double.js",
          "begin": "\\s*+((\"))",
          "end": "\\s*+(?:((\"))|(\n))",
          "beginCaptures": {
            "1": {
              "name": "string.quoted.double.js"
            },
            "2": {
              "name": "punctuation.definition.string.begin.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "string.quoted.double.js"
            },
            "2": {
              "name": "punctuation.definition.string.end.js"
            },
            "3": {
              "name": "invalid.illegal.newline.js"
            }
          },
          "patterns": [
            {
              "include": "#string-content"
            }
          ]
        }
      ]
    },
    "literal-module": {
      "patterns": [
        {
          "include": "#literal-module-import"
        },
        {
          "include": "#literal-module-export"
        }
      ]
    },
    "literal-module-import": {
      "patterns": [
        {
          "name": "meta.function-call.with-arguments.js",
          "begin": "(?<!\\.)\\s*+(import)(?=\\()",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "keyword.control.module.js"
            }
          },
          "patterns": [
            {
              "include": "#round-brackets"
            }
          ]
        },
        {
          "begin": "(?<!\\.)\\s*+\\b(import)(?!\\s*:)\\b",
          "end": "\\s*(?:(?:(\\bfrom\\b)?+\\s++(('|\")([^\"']*)(\\k<-3>)))|(?=;|^\\s*\\b(if|switch|case|break|default|try|var|let|const|static|function|return|class|do|for|while|debugger|export|import|yield|type|declare|interface|enum)\\b|\\)|}))",
          "beginCaptures": {
            "1": {
              "name": "keyword.control.module.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "keyword.control.module.js"
            },
            "2": {
              "name": "string.quoted.module.js"
            },
            "3": {
              "name": "punctuation.definition.string.begin.js"
            },
            "5": {
              "name": "punctuation.definition.string.end.js"
            }
          },
          "patterns": [
            {
              "match": "\\s*\\b(default)\\b",
              "captures": {
                "1": {
                  "name": "keyword.control.module.js"
                }
              }
            },
            {
              "include": "#literal-module-typeof"
            },
            {
              "include": "#literal-module-as"
            },
            {
              "name": "keyword.operator.module.all.js",
              "match": "\\s*\\*"
            },
            {
              "include": "#literal-module-brackets"
            },
            {
              "include": "#literal-variable"
            },
            {
              "include": "#comments"
            },
            {
              "include": "#literal-comma"
            }
          ]
        }
      ]
    },
    "literal-module-export": {
      "patterns": [
        {
          "comment": "e.g. export let variable =, export type a=",
          "match": "(?<!\\.)\\s*+\\b(export)(?!\\s*:)\\b(?=\\s++(const|let|opaque|var|type|typeof)\\s++(?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+}))",
          "captures": {
            "1": {
              "name": "keyword.control.module.js"
            }
          }
        },
        {
          "comment": "export {  or  export * or export var or export type {} from module",
          "begin": "(?<!\\.)\\s*+\\b(export)\\b\\s*(\\btype\\b)?(?=\\s++({|\\*|((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)(\\s++from\\b|\\s*,)))",
          "end": "\\s*(?:(?:(\\bfrom\\b)?+\\s++(('|\")([^\"']*)(\\k<-3>)))|(?=;|^\\s*\\b(if|switch|case|break|default|try|var|let|const|static|function|return|class|do|for|while|debugger|export|import|yield|type|declare|interface|enum)\\b|\\)|}))",
          "beginCaptures": {
            "1": {
              "name": "keyword.control.module.js"
            },
            "2": {
              "name": "keyword.control.module.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "keyword.control.module.js"
            },
            "2": {
              "name": "string.quoted.module.js"
            },
            "3": {
              "name": "punctuation.definition.string.begin.js"
            },
            "5": {
              "name": "punctuation.definition.string.end.js"
            }
          },
          "patterns": [
            {
              "include": "#literal-module-as"
            },
            {
              "name": "keyword.operator.module.all.js",
              "match": "\\s*\\*"
            },
            {
              "include": "#literal-module-brackets"
            },
            {
              "include": "#literal-variable"
            },
            {
              "include": "#comments"
            },
            {
              "include": "#literal-comma"
            }
          ]
        },
        {
          "comment": "trap expressions among - export function* () {}",
          "match": "(?<!\\.)\\s*+\\b(export|default)(?!\\s*:)\\b",
          "captures": {
            "1": {
              "name": "keyword.control.module.js"
            }
          }
        }
      ]
    },
    "literal-module-as": {
      "match": "\\s*+(?:(\\*)|(\\bdefault\\b))?\\s*+(\\bas\\b)\\s*+(?:(\\*)|(\\bdefault\\b))?",
      "captures": {
        "1": {
          "name": "keyword.operator.module.all.js"
        },
        "2": {
          "name": "keyword.control.module.js"
        },
        "3": {
          "name": "keyword.control.module.reference.js"
        },
        "4": {
          "name": "keyword.operator.module.all.js"
        },
        "5": {
          "name": "keyword.control.module.js"
        }
      }
    },
    "literal-module-brackets": {
      "patterns": [
        {
          "begin": "\\s*+(?:({)|(\\[))",
          "end": "\\s*(?:(\\})|(\\]))",
          "beginCaptures": {
            "1": {
              "name": "meta.brace.curly.js"
            },
            "2": {
              "name": "meta.brace.square.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "meta.brace.curly.js"
            },
            "2": {
              "name": "meta.brace.square.js"
            }
          },
          "patterns": [
            {
              "name": "keyword.operator.module.all.js",
              "match": "\\*"
            },
            {
              "include": "#literal-module-typeof"
            },
            {
              "include": "#literal-module-as"
            },
            {
              "include": "#literal-module-brackets"
            },
            {
              "include": "#literal-variable"
            },
            {
              "include": "#literal-string"
            },
            {
              "include": "#comments"
            },
            {
              "include": "#literal-comma"
            }
          ]
        }
      ]
    },
    "literal-module-typeof": {
      "match": "\\s*\\b(typeof|type)\\b\\s++(?={|\\*|(?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+}))(?!\\b(instanceof|in|as)\\b|,)",
      "captures": {
        "1": {
          "name": "keyword.other.typedef.flowtype"
        }
      }
    },
    "literal-variable": {
      "patterns": [
        {
          "comment": "e.g. CONSTANT",
          "match": "\\s*+(\\#?)(_++[$_\\p{Lu}\\p{N}]++|[\\p{Lu}][$_\\p{Lu}\\p{N}]*+)(?!\\p{Ll})",
          "captures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "variable.other.constant.js"
            }
          }
        },
        {
          "comment": "e.g. dollar vars",
          "match": "\\s*+(\\#?)(\\$[$\\w]*)",
          "captures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "variable.other.dollar.js"
            }
          }
        },
        {
          "comment": "e.g. Class.property",
          "name": "meta.property.class.js",
          "match": "\\s*+(\\#?)\\b((?:[$\\p{Lu}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(?:(\\?\\.)|(\\.))\\s*+(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)",
          "captures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "variable.other.class.js"
            },
            "3": {
              "name": "keyword.operator.existential.js"
            },
            "4": {
              "name": "keyword.operator.accessor.js"
            },
            "5": {
              "name": "keyword.operator.private.js"
            },
            "6": {
              "name": "variable.other.property.static.js"
            }
          }
        },
        {
          "comment": "e.g. obj.property",
          "name": "variable.other.object.js",
          "match": "(?<!\\.)\\s*+(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(?=[\\[\\.])",
          "captures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "variable.other.object.js"
            }
          }
        },
        {
          "comment": "e.g. obj.property",
          "name": "meta.property.object.js",
          "match": "(?<=\\.)\\s*+(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)",
          "captures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "variable.other.property.js"
            }
          }
        },
        {
          "match": "\\s*+(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)",
          "captures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "variable.other.readwrite.js"
            }
          }
        }
      ]
    },
    "literal-variable-flowtype": {
      "patterns": [
        {
          "comment": "Assume this is a flow typed var",
          "begin": "(?<=^|,|\\()\\s*+(?=(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*\\??\\s*:((?=::)|(?!:)))",
          "end": "\\s*(?=,|\\))",
          "patterns": [
            {
              "include": "#flowtype-variable"
            }
          ]
        },
        {
          "comment": "Assume this is a flow typed var",
          "begin": "(?<=^|,|\\()\\s*+(?=\"[^\"]\"\\s*:)",
          "end": "\\s*(?>=|\\))",
          "patterns": [
            {
              "include": "#flowtype-variable"
            }
          ]
        },
        {
          "comment": "Assume this is a flow typed var",
          "begin": "(?<=^|,|\\()\\s*+(?='[^']'\\s*:)",
          "end": "\\s*(?>=|\\))",
          "patterns": [
            {
              "include": "#flowtype-variable"
            }
          ]
        }
      ]
    },
    "literal-prototype": {
      "patterns": [
        {
          "comment": "e.g. Sound.prototype",
          "name": "meta.prototype.access.js",
          "match": "\\s*+(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)(?:(\\?\\.)|(\\.))(prototype)\\b",
          "captures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "entity.name.class.js"
            },
            "3": {
              "name": "keyword.operator.existential.js"
            },
            "4": {
              "name": "keyword.operator.accessor.js"
            },
            "5": {
              "name": "variable.language.prototype.js"
            }
          }
        },
        {
          "comment": "e.g. Sound.prototype = { }",
          "name": "meta.prototype.declaration.js",
          "match": "\\s*+(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)(?:(\\?\\.)|(\\.))(prototype)\\s*+=\\s*+",
          "captures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "entity.name.class.js"
            },
            "3": {
              "name": "keyword.operator.existential.js"
            },
            "4": {
              "name": "keyword.operator.accessor.js"
            },
            "5": {
              "name": "variable.language.prototype.js"
            }
          }
        }
      ]
    },
    "es7-decorators": {
      "patterns": [
        {
          "comment": "Look for a @identifier start If unicode start uppercase e.g. @A class it as a class ",
          "begin": "(?<!@)\\s*+(?:(@)(\\#?)(?:((?:[\\p{Lu}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)|((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)))",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.decorator.js"
            },
            "2": {
              "name": "keyword.operator.private.js"
            },
            "3": {
              "name": "entity.name.class.decorator.js"
            },
            "4": {
              "name": "variable.other.readwrite.decorator.js"
            }
          },
          "patterns": [
            {
              "commnent": "decorator .property or .method which may be on a different line",
              "begin": "\\s*(?:(\\?\\.)|(\\.))",
              "end": "\\s*(\\#?)(?:((?:[\\p{Lu}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)|((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+))",
              "beginCaptures": {
                "1": {
                  "name": "keyword.operator.existential.js"
                },
                "2": {
                  "name": "keyword.operator.accessor.js"
                }
              },
              "endCaptures": {
                "1": {
                  "name": "keyword.operator.private.js"
                },
                "2": {
                  "name": "entity.name.class.decorator.js"
                },
                "3": {
                  "name": "variable.other.property.decorator.js"
                }
              },
              "patterns": [
                {
                  "include": "#comments"
                }
              ]
            },
            {
              "comment": "arguments for decorators",
              "include": "#round-brackets"
            },
            {
              "comment": "method that always follow decorators such as play<T,T>(arg1, arg2): Type<T> { }",
              "name": "meta.function.method.js",
              "begin": "(?:(?<=^|;)|(?=\\s))\\s*+(\\bstatic\\b)?\\s*+(\\basync\\b)?\\s*+(\\*?)\\s*+(?<!\\.)(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(?=(<(?:(?>(?<==)>|[^<>]+)|\\g<-1>)*>)?(\\())",
              "end": "(?<=})|(?=;|}|,)",
              "beginCaptures": {
                "1": {
                  "name": "storage.modifier.js"
                },
                "2": {
                  "name": "storage.type.js"
                },
                "3": {
                  "name": "keyword.generator.asterisk.js"
                },
                "4": {
                  "name": "keyword.operator.private.js"
                },
                "5": {
                  "name": "entity.name.function.method.js"
                }
              },
              "patterns": [
                {
                  "include": "#flowtype"
                },
                {
                  "include": "#curly-brackets"
                },
                {
                  "include": "#class-body"
                },
                {
                  "include": "$self"
                }
              ]
            },
            {
              "include": "#comments"
            },
            {
              "match": "\\s*\n"
            }
          ]
        }
      ]
    },
    "es7-function-bind": {
      "patterns": [
        {
          "comment": "https://github.com/zenparsing/es-function-bind#examples",
          "match": "\\s*(::)",
          "captures": {
            "1": {
              "name": "keyword.operator.accessor.js"
            }
          }
        }
      ]
    },
    "esnext-pipeline": {
      "patterns": [
        {
          "begin": "\\s*(\\|>)(?=\\s*(\\#?)(((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\??\\.?\\#?)++\\s*([^(]|$|;))",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.pipeline.js"
            }
          },
          "patterns": [
            {
              "match": "(?<=\\|>)\\s*(?!\\b(if|switch|case|break|default|try|var|let|const|static|function|return|class|do|for|while|debugger|export|import|yield|async|await|enum)\\b)(\\#?)(((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+))(?!\\?|\\.)",
              "captures": {
                "2": {
                  "name": "keyword.operator.private.js"
                },
                "3": {
                  "name": "meta.function-call.without-arguments.js"
                },
                "4": {
                  "name": "entity.name.function.js"
                }
              }
            },
            {
              "match": "\\s*(?!\\b(if|switch|case|break|default|try|var|let|const|static|function|return|class|do|for|while|debugger|export|import|yield|async|await|enum)\\b)(\\#?)(((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+))(?!\\?|\\.)",
              "captures": {
                "2": {
                  "name": "keyword.operator.private.js"
                },
                "3": {
                  "name": "meta.method-call.without-arguments.js"
                },
                "4": {
                  "name": "entity.name.function.js"
                }
              }
            },
            {
              "match": "\\s*(?!\\b(if|switch|case|break|default|try|var|let|const|static|function|return|class|do|for|while|debugger|export|import|yield|async|await|enum)\\b)(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)(\\??)(\\.?)",
              "captures": {
                "2": {
                  "name": "keyword.operator.private.js"
                },
                "3": {
                  "name": "variable.other.object.js"
                },
                "4": {
                  "name": "keyword.operator.existential.js"
                },
                "5": {
                  "name": "keyword.operator.accessor.js"
                }
              }
            },
            {
              "include": "#comments"
            }
          ]
        },
        {
          "match": "\\s*(\\|>)",
          "captures": {
            "1": {
              "name": "keyword.operator.pipeline.js"
            }
          }
        }
      ]
    },
    "enum-declaration": {
      "name": "meta.enum.declaration.flowtype",
      "begin": "(?<!\\.)\\s*+\\b(enum)\\s+([_$[:alpha:]][_$[:alnum:]]*)(?:\\s+(of)\\s+(boolean|string|symbol|number))?",
      "beginCaptures": {
        "1": {
          "name": "storage.type.enum.flowtype"
        },
        "2": {
          "name": "entity.name.type.enum.flowtype"
        },
        "3": {
          "name": "meta.enum.of.flowtype"
        },
        "4": {
          "name": "support.type.builtin.primitive.flowtype"
        }
      },
      "end": "(?<=\\})",
      "patterns": [
        {
          "include": "#comments"
        },
        {
          "begin": "\\{",
          "beginCaptures": {
            "0": {
              "name": "meta.brace.curly.js"
            }
          },
          "end": "\\}",
          "endCaptures": {
            "0": {
              "name": "meta.brace.curly.js"
            }
          },
          "patterns": [
            {
              "include": "#comments"
            },
            {
              "begin": "([_$[:alpha:]][_$[:alnum:]]*)(?:\\s*(=))?\\s*",
              "beginCaptures": {
                "1": {
                  "name": "variable.other.enummember.flowtype"
                },
                "2": {
                  "name": "keyword.operator.assignment.js"
                }
              },
              "end": "(?=,|\\}|$)",
              "patterns": [
                {
                  "include": "#comments"
                },
                {
                  "include": "#literal-string"
                },
                {
                  "include": "#literal-number"
                },
                {
                  "match": "\\b(?:(true)|(false))\\b",
                  "captures": {
                    "1": {
                      "name": "constant.language.boolean.true.js"
                    },
                    "2": {
                      "name": "constant.language.boolean.false.js"
                    }
                  }
                }
              ]
            },
            {
              "include": "#literal-comma"
            }
          ]
        }
      ]
    },
    "jsx": {
      "comment": "Avoid < operator expressions as best we can using Zertosh's regex",
      "patterns": [
        {
          "begin": "(?<=\\(|{|\\[|,|&&|\\|\\||\\?|:|=|=>|\\Wreturn|^return|\\Wyield|^yield|\\Wdefault|\\Wvoid|^void|^)\\s*+(?=<[$_\\p{L}]|<\\s*>)",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "patterns": [
            {
              "include": "#jsx-tag-element-name"
            }
          ]
        }
      ]
    },
    "jsx-tag-element-name": {
      "patterns": [
        {
          "comment": "JSX Fragment",
          "name": "meta.tag.jsx",
          "contentName": "JSXAttrs",
          "begin": "\\s*+(<)\\s*(?=>)",
          "end": "(?<=</)(>)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.definition.tag.jsx"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.definition.tag.jsx"
            }
          },
          "patterns": [
            {
              "include": "#jsx-tag-termination"
            }
          ]
        },
        {
          "comment": "Tags that end > are trapped in #jsx-tag-termination",
          "name": "meta.tag.jsx",
          "contentName": "JSXAttrs",
          "begin": "\\s*+(<)((\\p{Ll}[\\p{Ll}0-9]*)|((?:[$_\\p{L}\\p{Nl}][$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}-]*?:)?+(?:[$_\\p{L}\\p{Nl}](?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\.-](?<!\\.\\.))*+)+))(?=[ />\\s])(?![:])(?<!\\.|:)",
          "end": "\\s*(?<=</)((\\4)|\\2)(>)|(/>)|((?<=</)[\\S ]*?)>",
          "beginCaptures": {
            "1": {
              "name": "punctuation.definition.tag.jsx"
            },
            "2": {
              "name": "entity.name.tag.open.jsx"
            },
            "4": {
              "name": "support.class.component.open.jsx"
            }
          },
          "endCaptures": {
            "1": {
              "name": "entity.name.tag.close.jsx"
            },
            "2": {
              "name": "support.class.component.close.jsx"
            },
            "3": {
              "name": "punctuation.definition.tag.jsx"
            },
            "4": {
              "name": "punctuation.definition.tag.jsx"
            },
            "5": {
              "name": "invalid.illegal.termination.jsx"
            }
          },
          "patterns": [
            {
              "include": "#jsx-tag-termination"
            },
            {
              "include": "#jsx-tag-attributes"
            }
          ]
        }
      ]
    },
    "jsx-tag-termination": {
      "patterns": [
        {
          "comment": "uses non consuming search for </ in </tag>",
          "contentName": "JSXNested",
          "begin": "(>)",
          "end": "(</)",
          "beginCaptures": {
            "0": {
              "name": "punctuation.definition.tag.jsx"
            },
            "1": {
              "name": "JSXStartTagEnd"
            }
          },
          "endCaptures": {
            "0": {
              "name": "punctuation.definition.tag.jsx"
            },
            "1": {
              "name": "JSXEndTagStart"
            }
          },
          "patterns": [
            {
              "include": "#jsx-evaluated-code"
            },
            {
              "include": "#jsx-entities"
            },
            {
              "include": "#jsx-tag-element-name"
            }
          ]
        }
      ]
    },
    "jsx-tag-attributes": {
      "patterns": [
        {
          "include": "#jsx-attribute-name"
        },
        {
          "include": "#jsx-assignment"
        },
        {
          "include": "#jsx-string-double-quoted"
        },
        {
          "include": "#jsx-string-single-quoted"
        },
        {
          "include": "#jsx-evaluated-code"
        },
        {
          "include": "#jsx-tag-element-name"
        },
        {
          "include": "#comments"
        }
      ]
    },
    "jsx-spread-attribute": {
      "patterns": [
        {
          "comment": "Spread attribute { ... AssignmentExpression }",
          "match": "(?<!\\.)\\.\\.\\.",
          "name": "keyword.operator.spread.jsx"
        }
      ]
    },
    "jsx-attribute-name": {
      "patterns": [
        {
          "comment": "look for attribute name",
          "match": "(?<!\\S)([$_\\p{L}](?:[$.\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}-](?<!\\.\\.))*+)(?<!\\.)(?=//|/\\*|=|\\s|>|/>)",
          "captures": {
            "0": {
              "name": "entity.other.attribute-name.jsx"
            }
          }
        }
      ]
    },
    "jsx-assignment": {
      "patterns": [
        {
          "comment": "look for attribute assignment",
          "name": "keyword.operator.assignment.jsx",
          "match": "=(?=\\s*(?:'|\"|{|/\\*|<|//|\\n))"
        }
      ]
    },
    "jsx-string-double-quoted": {
      "name": "string.quoted.double.js",
      "begin": "\"",
      "end": "\"(?<!\\\\\")",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.string.begin.jsx"
        }
      },
      "endCaptures": {
        "0": {
          "name": "punctuation.definition.string.end.jsx"
        }
      },
      "patterns": [
        {
          "include": "#jsx-entities"
        }
      ]
    },
    "jsx-string-single-quoted": {
      "name": "string.quoted.single.js",
      "begin": "'",
      "end": "'(?<!\\\\')",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.string.begin.jsx"
        }
      },
      "endCaptures": {
        "0": {
          "name": "punctuation.definition.string.end.jsx"
        }
      },
      "patterns": [
        {
          "include": "#jsx-entities"
        }
      ]
    },
    "jsx-evaluated-code": {
      "patterns": [
        {
          "name": "meta.embedded.expression.js",
          "contentName": "source.js",
          "begin": "{",
          "end": "}",
          "beginCaptures": {
            "0": {
              "name": "punctuation.section.embedded.begin.jsx"
            }
          },
          "endCaptures": {
            "0": {
              "name": "punctuation.section.embedded.end.jsx"
            }
          },
          "patterns": [
            {
              "include": "#jsx-string-double-quoted"
            },
            {
              "include": "#jsx-string-single-quoted"
            },
            {
              "include": "#jsx-spread-attribute"
            },
            {
              "include": "#core"
            }
          ]
        }
      ]
    },
    "jsx-entities": {
      "patterns": [
        {
          "comment": "Embeded HTML entities &blah",
          "match": "(&)([a-zA-Z0-9]+|#[0-9]+|#x[0-9a-fA-F]+)(;)",
          "captures": {
            "0": {
              "name": "constant.character.entity.jsx"
            },
            "1": {
              "name": "punctuation.definition.entity.jsx"
            },
            "2": {
              "name": "entity.name.tag.html.jsx"
            },
            "3": {
              "name": "punctuation.definition.entity.jsx"
            }
          }
        },
        {
          "comment": "Entity with & and invalid name",
          "match": "&\\s*+;",
          "name": "invalid.illegal.bad-ampersand.jsx"
        }
      ]
    },
    "flowtype": {
      "patterns": [
        {
          "include": "#comments"
        },
        {
          "include": "#flowtype-polymorphs"
        },
        {
          "include": "#flowtype-bracketed-args"
        },
        {
          "include": "#flowtype-return"
        }
      ]
    },
    "flowtype-trap": {
      "comment": "traps flowtype vars that aren't caught normally - e.g. multi-line arrow funcs",
      "patterns": [
        {
          "begin": "(?<=\\))\\s*(?=:)",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "patterns": [
            {
              "include": "#flowtype-return"
            }
          ]
        },
        {
          "begin": "\\s*:(?!:)",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "patterns": [
            {
              "include": "#flowtype-parse-types"
            }
          ]
        }
      ]
    },
    "flowtype-return": {
      "patterns": [
        {
          "comment": "maybe an issue if a object literal is returned and the start of func block isn't on same line!",
          "begin": "(?<=\\))\\s*+(:)((?=::)|(?!:))",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "punctuation.type.flowtype"
            }
          },
          "patterns": [
            {
              "include": "#flowtype-predicate"
            },
            {
              "include": "#flowtype-parse-types"
            }
          ]
        },
        {
          "include": "#flowtype-predicate"
        }
      ]
    },
    "flowtype-predicate": {
      "comment": "flow predicate checks",
      "begin": "\\s*+(?<=\\s)(%checks)\\b",
      "end": "(?=.)",
      "applyEndPatternLast": 1,
      "beginCaptures": {
        "1": {
          "name": "entity.name.function.predicate.flowtype"
        }
      },
      "patterns": [
        {
          "include": "#round-brackets"
        }
      ]
    },
    "flowtype-variable": {
      "patterns": [
        {
          "comment": "e.g. let a: ()=>null  =  function() {return null}",
          "match": "(?<!\\.)\\s*+(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(\\??)\\s*+(?=:\\s*([$_\\p{L}](?:[$.\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}])*+)?\\s*(<(?:(?>(?<==)>|[^<>]+)|\\g<-1>)*>)?\\s*(\\bFunction\\b|(\\((?>[^()\"']|(\"(\\\\.|[^\"])*+\")++|('(\\\\.|[^'])*+')++|\\g<-5>)*+\\))\\s*=>|\\(\\s*$))",
          "captures": {
            "1": {
              "name": "keyword.operator.private.js"
            },
            "2": {
              "name": "storage.type.function.js"
            },
            "3": {
              "name": "keyword.operator.optional.parameter.flowtype"
            }
          }
        },
        {
          "comment": "name of variable spread var with optional ? and optional flowtype :",
          "match": "((?<!\\.)\\.\\.\\.)?\\s*+(\\#?)((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)\\s*+(\\??)\\s*+(?!::)(?=:|=>)",
          "captures": {
            "1": {
              "name": "keyword.operator.spread.js"
            },
            "2": {
              "name": "keyword.operator.private.js"
            },
            "3": {
              "name": "variable.other.readwrite.js"
            },
            "4": {
              "name": "keyword.operator.optional.parameter.flowtype"
            }
          }
        },
        {
          "include": "#flowtype-vars-and-props"
        }
      ]
    },
    "flowtype-vars-and-props": {
      "patterns": [
        {
          "comment": "flowtype optional arg/parameter e.g. protocol? : string",
          "match": "\\s*+(\\?)",
          "captures": {
            "1": {
              "name": "punctuation.type.flowtype"
            }
          }
        },
        {
          "comment": "Type Unions |",
          "match": "\\s*+(\\|)(?<!{\\|)(?!}|>)",
          "captures": {
            "1": {
              "name": "kewyword.operator.union.flowtype"
            }
          }
        },
        {
          "comment": "intersection of types &",
          "match": "\\s*+(\\&)",
          "captures": {
            "1": {
              "name": "kewyword.operator.intersection.flowtype"
            }
          }
        },
        {
          "comment": "typed entity :",
          "begin": "\\s*+(:)((?=::)|(?!:))",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "punctuation.type.flowtype"
            }
          },
          "patterns": [
            {
              "include": "#flowtype-parse-types"
            }
          ]
        },
        {
          "include": "#literal-comma"
        },
        {
          "comment": "An Iterator prefix?",
          "match": "\\s*+(@@)"
        },
        {
          "begin": "\\s*+(=>)",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "storage.type.function.arrow.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype-parse-types"
            }
          ]
        },
        {
          "comment": "varname of|in ",
          "begin": "(?<!let|const|var)(?<=[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}])\\s+(?=\\b(?:of|in)\\b)",
          "end": "\\s*(?=,|;|\\)|}|\\]|\\*/|\\b(?:if|switch|case|break|default|try|var|let|const|static|function|return|class|do|for|while|debugger|export|import|yield|enum)\\b|\\b(async|await)\\b\\s*+(?!=|:)|type\\s+[$\\w]+|declare\\s+[$\\w]+|interface\\s+[$\\w]+)",
          "patterns": [
            {
              "include": "#expression"
            }
          ]
        },
        {
          "comment": "assignment var = or = ",
          "begin": "(?<!:)\\s*+(?=((?:(\\#?)[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)?\\s*=)(?!=>|==)",
          "end": "\\s*(?=,|;|\\)|}|\\]|\\*/|\\b(?:if|switch|case|break|default|try|var|let|const|static|function|return|class|do|for|while|debugger|export|import|yield|enum)\\b|\\b(async|await)\\b\\s*+(?!=|:)|type\\s+[$\\w]+|declare\\s+[$\\w]+|interface\\s+[$\\w]+)",
          "patterns": [
            {
              "include": "#expression"
            }
          ]
        },
        {
          "include": "#flowtype-bracketed-parameters"
        },
        {
          "include": "#flowtype-parse-array"
        },
        {
          "include": "#expression"
        }
      ]
    },
    "flowtype-parse-types": {
      "patterns": [
        {
          "comment": "sometypename of|in ",
          "begin": "(?<=[>$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}])\\s+(?=\\b(?:of|in)\\b)",
          "end": "\\s*(?=,|;|\\)|}|\\]|\\*/|\\b(?:if|switch|case|break|default|try|var|let|const|static|function|return|class|do|for|while|debugger|export|import|yield|enum)\\b|\\b(async|await)\\b\\s*+(?!=|:)|type\\s+[$\\w]+|declare\\s+[$\\w]+|interface\\s+[$\\w]+)",
          "patterns": [
            {
              "include": "#expression"
            }
          ]
        },
        {
          "comment": "Maybe types",
          "match": "\\s*+(\\?)",
          "captures": {
            "1": {
              "name": "keyword.operator.maybe.flowtype"
            }
          }
        },
        {
          "match": "\\s*+\\b(typeof)\\b\\s*+",
          "captures": {
            "1": {
              "name": "keyword.operator.flowtype"
            }
          }
        },
        {
          "comment": "primitive flowtypes",
          "match": "(?!^)\\s*+\\b((?>any|boolean|mixed|number|string|void))\\b",
          "captures": {
            "1": {
              "name": "support.type.builtin.primitive.flowtype"
            }
          }
        },
        {
          "comment": "Built-in Class Types",
          "match": "(?!^)\\s*+\\b((?>WeakSet|WeakMap|URIError|Uint8ClampedArray|Uint8Array|Uint32Array|Uint16Array|TypeError|TypedArray|SyntaxError|Symbol|String|SIMD.Uint8x16|SIMD.Uint32x4|SIMD.Uint16x8|SIMD.Int8x16|SIMD.Int32x4|SIMD.Int16x8|SIMD.Float64x2|SIMD.Float32x4|SIMD.Bool8x16|SIMD.Bool64x2|SIMD.Bool32x4|SIMD.Bool16x8|SIMD|SharedArrayBuffer|Set|RegExp|Reflect|ReferenceError|RangeError|Proxy|Promise|Object|Number|NaN|Math|Map|JSON|Intl.NumberFormat|Intl.DateTimeFormat|Intl.Collator|Intl|InternalError|Int8Array|Int32Array|Int16Array|Infinity|GeneratorFunction|Generator|Function|Float64Array|Float32Array|EvalError|Error|Date|DataView|Boolean|Atomics|ArrayBuffer|Array))\\b",
          "captures": {
            "1": {
              "name": "support.type.builtin.class.flowtype"
            }
          }
        },
        {
          "match": "\\s*+\\b((SIMD)((\\.)(Uint8x16|Uint32x4|Uint16x8|Int8x16|Int32x4|Int16x8|Float64x2|Float32x4|Bool8x16|Bool64x2|Bool32x4|Bool16x8))?)\\b",
          "captures": {
            "2": {
              "name": "support.type.builtin.class.flowtype"
            },
            "4": {
              "name": "keyword.operator.accessor.js"
            },
            "5": {
              "name": "support.type.builtin.class.flowtype"
            }
          }
        },
        {
          "match": "\\s*+\\b((Intl)((\\.)(NumberFormat|DateTimeFormat|Collator))?)\\b",
          "captures": {
            "2": {
              "name": "support.type.builtin.class.flowtype"
            },
            "4": {
              "name": "keyword.operator.accessor.js"
            },
            "5": {
              "name": "support.type.builtin.class.flowtype"
            }
          }
        },
        {
          "include": "#flowtype-polymorphs"
        },
        {
          "comment": "custom Class Types e.g. Abc avoid Abc(",
          "match": "\\s*+([$_[\\p{Lu}\\p{Lt}\\p{Lm}\\p{Lo}]][$.\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}]*+)(?!\\s*+\\()",
          "captures": {
            "1": {
              "name": "support.type.class.flowtype"
            }
          }
        },
        {
          "comment": "custom primitive/var Types e.g. abc avoid abc(",
          "match": "(?!\\s*\\b(if|switch|case|break|default|try|var|let|const|static|function|return|class|do|for|while|debugger|export|import|yield|type|declare|interface|enum)\\b)(?!^)\\s*(?<=\\s|:|&|\\||<)([$_\\p{L}][$.\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}]*+)(?!\\s*+\\()",
          "captures": {
            "2": {
              "name": "support.type.primitive.flowtype"
            }
          }
        },
        {
          "comment": "Type Unions |",
          "match": "\\s*+(\\|)(?<!{\\|)(?!}|>)",
          "captures": {
            "1": {
              "name": "kewyword.operator.union.flowtype"
            }
          }
        },
        {
          "comment": "intersection of types &",
          "match": "\\s*+(\\&)",
          "captures": {
            "1": {
              "name": "kewyword.operator.intersection.flowtype"
            }
          }
        },
        {
          "comment": "as per React declares in flowtype github",
          "match": "\\s*+(\\*)(?!/([^\\*]|$))",
          "captures": {
            "1": {
              "name": "kewyword.operator.existential.flowtype"
            }
          }
        },
        {
          "comment": "types of type marker e.g. <T: number | string>",
          "name": "punctuation.type.flowtype",
          "match": "\\s*+(:)((?=::)|(?!:))",
          "captures": {
            "1": {
              "name": "support.type.builtin.primitive.flowtype"
            }
          }
        },
        {
          "comment": "call back with a form  ) => type",
          "match": "(?<=\\))\\s*+(=>)",
          "captures": {
            "1": {
              "name": "storage.type.function.arrow.js"
            }
          }
        },
        {
          "include": "#literal-string"
        },
        {
          "include": "#literal-number"
        },
        {
          "include": "#flowtype-bracketed-parameters"
        },
        {
          "include": "#flowtype-parse-objects"
        },
        {
          "include": "#flowtype-parse-array"
        },
        {
          "include": "#comments"
        }
      ]
    },
    "flowtype-bracketed-args": {
      "patterns": [
        {
          "comment": "Get parameters within a function/method call",
          "contentName": "meta.function.parameters.js",
          "begin": "(?<!}|return|await|switch|case|while|for|throw)\\s*((\\())",
          "end": "\\s*((\\)))",
          "beginCaptures": {
            "1": {
              "name": "punctuation.definition.parameters.begin.js"
            },
            "2": {
              "name": "meta.brace.round.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.definition.parameters.end.js"
            },
            "2": {
              "name": "meta.brace.round.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype-polymorphs"
            },
            {
              "include": "#flowtype-variable"
            }
          ]
        }
      ]
    },
    "flowtype-bracketed-parameters": {
      "patterns": [
        {
          "comment": "trap balanced parens which are NOT followed by . : => { or /*: ",
          "begin": "\\s*+(?=(\\((?>[^()\"']|(\"(\\\\.|[^\"])*+\")++|('(\\\\.|[^'])*+')++|\\g<-5>)*+\\))\\s*+(?!\\.|:|=>|{|/\\*\\s*:))",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "patterns": [
            {
              "begin": "\\s*(\\()",
              "end": "\\s*(\\))",
              "beginCaptures": {
                "1": {
                  "name": "meta.brace.round.js"
                }
              },
              "endCaptures": {
                "1": {
                  "name": "meta.brace.round.js"
                }
              },
              "patterns": [
                {
                  "include": "#flowtype-parse-types"
                }
              ]
            }
          ]
        },
        {
          "comment": "Get parameters within a function/method call",
          "contentName": "meta.function.parameters.js",
          "begin": "(?<!}|return|await|switch|case|while|for|throw)\\s*((\\())",
          "end": "\\s*((\\)))",
          "beginCaptures": {
            "1": {
              "name": "punctuation.definition.parameters.begin.js"
            },
            "2": {
              "name": "meta.brace.round.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.definition.parameters.end.js"
            },
            "2": {
              "name": "meta.brace.round.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype-polymorphs"
            },
            {
              "include": "#flowtype-variable"
            }
          ]
        }
      ]
    },
    "flowtype-polymorphs": {
      "comment": "Support Bounded Polymorphism http://flowtype.org/blog/2015/03/12/Bounded-Polymorphism.html",
      "patterns": [
        {
          "comment": "Built-in Class Types with elements of type <T>",
          "begin": "\\s*+\\b((?>Array|Class|Map|Promise|Set|WeakMap|WeakSet))\\s*+(<)",
          "end": "\\s*(>)",
          "beginCaptures": {
            "1": {
              "name": "support.type.builtin.class.flowtype"
            },
            "2": {
              "name": "punctuation.flowtype"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.flowtype"
            }
          },
          "patterns": [
            {
              "include": "#literal-comma"
            },
            {
              "match": "\\s*+(\\+|-)",
              "captures": {
                "1": {
                  "name": "support.type.variant.flowtype"
                }
              }
            },
            {
              "include": "#flowtype-parse-types"
            }
          ]
        },
        {
          "comment": "just the polymorph bit like this <K,V>(arg,arg)",
          "begin": "\\s*+(<)",
          "end": "\\s*(>)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.flowtype"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.flowtype"
            }
          },
          "patterns": [
            {
              "include": "#literal-comma"
            },
            {
              "match": "\\s*+(\\+|-)",
              "captures": {
                "1": {
                  "name": "support.type.variant.flowtype"
                }
              }
            },
            {
              "include": "#flowtype-parse-types"
            }
          ]
        }
      ]
    },
    "flowtype-parse-objects": {
      "name": "meta.object.flowtype",
      "comment": "object literal flowtype  preceded by either => : | & ? symbols",
      "begin": "(?<=:|\\||&|\\?|=>|<|\\()\\s*+({)",
      "end": "\\s*(\\})",
      "applyEndPatternLast": 1,
      "beginCaptures": {
        "1": {
          "name": "meta.brace.curly.open.flowtype"
        }
      },
      "endCaptures": {
        "1": {
          "name": "meta.brace.curly.close.flowtype"
        }
      },
      "patterns": [
        {
          "include": "#flowtype-object-property"
        }
      ]
    },
    "flowtype-object-property": {
      "patterns": [
        {
          "comment": "Only these props syntax {| |}",
          "match": "((\\|)(?={|))|(\\s*(\\|)(?=}))",
          "captures": {
            "1": {
              "name": "kewyword.operator.only.flowtype"
            },
            "4": {
              "name": "kewyword.operator.only.flowtype"
            }
          }
        },
        {
          "include": "#literal-method"
        },
        {
          "include": "#comments"
        },
        {
          "include": "#flowtype-variable"
        }
      ]
    },
    "flowtype-parse-array": {
      "comment": "arrays such as [name: string, dob: Date]",
      "begin": "(?<!=|[$_A-Za-z0-9])\\s*+(\\[)",
      "end": "\\s*(\\])",
      "beginCaptures": {
        "1": {
          "name": "meta.brace.square.open.flowtype"
        }
      },
      "endCaptures": {
        "1": {
          "name": "meta.brace.square.end.flowtype"
        }
      },
      "patterns": [
        {
          "comment": "destructring in arrays requires vars parse before types",
          "begin": "\\s*(?=[_$[:alpha:]][_$[:alnum:]]*\\s*[=:])",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "patterns": [
            {
              "include": "#flowtype-variable"
            },
            {
              "include": "#flowtype-parse-types"
            }
          ]
        },
        {
          "include": "#flowtype-parse-types"
        },
        {
          "include": "#flowtype-variable"
        }
      ]
    },
    "flowtype-type-aliases": {
      "patterns": [
        {
          "comment": "type aliases for export but avoid type instaceof or type in operators",
          "begin": "(?<=^|;|\\S)\\s*+\\b(opaque)?\\s*+\\b(type)\\b\\s+(?!(instanceof|in)\\b)(?=[$_A-Za-z{\\[])",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "keyword.other.typedef.flowtype"
            },
            "2": {
              "name": "keyword.other.typedef.flowtype"
            }
          },
          "patterns": [
            {
              "name": "meta.object.flowtype",
              "begin": "\\s*+({)",
              "end": "\\s*(})",
              "captures": {
                "1": {
                  "name": "meta.brace.curly.js"
                }
              },
              "patterns": [
                {
                  "include": "#flowtype-object-property"
                }
              ]
            },
            {
              "include": "#flowtype"
            },
            {
              "include": "#flowtype-parse-types"
            },
            {
              "include": "#comments"
            },
            {
              "include": "#flowtype-function-name"
            },
            {
              "match": "\\s*+(=)(?!=|>)",
              "captures": {
                "1": {
                  "name": "keyword.operator.assignment.js"
                }
              }
            }
          ]
        }
      ]
    },
    "flowtype-interface": {
      "begin": "(?<!\\.)\\s*+\\b(interface)(\\s+|$)",
      "end": "(?<=})",
      "beginCaptures": {
        "1": {
          "name": "keyword.other.interface.flowtype"
        }
      },
      "patterns": [
        {
          "match": "\\s*+\\b((extends))\\b\\s*+",
          "captures": {
            "1": {
              "name": "meta.class.extends.js"
            },
            "2": {
              "name": "storage.type.extends.js"
            }
          }
        },
        {
          "comment": "look for interface names but dont assume uppercase start char",
          "match": "\\s*+((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)",
          "name": "support.type.class.interface.js"
        },
        {
          "include": "#flowtype-polymorphs"
        },
        {
          "begin": "\\s*+({)",
          "end": "\\s*(})",
          "contentName": "meta.class.body.js",
          "beginCaptures": {
            "1": {
              "name": "punctuation.section.class.begin.js"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.section.class.end.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype-literal-method"
            },
            {
              "include": "#class-body"
            }
          ]
        },
        {
          "match": "\\s*(\\.)",
          "captures": {
            "1": {
              "name": "keyword.operator.accessor.js"
            }
          }
        }
      ]
    },
    "flowtype-declare": {
      "patterns": [
        {
          "match": "\\s*+(?<!\\.)\\b(declare)(?=\\s+(function|var|type|interface|opaque|export)\\b)",
          "captures": {
            "1": {
              "name": "keyword.other.declare.flowtype"
            }
          }
        },
        {
          "comment": "declare module.exports:",
          "begin": "\\s*+(?<!\\.)\\b(declare)\\b\\s*+\\b(module)(.)(exports)(:)((?=::)|(?!:))",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "keyword.other.declare.flowtype"
            },
            "2": {
              "name": "storage.type.module.flowtype"
            },
            "3": {
              "name": "keyword.operator.accessor.flowtype"
            },
            "4": {
              "name": "storage.type.module.flowtype"
            },
            "5": {
              "name": "punctuation.type.flowtype"
            }
          },
          "patterns": [
            {
              "include": "#flowtype-parse-objects"
            },
            {
              "include": "#flowtype-parse-types"
            }
          ]
        },
        {
          "comment": "declare modules",
          "begin": "(?<!\\.)\\s*+\\b(declare)\\b\\s*+\\b(module)(\\s|$)",
          "end": "\\s*(?<=})",
          "beginCaptures": {
            "1": {
              "name": "keyword.other.declare.flowtype"
            },
            "2": {
              "name": "storage.type.module.flowtype"
            }
          },
          "patterns": [
            {
              "include": "#flowtype-polymorphs"
            },
            {
              "comment": "look for module names but dont assume uppercase start char",
              "match": "\\s*+((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)",
              "captures": {
                "1": {
                  "name": "entity.name.class.js"
                }
              }
            },
            {
              "comment": "look for module names in quoted string forms",
              "include": "#literal-string"
            },
            {
              "begin": "\\s*+({)",
              "end": "\\s*(})",
              "contentName": "meta.class.body.js",
              "beginCaptures": {
                "1": {
                  "name": "punctuation.section.class.begin.js"
                }
              },
              "endCaptures": {
                "1": {
                  "name": "punctuation.section.class.end.js"
                }
              },
              "patterns": [
                {
                  "include": "#flowtype-keywords"
                },
                {
                  "include": "#flowtype-literal-method"
                },
                {
                  "include": "#class-body"
                }
              ]
            }
          ]
        },
        {
          "comment": "declare classes",
          "begin": "\\s*+(?<!\\.)\\b(declare)\\b\\s*+(\\bexport\\b)?\\s*+\\b(class)\\b",
          "end": "\\s*(?<=})",
          "beginCaptures": {
            "1": {
              "name": "keyword.other.declare.flowtype"
            },
            "2": {
              "name": "keyword.constrol.module.flowtype"
            },
            "3": {
              "name": "storage.type.class.flowtype"
            }
          },
          "patterns": [
            {
              "comment": "look for extends keyword",
              "match": "\\s*+\\b((extends))\\b\\s*+",
              "captures": {
                "1": {
                  "name": "meta.class.extends.js"
                },
                "2": {
                  "name": "storage.type.extends.js"
                }
              }
            },
            {
              "comment": "look for implements keyword",
              "match": "\\s*+\\b((implements))\\b\\s*+",
              "captures": {
                "1": {
                  "name": "meta.class.implements.js"
                },
                "2": {
                  "name": "storage.type.implements.js"
                }
              }
            },
            {
              "comment": "look for mixins keyword",
              "match": "\\s*+\\b((mixins))\\b\\s*+",
              "captures": {
                "1": {
                  "name": "meta.class.extends.js"
                },
                "2": {
                  "name": "storage.type.extends.js"
                }
              }
            },
            {
              "comment": "look for class names but dont assume uppercase start char",
              "match": "\\s*+((?:[$_\\p{L}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)",
              "captures": {
                "1": {
                  "name": "entity.name.class.js"
                }
              }
            },
            {
              "begin": "\\s*+({)",
              "end": "\\s*(})",
              "contentName": "meta.class.body.js",
              "beginCaptures": {
                "1": {
                  "name": "punctuation.section.class.begin.js"
                }
              },
              "endCaptures": {
                "1": {
                  "name": "punctuation.section.class.end.js"
                }
              },
              "patterns": [
                {
                  "include": "#flowtype-literal-method"
                },
                {
                  "include": "#class-body"
                }
              ]
            },
            {
              "include": "#flowtype-polymorphs"
            },
            {
              "include": "#literal-comma"
            },
            {
              "match": "\\s*(\\.)",
              "captures": {
                "1": {
                  "name": "keyword.operator.accessor.js"
                }
              }
            }
          ]
        }
      ]
    },
    "flowtype-literal-method": {
      "comment": "trap methods without a name  e.g.   <Key, Value>(): Map<Key, Value>",
      "begin": "(?<!:)\\s*+(?=(<(?:(?>(?<==)>|[^<>]+)|\\g<-1>)*>)?(\\())",
      "end": "\\s*(?=.)",
      "applyEndPatternLast": 1,
      "beginCaptures": {
        "1": {
          "name": "storage.modifier.js"
        },
        "2": {
          "name": "storage.type.js"
        },
        "3": {
          "name": "keyword.generator.asterisk.js"
        }
      },
      "patterns": [
        {
          "include": "#flowtype"
        }
      ]
    },
    "flowtype-keywords": {
      "patterns": [
        {
          "include": "#flowtype-declare"
        },
        {
          "include": "#flowtype-type-aliases"
        },
        {
          "include": "#flowtype-interface"
        }
      ]
    },
    "flowtype-comments": {
      "patterns": [
        {
          "name": "meta.comments.flowtype",
          "begin": "\\s*+(/\\*)\\s*(::)",
          "end": "\\s*(\\*/)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.definition.comment.js"
            },
            "2": {
              "name": "punctuation.type.flowtype"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.definition.comment.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype-comments-optional-parameter"
            },
            {
              "include": "#literal-module"
            },
            {
              "include": "#flowtype-keywords"
            },
            {
              "include": "#flowtype-predicate"
            },
            {
              "include": "#flowtype-parse-types"
            },
            {
              "include": "#literal-function"
            },
            {
              "include": "#literal-keyword-storage"
            }
          ]
        },
        {
          "name": "meta.comments.flowtype",
          "begin": "\\s*+(/\\*)\\s*(flow-include)\\b",
          "end": "\\s*(\\*/)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.definition.comment.js"
            },
            "2": {
              "name": "keyword.other.flow-include.flowtype"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.definition.comment.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype-comments-optional-parameter"
            },
            {
              "include": "#literal-module"
            },
            {
              "include": "#flowtype-keywords"
            },
            {
              "include": "#flowtype-predicate"
            },
            {
              "include": "#flowtype-parse-types"
            },
            {
              "include": "#literal-function"
            },
            {
              "include": "#literal-keyword-storage"
            }
          ]
        },
        {
          "name": "meta.comments.flowtype",
          "begin": "\\s*+(/\\*)\\s*(:)((?=::)|(?!:))",
          "end": "\\s*(\\*/)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.definition.comment.js"
            },
            "2": {
              "name": "punctuation.type.flowtype"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.definition.comment.js"
            }
          },
          "patterns": [
            {
              "include": "#flowtype-predicate"
            },
            {
              "include": "#flowtype-parse-types"
            }
          ]
        }
      ]
    },
    "flowtype-comments-optional-parameter": {
      "patterns": [
        {
          "match": "(?<=::|flow-include)\\s*(\\?)",
          "captures": {
            "1": {
              "name": "keyword.operator.optional.parameter.flowtype"
            }
          }
        }
      ]
    },
    "fat-arrow": {
      "comment": "trap fat-arrow",
      "patterns": [
        {
          "comment": "match arrow func symbol",
          "begin": "\\s*(=>)",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "beginCaptures": {
            "1": {
              "name": "storage.type.function.arrow.js"
            }
          },
          "patterns": [
            {
              "include": "$self"
            }
          ]
        }
      ]
    },
    "fat-arrow-braced-body": {
      "comment": " => {",
      "begin": "\\s*(=>)\\s*({)",
      "end": "\\s*(})",
      "beginCaptures": {
        "1": {
          "name": "storage.type.function.arrow.js"
        },
        "2": {
          "name": "meta.brace.curly.js"
        }
      },
      "endCaptures": {
        "1": {
          "name": "meta.brace.curly.js"
        }
      },
      "patterns": [
        {
          "include": "$self"
        }
      ]
    },
    "html-template": {
      "comment": "Assume object properties of template: `some html` contain html",
      "begin": "(?:(?:^|(?<=,|{))\\s*\\b((template))\\b\\s*(:)\\s*(`))",
      "end": "\\s*(`)",
      "beginCaptures": {
        "1": {
          "name": "constant.other.object.key.js"
        },
        "2": {
          "name": "string.unquoted.js"
        },
        "3": {
          "name": "punctuation.separator.key-value.js"
        },
        "4": {
          "name": "punctuation.definition.quasi.begin.js"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.quasi.end.js"
        }
      },
      "patterns": [
        {
          "name": "entity.quasi.element.js",
          "begin": "(?<!\\\\)\\${",
          "end": "\\s*}",
          "beginCaptures": {
            "0": {
              "name": "punctuation.quasi.element.begin.js"
            }
          },
          "endCaptures": {
            "0": {
              "name": "punctuation.quasi.element.end.js"
            }
          },
          "patterns": [
            {
              "include": "#expression"
            }
          ]
        }
      ]
    },
    "graphql": {
      "patterns": [
        {
          "include": "#graphql-fragment-definition"
        },
        {
          "include": "#graphql-type-interface"
        },
        {
          "include": "#graphql-enum"
        },
        {
          "include": "#graphql-scalar"
        },
        {
          "include": "#graphql-union"
        },
        {
          "include": "#graphql-schema"
        },
        {
          "include": "#graphql-operation-def"
        },
        {
          "include": "#graphql-comment"
        },
        {
          "include": "#literal-quasi-embedded"
        }
      ]
    },
    "graphql-operation-def": {
      "patterns": [
        {
          "include": "#graphql-query-mutation"
        },
        {
          "include": "#graphql-name"
        },
        {
          "include": "#graphql-variable-definitions"
        },
        {
          "include": "#graphql-directive"
        },
        {
          "include": "#graphql-selection-set"
        }
      ]
    },
    "graphql-fragment-definition": {
      "name": "meta.fragment.graphql",
      "begin": "\\s*(?:(\\bfragment\\b)\\s*(?!\\bon\\b)([_A-Za-z][_0-9A-Za-z]*)\\s*(?:(\\bon\\b)\\s*([_A-Za-z][_0-9A-Za-z]*)))",
      "end": "(?<=})",
      "captures": {
        "1": {
          "name": "keyword.fragment.graphql"
        },
        "2": {
          "name": "entity.name.fragment.graphql"
        },
        "3": {
          "name": "keyword.on.graphql"
        },
        "4": {
          "name": "support.type.graphql"
        }
      },
      "patterns": [
        {
          "include": "#graphql-comment"
        },
        {
          "include": "#graphql-selection-set"
        },
        {
          "include": "#graphql-directive"
        },
        {
          "include": "#graphql-skip-newlines"
        },
        {
          "include": "#literal-quasi-embedded"
        }
      ]
    },
    "graphql-query-mutation": {
      "match": "\\s*\\b(query|mutation)\\b",
      "captures": {
        "1": {
          "name": "keyword.operation.graphql"
        }
      }
    },
    "graphql-type-interface": {
      "name": "meta.type.interface.graphql",
      "begin": "\\s*\\b(?:(extends?)?\\b\\s*\\b(type)|(interface)|(input))\\b\\s*([_A-Za-z][_0-9A-Za-z]*)?",
      "end": "(?=.)",
      "applyEndPatternLast": 1,
      "beginCaptures": {
        "1": {
          "name": "keyword.type.graphql"
        },
        "2": {
          "name": "keyword.type.graphql"
        },
        "3": {
          "name": "keyword.interface.graphql"
        },
        "4": {
          "name": "keyword.input.graphql"
        },
        "5": {
          "name": "support.type.graphql"
        }
      },
      "patterns": [
        {
          "match": "\\s*\\b(implements)\\b\\s*([_A-Za-z][_0-9A-Za-z]*)",
          "captures": {
            "1": {
              "name": "keyword.implements.grapahql"
            },
            "2": {
              "name": "support.type.graphql"
            }
          }
        },
        {
          "include": "#graphql-comment"
        },
        {
          "include": "#graphql-type-object"
        },
        {
          "include": "#literal-quasi-embedded"
        },
        {
          "include": "#graphql-ignore-spaces"
        }
      ]
    },
    "graphql-ignore-spaces": {
      "match": "\\s*"
    },
    "graphql-type-object": {
      "name": "meta.type.object.graphql",
      "begin": "\\s*({)",
      "end": "\\s*(})",
      "beginCaptures": {
        "1": {
          "name": "punctuation.operation.graphql"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.operation.graphql"
        }
      },
      "patterns": [
        {
          "include": "#graphql-object-type"
        },
        {
          "include": "#graphql-comment"
        },
        {
          "include": "#graphql-type-definition"
        },
        {
          "include": "#literal-quasi-embedded"
        }
      ]
    },
    "graphql-type-definition": {
      "comment": "key (optionalArgs): Type",
      "begin": "\\s*([_A-Za-z][_0-9A-Za-z]*)(?=\\s*\\(|:)",
      "end": "(?=\\s*(([_A-Za-z][_0-9A-Za-z]*)\\s*(\\(|:)|(})))|\\s*(,)",
      "beginCaptures": {
        "1": {
          "name": "variable.graphql"
        }
      },
      "endCaptures": {
        "5": {
          "name": "punctuation.comma.graphql"
        }
      },
      "patterns": [
        {
          "include": "#graphql-comment"
        },
        {
          "include": "#graphql-variable-definitions"
        },
        {
          "include": "#graphql-type-object"
        },
        {
          "include": "#graphql-colon"
        },
        {
          "include": "#graphql-input-types"
        },
        {
          "include": "#literal-quasi-embedded"
        }
      ]
    },
    "graphql-schema": {
      "begin": "\\s*\\b(schema)\\b",
      "end": "(?<=})",
      "beginCaptures": {
        "1": {
          "name": "keyword.schema.graphql"
        }
      },
      "patterns": [
        {
          "begin": "\\s*({)",
          "end": "\\s*(})",
          "beginCaptures": {
            "1": {
              "name": "punctuation.operation.graphql"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.operation.graphql"
            }
          },
          "patterns": [
            {
              "begin": "\\s*([_A-Za-z][_0-9A-Za-z]*)(?=\\s*\\(|:)",
              "end": "(?=\\s*(([_A-Za-z][_0-9A-Za-z]*)\\s*(\\(|:)|(})))|\\s*(,)",
              "beginCaptures": {
                "1": {
                  "name": "variable.arguments.graphql"
                }
              },
              "endCaptures": {
                "5": {
                  "name": "punctuation.comma.graphql"
                }
              },
              "patterns": [
                {
                  "match": "\\s*([_A-Za-z][_0-9A-Za-z]*)",
                  "captures": {
                    "1": {
                      "name": "support.type.graphql"
                    }
                  }
                },
                {
                  "include": "#graphql-colon"
                },
                {
                  "include": "#graphql-comment"
                },
                {
                  "include": "#graphql-skip-newlines"
                }
              ]
            },
            {
              "include": "#graphql-comment"
            },
            {
              "include": "#graphql-skip-newlines"
            }
          ]
        },
        {
          "include": "#graphql-comment"
        },
        {
          "include": "#graphql-skip-newlines"
        }
      ]
    },
    "graphql-comment": {
      "patterns": [
        {
          "name": "comment.block.graphql.js",
          "begin": "\\s*+\"\"\"",
          "end": "\\s*\"\"\""
        },
        {
          "name": "comment.line.graphql.js",
          "match": "(\\s*)((\\#.*)|(\".*\"))",
          "captures": {
            "1": {
              "name": "punctuation.whitespace.comment.leading.graphql"
            }
          }
        }
      ]
    },
    "graphql-variable-definitions": {
      "begin": "\\s*(\\()",
      "end": "\\s*(\\))",
      "captures": {
        "1": {
          "name": "meta.brace.round.graphql"
        }
      },
      "patterns": [
        {
          "include": "#graphql-comment"
        },
        {
          "include": "#graphql-variable-definition"
        },
        {
          "include": "#literal-quasi-embedded"
        }
      ]
    },
    "graphql-variable-definition": {
      "comment": "variable: type = value,.... which may be a list",
      "name": "meta.variables.graphql",
      "begin": "\\s*(\\$?[_A-Za-z][_0-9A-Za-z]*)(?=\\s*\\(|:)",
      "end": "(?=\\s*((\\$?[_A-Za-z][_0-9A-Za-z]*)\\s*(\\(|:)|(}|\\))))|\\s*(,)",
      "beginCaptures": {
        "1": {
          "name": "variable.graphql"
        }
      },
      "endCaptures": {
        "5": {
          "name": "punctuation.comma.graphql"
        }
      },
      "patterns": [
        {
          "include": "#graphql-comment"
        },
        {
          "include": "#graphql-colon"
        },
        {
          "include": "#graphql-input-types"
        },
        {
          "include": "#graphql-variable-assignment"
        },
        {
          "include": "#literal-quasi-embedded"
        },
        {
          "include": "#graphql-skip-newlines"
        }
      ]
    },
    "graphql-input-types": {
      "patterns": [
        {
          "include": "#graphql-scalar-type"
        },
        {
          "match": "\\s*([_A-Za-z][_0-9A-Za-z]*)(?:\\s*(!))?",
          "captures": {
            "1": {
              "name": "support.type.graphql"
            },
            "2": {
              "name": "keyword.operator.nulltype.graphql"
            }
          }
        },
        {
          "name": "meta.type.list.graphql",
          "begin": "\\s*(\\[)",
          "end": "\\s*(\\])(?:\\s*(!))?",
          "captures": {
            "1": {
              "name": "meta.brace.squart.graphql"
            },
            "2": {
              "name": "keyword.operator.nulltype.graphql"
            }
          },
          "patterns": [
            {
              "include": "#graphql-input-types"
            },
            {
              "include": "#graphql-comment"
            },
            {
              "include": "#graphql-comma"
            },
            {
              "include": "#literal-quasi-embedded"
            }
          ]
        }
      ]
    },
    "graphql-scalar": {
      "match": "\\s*\\b(scalar)\\b\\s*([_A-Za-z][_0-9A-Za-z]*)",
      "captures": {
        "1": {
          "name": "keyword.scalar.graphql"
        },
        "2": {
          "name": "entity.scalar.graphql"
        }
      }
    },
    "graphql-scalar-type": {
      "match": "\\s*\\b(Int|Float|String|Boolean|ID)\\b(?:\\s*(!))?",
      "captures": {
        "1": {
          "name": "support.type.builtin.graphql"
        },
        "2": {
          "name": "keyword.operator.nulltype.graphql"
        }
      }
    },
    "graphql-variable-assignment": {
      "begin": "\\s(=)",
      "end": "(?=.)",
      "applyEndPatternLast": 1,
      "beginCaptures": {
        "1": {
          "name": "punctuation.assignment.graphql"
        }
      },
      "patterns": [
        {
          "include": "#graphql-value"
        }
      ]
    },
    "graphql-comma": {
      "match": "\\s*(,)",
      "captures": {
        "1": {
          "name": "punctuation.comma.graphql"
        }
      }
    },
    "graphql-colon": {
      "match": "\\s*(:)",
      "captures": {
        "1": {
          "name": "punctuation.colon.graphql"
        }
      }
    },
    "graphql-union-mark": {
      "match": "\\s*(\\|)",
      "captures": {
        "1": {
          "name": "punctuation.union.graphql"
        }
      }
    },
    "graphql-name": {
      "match": "\\s*([_A-Za-z][_0-9A-Za-z]*)",
      "captures": {
        "1": {
          "name": "entity.name.function.graphql"
        }
      }
    },
    "graphql-directive": {
      "begin": "\\s*((@)\\s*([_A-Za-z][_0-9A-Za-z]*))",
      "end": "(?=.)",
      "applyEndPatternLast": 1,
      "beginCaptures": {
        "1": {
          "name": "entity.name.function.directive.graphql"
        }
      },
      "patterns": [
        {
          "include": "#graphql-arguments"
        },
        {
          "include": "#graphql-comment"
        },
        {
          "include": "#literal-quasi-embedded"
        },
        {
          "include": "#graphql-skip-newlines"
        }
      ]
    },
    "graphql-selection-set": {
      "name": "meta.selectionset.graphql",
      "begin": "\\s*({)",
      "end": "\\s*(})",
      "beginCaptures": {
        "1": {
          "name": "punctuation.operation.graphql"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.operation.graphql"
        }
      },
      "patterns": [
        {
          "include": "#graphql-field"
        },
        {
          "include": "#graphql-fragment-spread"
        },
        {
          "include": "#graphql-inline-fragment"
        },
        {
          "include": "#graphql-comma"
        },
        {
          "include": "#graphql-comment"
        },
        {
          "include": "#literal-quasi-embedded"
        }
      ]
    },
    "graphql-field": {
      "patterns": [
        {
          "match": "\\s*([_A-Za-z][_0-9A-Za-z]*)\\s*(:)",
          "captures": {
            "1": {
              "name": "string.unquoted.alias.graphql"
            },
            "2": {
              "name": "punctuation.colon.graphql"
            }
          }
        },
        {
          "match": "\\s*([_A-Za-z][_0-9A-Za-z]*)",
          "captures": {
            "1": {
              "name": "variable.graphql"
            }
          }
        },
        {
          "include": "#graphql-arguments"
        },
        {
          "include": "#graphql-directive"
        },
        {
          "include": "#graphql-selection-set"
        },
        {
          "include": "#literal-quasi-embedded"
        },
        {
          "include": "#graphql-skip-newlines"
        }
      ]
    },
    "graphql-fragment-spread": {
      "begin": "\\s*(\\.\\.\\.)\\s*(?!\\bon\\b)([_A-Za-z][_0-9A-Za-z]*)",
      "end": "(?=.)",
      "applyEndPatternLast": 1,
      "captures": {
        "1": {
          "name": "keyword.operator.spread.graphql"
        },
        "2": {
          "name": "variable.fragment.graphql"
        }
      },
      "patterns": [
        {
          "include": "#graphql-comment"
        },
        {
          "include": "#graphql-selection-set"
        },
        {
          "include": "#graphql-directive"
        },
        {
          "include": "#literal-quasi-embedded"
        },
        {
          "include": "#graphql-skip-newlines"
        }
      ]
    },
    "graphql-inline-fragment": {
      "begin": "\\s*(\\.\\.\\.)\\s*(?:(\\bon\\b)\\s*([_A-Za-z][_0-9A-Za-z]*))?",
      "end": "(?=.)",
      "applyEndPatternLast": 1,
      "captures": {
        "1": {
          "name": "keyword.operator.spread.graphql"
        },
        "2": {
          "name": "keyword.on.graphql"
        },
        "3": {
          "name": "support.type.graphql"
        }
      },
      "patterns": [
        {
          "include": "#graphql-comment"
        },
        {
          "include": "#graphql-selection-set"
        },
        {
          "include": "#graphql-directive"
        },
        {
          "include": "#graphql-skip-newlines"
        },
        {
          "include": "#literal-quasi-embedded"
        }
      ]
    },
    "graphql-arguments": {
      "name": "meta.arguments.graphql",
      "begin": "\\s*(\\()",
      "end": "\\s*(\\))",
      "beginCaptures": {
        "1": {
          "name": "meta.brace.round.directive.graphql"
        }
      },
      "endCaptures": {
        "1": {
          "name": "meta.brace.round.directive.graphql"
        }
      },
      "patterns": [
        {
          "include": "#graphql-comment"
        },
        {
          "begin": "\\s*([_A-Za-z][_0-9A-Za-z]*)(?:\\s*(:))?",
          "end": "(?=\\s*(?:(?:([_A-Za-z][_0-9A-Za-z]*)\\s*(:))|\\)))|\\s*(,)",
          "beginCaptures": {
            "1": {
              "name": "variable.arguments.graphql"
            },
            "2": {
              "name": "punctuation.colon.graphql"
            }
          },
          "endCaptures": {
            "3": {
              "name": "punctuation.comma.graphql"
            }
          },
          "patterns": [
            {
              "include": "#graphql-value"
            },
            {
              "include": "#graphql-comment"
            },
            {
              "include": "#graphql-skip-newlines"
            }
          ]
        },
        {
          "include": "#literal-quasi-embedded"
        }
      ]
    },
    "graphql-variable-name": {
      "match": "\\s*(\\$[_A-Za-z][_0-9A-Za-z]*)",
      "captures": {
        "1": {
          "name": "variable.graphql"
        }
      }
    },
    "graphql-int-value": {
      "match": "\\s*((-)?(0|[1-9][0-9]*))",
      "captures": {
        "1": {
          "name": "constant.int.graphql"
        }
      }
    },
    "graphql-float-value": {
      "match": "\\s*((-)?(0|([1-9]\\d*)(\\.\\d*)?((e|E)(\\+|-)?\\d*)?))",
      "captures": {
        "1": {
          "name": "constant.float.graphql"
        }
      }
    },
    "graphql-boolean-value": {
      "match": "\\s*\\b(true|false)\\b",
      "captures": {
        "1": {
          "name": "constant.boolean.graphql"
        }
      }
    },
    "graphql-string-value": {
      "contentName": "string.quoted.double.graphql",
      "begin": "\\s*+((\"))",
      "end": "\\s*+(?:((\"))|(\n))",
      "beginCaptures": {
        "1": {
          "name": "string.quoted.double.graphql"
        },
        "2": {
          "name": "punctuation.definition.string.begin.graphql"
        }
      },
      "endCaptures": {
        "1": {
          "name": "string.quoted.double.graphql"
        },
        "2": {
          "name": "punctuation.definition.string.end.graphql"
        },
        "3": {
          "name": "invalid.illegal.newline.graphql"
        }
      },
      "patterns": [
        {
          "include": "#graphql-string-content"
        },
        {
          "include": "#literal-quasi-embedded"
        }
      ]
    },
    "graphql-string-content": {
      "patterns": [
        {
          "name": "constant.character.escape.graphql",
          "match": "\\\\[/'\"\\\\nrtbf]"
        },
        {
          "name": "constant.character.escape.graphql",
          "match": "\\\\u([0-9a-fA-F]{4})"
        }
      ]
    },
    "graphql-enum": {
      "name": "meta.enum.graphql",
      "begin": "\\s*+\\b(enum)\\b\\s*([_A-Za-z][_0-9A-Za-z]*)",
      "end": "(?<=})",
      "beginCaptures": {
        "1": {
          "name": "keyword.enum.graphql"
        },
        "2": {
          "name": "support.type.enum.graphql"
        }
      },
      "patterns": [
        {
          "name": "meta.type.object.graphql",
          "begin": "\\s*({)",
          "end": "\\s*(})",
          "beginCaptures": {
            "1": {
              "name": "punctuation.operation.graphql"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.operation.graphql"
            }
          },
          "patterns": [
            {
              "include": "#graphql-object-type"
            },
            {
              "include": "#graphql-comment"
            },
            {
              "include": "#graphql-enum-value"
            },
            {
              "include": "#literal-quasi-embedded"
            }
          ]
        }
      ]
    },
    "graphql-enum-value": {
      "name": "constant.character.enum.graphql",
      "match": "\\s*(?!=\\b(true|false|null)\\b)([_A-Za-z][_0-9A-Za-z]*)"
    },
    "graphql-value": {
      "patterns": [
        {
          "include": "#graphql-variable-name"
        },
        {
          "include": "#graphql-float-value"
        },
        {
          "include": "#graphql-int-value"
        },
        {
          "include": "#graphql-string-value"
        },
        {
          "include": "#graphql-boolean-value"
        },
        {
          "include": "#graphql-enum-value"
        },
        {
          "include": "#graphql-list-value"
        },
        {
          "include": "#graphql-object-value"
        },
        {
          "include": "#graphql-comment"
        },
        {
          "include": "#literal-quasi-embedded"
        }
      ]
    },
    "graphql-list-value": {
      "patterns": [
        {
          "name": "meta.listvalues.graphql",
          "begin": "\\s*+(\\[)",
          "end": "\\s*(\\])",
          "endCaptures": {
            "1": {
              "name": "meta.brace.square.graphql"
            }
          },
          "beginCaptures": {
            "1": {
              "name": "meta.brace.square.graphql"
            }
          },
          "patterns": [
            {
              "include": "#graphql-value"
            }
          ]
        }
      ]
    },
    "graphql-object-value": {
      "patterns": [
        {
          "name": "meta.objectvalues.graphql",
          "begin": "\\s*+({)",
          "end": "\\s*(})",
          "endCaptures": {
            "1": {
              "name": "meta.brace.curly.graphql"
            }
          },
          "beginCaptures": {
            "1": {
              "name": "meta.brace.curly.graphql"
            }
          },
          "patterns": [
            {
              "include": "#graphql-object-field"
            },
            {
              "include": "#graphql-value"
            }
          ]
        }
      ]
    },
    "graphql-object-field": {
      "match": "\\s*(([_A-Za-z][_0-9A-Za-z]*))\\s*(:)",
      "captures": {
        "1": {
          "name": "constant.object.key.graphql"
        },
        "2": {
          "name": "string.unquoted.graphql"
        },
        "3": {
          "name": "punctuation.graphql"
        }
      }
    },
    "graphql-union": {
      "begin": "\\s*\\b(union)\\b\\s*([_A-Za-z][_0-9A-Za-z]*)",
      "end": "(?=.)",
      "applyEndPatternLast": 1,
      "captures": {
        "1": {
          "name": "keyword.union.graphql"
        },
        "2": {
          "name": "support.type.graphql"
        }
      },
      "patterns": [
        {
          "begin": "\\s*(=)\\s*([_A-Za-z][_0-9A-Za-z]*)",
          "end": "(?=.)",
          "applyEndPatternLast": 1,
          "captures": {
            "1": {
              "name": "punctuation.assignment.graphql"
            },
            "2": {
              "name": "support.type.graphql"
            }
          },
          "patterns": [
            {
              "include": "#graphql-skip-newlines"
            },
            {
              "include": "#graphql-comment"
            },
            {
              "include": "#literal-quasi-embedded"
            },
            {
              "match": "\\s*(\\|)\\s*([_A-Za-z][_0-9A-Za-z]*)",
              "captures": {
                "1": {
                  "name": "punctuation.or.graphql"
                },
                "2": {
                  "name": "support.type.graphql"
                }
              }
            }
          ]
        },
        {
          "include": "#graphql-skip-newlines"
        },
        {
          "include": "#graphql-comment"
        },
        {
          "include": "#literal-quasi-embedded"
        }
      ]
    },
    "graphql-skip-newlines": {
      "match": "\\s*\n"
    }
  },
  "comment": "((?:[$_\\p{Lu}\\p{Nl}]|\\\\u\\h{4}|\\\\u{\\h+})(?:[$_\\p{L}\\p{Mn}\\p{Mc}\\p{Nd}\\p{Nl}\\p{Pc}\\x{200C}\\x{200D}]|\\\\u\\h{4}|\\\\u{\\h+})*+)"
}
