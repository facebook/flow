/*  */
// @nolint

// Regular import
import {
  Something,
} from 'some-module';

// Import types

// Typed function
async function test(x, y /*.*/ /*.*/ , z /*.*/ /*.*/ = 123) {
  // Typed expression
  return await (x);
}

// Interface

// Exported interface

// Interface extends

// Implements interface
class Bar extends Other /*.*/ {
  // Class Property with default value
  answer = 42;

  // Class Property with default value and variance
covariant = 42;

  // Class Property
  prop;

  // Class Property with variance
propCo;

  method() {
    return;
  }
}

// Class expression implements interface
var SomeClass = class Baz {
  prop;

  method() {
    return;
  }
};

// Parametric class
class Wrapper {
  get() {
    return this.value;
  }

  map() {
    // do something
  }
}

// Extends Parametric class
class StringWrapper extends Wrapper {
  // ...
}

// Declare class

// Declare funtion

// Declare interface

// Declare module

// Declare type alias

// Declare variable

// Type alias

// Export type

// Export type *

// Regular export
export { Wrapper };

// Exported type alias

// Object with types within
var someObj = {
  objMethod() {
    // do nothing.
  }
}

// Example from README
import SomeClass from 'some-module'

export class MyClass extends SomeClass {

  value

  constructor(value) {
    this.value = value
  }

  get() {
    return this.value
  }

}

// Test async/await functions
async function asyncFunction(input) {
  return await t;
}

// Test read-only data

// Test covariant type variant class with constaint and default.
export class TestClassWithDefault {

  constructor() {}
}

var newline_arrow = () => 42;

var newline_arrow_2 = ()=>42;

// Test calling a function with explicit type arguments
doSomething(3);
doSomething(3);

// Test invoking a constructor with explicit type arguments
new Event();

// Test type union and intersection syntax with leading "operator"
var union;
var intersection;

// Test generic async arrow funcion
const f = async() => {};

// Comment type annotations are preserved
var X /*: {
  version: string,
} */ = { version: '42'};

function method(param /*: string */) /*: number */ {
  // ...
}

// declared class fields
class MyClass {
}

// Comment type includes are not emptied out
class MyClass {
  /*:: prop: string; */
}

// Inferred predicate
function inferredPredicateWithType(arg) {
  return !!arg;
}

function inferredPredicateWithoutType(arg) {
  return !!arg;
}

// Type guards
function typeGuardFunction(x) {
  return typeof x === "boolean";
}

const typeGuardArrow = (x) => (typeof x === "boolean");

function typeGuardInComments(x /*: mixed */) /*: x is boolean */ {
  return typeof x === "boolean";
}

function typeAssertsFunction1(x) {
  if (typeof x !== "boolean") throw new Error;
}

function typeAssertsFunction2(x) {
  if (!x) throw new Error;
}

// Test function with default type parameter
function f() {}

// Opaque types

// Declare export

// `this` params

function z () {}
function u ( ...a) {}
function v (
 ...a) {}
function w (
) {}
function x (
   ...a) {}
function i(
) {}
function j(
  a
) {}

function jj(
  a
) {
  function jjj( a) {}
}

const f = function() {}
const g = function( ...a) {}
const h = function(...a) {}
const k = function(
) {}
const kk = function(a,) {}

// `as` cast
1;
1;
[1];

// `as` cast with generics
'm';
['a', 'b', 'c'];
['x', 'y', 'z'];
const ga = {a: 'b'};
const gb = {a: 'x', b: 1};

// `as const`
's';
['s'];

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxzdGRpbj4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkdBQUcsQUFBSzs7Ozs7O0VBTU4sQUFBQSxBQUFhLEFBQUMsQUFBQTtFQUNkLEFBQUEsQUFBcUIsQUFBQTs7OztBQUl2QixBQUE0QyxBQUFBOzs7cUJBR3ZCLEFBQU0sVUFBVSxBQUFBLEFBQUMsaUJBQWlCLEFBQUEsQUFBQyxPQUFPLEFBQUEsQUFBYyxPQUFPLEFBQVE7O2lCQUUzRSxBQUFLOzs7O0FBSXRCLEFBSUMsQUFBQTs7O0FBR0QsQUFFQyxBQUFBOzs7QUFHRCxBQUVDLEFBQUE7Ozt3QkFHdUIsQUFBQSxBQUFVLE9BQU8sQUFBQSxBQUFHLEFBQUMsQ0FBQyxBQUFBLEFBQVU7O1FBRWhELEFBQVE7OztFQUdkLEFBQUEsQUFBQyxTQUFTLEFBQVE7OztNQUdkLEFBQUs7OztFQUdULEFBQUEsQUFBQyxNQUFNLEFBQVE7O1VBRVAsQUFBTzs7Ozs7OzBCQU1TLEFBQUEsQUFBVSxDQUFDLEFBQUEsQUFBRztNQUNsQyxBQUFLOztVQUVELEFBQU87Ozs7OzthQU1KLEFBQUc7T0FDVCxBQUFHOzs7O0tBSUwsQUFBRyxFQUFFLEFBQVk7Ozs7OzttQ0FNYSxBQUFROzs7OztBQUszQyxBQUVDLEFBQUE7OztBQUdELEFBQWtDLEFBQUE7OztBQUdsQyxBQUVDLEFBQUE7OztBQUdELEFBRUMsQUFBQTs7O0FBR0QsQUFHRSxBQUFBOzs7QUFHRixBQUErQixBQUFBOzs7QUFHL0IsQUFBZ0IsQUFBQTs7O0FBR2hCLEFBQWtCLEFBQUE7OztBQUdsQixBQUFpQyxBQUFBOzs7Ozs7QUFNakMsQUFBa0MsQUFBQTs7OzthQUlyQixBQUFNOzs7Ozs7O0FBT25CLEFBQWdELEFBQUE7O29CQUU1QixBQUFHLG1CQUFtQixBQUFBLEFBQVUsQ0FBQyxBQUFBLEFBQWE7O09BRTNELEFBQUc7O21CQUVTLEFBQUc7Ozs7T0FJZixBQUFHOzs7Ozs7OzRCQU9rQixBQUFHLE1BQU0sQUFBRyxDQUFDLEFBQVk7Ozs7O0FBS3JELEFBRUcsQUFBQTs7O2lDQUc4QixBQUFpQzs7Ozs7c0JBSzVDLEFBQ2hCOzt5QkFFbUIsQUFBQSxBQUNuQjs7O1dBR0ssQUFBUTtZQUNQLEFBQUEsQUFBTTs7O1NBR1QsQUFBUTs7O1NBR1IsQUFBUztnQkFDRixBQUFTOzs7Z0JBR1QsQUFBQSxBQUFHLEVBQUUsQUFBRzs7Ozs7Ozs7Ozs7OztFQWF0QixBQUFBLEFBQXFCLEFBQUE7Ozs7Ozs7OztzQ0FTZSxBQUFPLENBQUMsQUFBUyxDQUFDLEFBQUEsQUFBTzs7Ozt5Q0FJdEIsQUFBTyxDQUFDLEFBQUMsQ0FBQyxBQUFBLEFBQU87Ozs7OzRCQUs5QixBQUFPLENBQUMsQUFBYzs7Ozt5QkFJekIsQUFBTyxDQUFDLEFBQWM7Ozs7OzsrQkFNaEIsQUFBTyxDQUFDLEFBQXNCOzs7OytCQUk5QixBQUFPLENBQUMsQUFBVzs7Ozs7VUFLeEMsQUFBVTs7O0FBR3BCLEFBQXVCLEFBQUE7QUFDdkIsQUFBK0IsQUFBQTtBQUMvQixBQUFzQixBQUFBO0FBQ3RCLEFBQThCLEFBQUE7QUFDOUIsQUFBOEIsQUFBQTs7O0FBRzlCLEFBQTZCLEFBQUE7QUFDN0IsQUFBa0MsQUFBQTtBQUNsQyxBQUF5QixBQUFBOzs7O0FBSXpCLEFBQXlDLEFBQUE7QUFDekMsQUFBZ0MsQUFBQTtZQUNwQixBQUFhO1lBQ2IsQUFBYSxBQUFDO1lBQ2QsQUFBYTtHQUN0QixBQUFBLEFBQUM7WUFDUSxBQUNGLEFBQUE7O0dBRVAsQUFBQSxBQUFDO1lBQ1EsQUFDRixBQUFBOztHQUVQLEFBQUEsQUFBQyxBQUFBOzs7RUFHRixBQUFBLEFBQU8sQUFBQyxBQUFBOzs7RUFHUixBQUFBLEFBQU8sQUFBQyxBQUFBO0dBQ1AsQUFBUTs7OztFQUlULEFBQUEsQUFBTyxBQUFDLEFBQUE7R0FDUCxBQUFROztlQUVJLEFBQU8sQUFBQyxFQUFFLEFBQVE7OzttQkFHZCxBQUFZO21CQUNaLEFBQVksQUFBQzttQkFDYixBQUNYLEFBQUMsQUFBQTs7bUJBRVUsQUFDWCxBQUFBOztBQUVSLEFBQUM7b0JBQ21CLEFBQ1osQUFBQyxBQUFBO0NBQ1IsQUFBUTs7O0VBR1AsQUFBQSxBQUFFLENBQUMsQUFBQSxBQUFNO0VBQ1QsQUFBQSxBQUFFLENBQUMsQUFBQSxBQUFNLENBQUMsQUFBQSxBQUFFLENBQUMsQUFBQSxBQUFLO0lBQ2hCLEFBQUEsQUFBRSxDQUFDLEFBQUEsQUFBRzs7O0lBR04sQUFBQSxBQUFFLENBQUMsQUFBQSxBQUFhLEFBQVE7Z0JBQ1osQUFBQSxBQUFFLENBQUMsQUFBQSxBQUFLLEFBQW1DO2dCQUMzQyxBQUFBLEFBQUUsQ0FBQyxBQUFBLEFBQU8sQUFBMEI7b0JBQ2hDLEFBQUEsQUFBRSxDQUFDLEFBQUEsQUFBSyxBQUFxQzswQkFDdkMsQUFBQSxBQUFFLENBQUMsQUFBQSxBQUFNLEFBQXdCOzs7SUFHdkQsQUFBQSxBQUFFLENBQUMsQUFBQSxBQUFLO01BQ04sQUFBQSxBQUFFLENBQUMsQUFBQSxBQUFLIiwic291cmNlc0NvbnRlbnQiOlsiLyogQGZsb3cgKi9cbi8vIEBub2xpbnRcblxuLy8gUmVndWxhciBpbXBvcnRcbmltcG9ydCB7XG4gIFNvbWV0aGluZyxcbiAgdHlwZSBTb21lVHlwZSxcbiAgdHlwZW9mIFNvbWVPdGhlclRoaW5nXG59IGZyb20gJ3NvbWUtbW9kdWxlJztcblxuLy8gSW1wb3J0IHR5cGVzXG5pbXBvcnQgdHlwZSB7IFNvbWVUeXBlIH0gZnJvbSAnc29tZS1tb2R1bGUnO1xuXG4vLyBUeXBlZCBmdW5jdGlvblxuYXN5bmMgZnVuY3Rpb24gdGVzdCh4OiBUeXBlLCB5IC8qLiovID8gLyouKi8gLCB6IC8qLiovID8gLyouKi8gOiAvKi4qLyBudW1iZXIgPSAxMjMpOiBzdHJpbmcge1xuICAvLyBUeXBlZCBleHByZXNzaW9uXG4gIHJldHVybiBhd2FpdCAoeDogYW55KTtcbn1cblxuLy8gSW50ZXJmYWNlXG5pbnRlcmZhY2UgRm9vIHtcbiAgcHJvcDogYW55O1xuXG4gIG1ldGhvZCgpOiBtaXhlZDtcbn1cblxuLy8gRXhwb3J0ZWQgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIElUaGluZyB7XG4gIGV4cG9ydGVkOiB0cnVlO1xufVxuXG4vLyBJbnRlcmZhY2UgZXh0ZW5kc1xuaW50ZXJmYWNlIFNpbGx5Rm9vIGV4dGVuZHMgRm9vIHtcbiAgc2lsbHk6IHN0cmluZztcbn1cblxuLy8gSW1wbGVtZW50cyBpbnRlcmZhY2VcbmNsYXNzIEJhciBleHRlbmRzIE90aGVyIGltcGxlbWVudHMgLyouKi8gRm9vLCBJU29tZXRoaW5nIHtcbiAgLy8gQ2xhc3MgUHJvcGVydHkgd2l0aCBkZWZhdWx0IHZhbHVlXG4gIGFuc3dlcjogbnVtYmVyID0gNDI7XG5cbiAgLy8gQ2xhc3MgUHJvcGVydHkgd2l0aCBkZWZhdWx0IHZhbHVlIGFuZCB2YXJpYW5jZVxuICArY292YXJpYW50OiBudW1iZXIgPSA0MjtcblxuICAvLyBDbGFzcyBQcm9wZXJ0eVxuICBwcm9wOiBhbnk7XG5cbiAgLy8gQ2xhc3MgUHJvcGVydHkgd2l0aCB2YXJpYW5jZVxuICArcHJvcENvOiBudW1iZXI7XG5cbiAgbWV0aG9kKCk6IG1peGVkIHtcbiAgICByZXR1cm47XG4gIH1cbn1cblxuLy8gQ2xhc3MgZXhwcmVzc2lvbiBpbXBsZW1lbnRzIGludGVyZmFjZVxudmFyIFNvbWVDbGFzcyA9IGNsYXNzIEJheiBpbXBsZW1lbnRzIEZvbyB7XG4gIHByb3A6IGFueTtcblxuICBtZXRob2QoKTogbWl4ZWQge1xuICAgIHJldHVybjtcbiAgfVxufTtcblxuLy8gUGFyYW1ldHJpYyBjbGFzc1xuY2xhc3MgV3JhcHBlcjxUPiB7XG4gIGdldCgpOiBUIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxuXG4gIG1hcDxNPigpOiBXcmFwcGVyPE0+IHtcbiAgICAvLyBkbyBzb21ldGhpbmdcbiAgfVxufVxuXG4vLyBFeHRlbmRzIFBhcmFtZXRyaWMgY2xhc3NcbmNsYXNzIFN0cmluZ1dyYXBwZXIgZXh0ZW5kcyBXcmFwcGVyPHN0cmluZz4ge1xuICAvLyAuLi5cbn1cblxuLy8gRGVjbGFyZSBjbGFzc1xuZGVjbGFyZSBjbGFzcyBCYXoge1xuICBtZXRob2QoKTogbWl4ZWQ7XG59XG5cbi8vIERlY2xhcmUgZnVudGlvblxuZGVjbGFyZSBmdW5jdGlvbiBzb21lRnVuYygpOiB2b2lkO1xuXG4vLyBEZWNsYXJlIGludGVyZmFjZVxuZGVjbGFyZSBpbnRlcmZhY2UgSVNvbWV0aGluZyB7XG4gIGFuc3dlcjogbnVtYmVyO1xufVxuXG4vLyBEZWNsYXJlIG1vZHVsZVxuZGVjbGFyZSBtb2R1bGUgJ2ZzJyB7XG4gIGRlY2xhcmUgZnVuY3Rpb24gcmVhZFRoaW5nKHBhdGg6IHN0cmluZyk6IHN0cmluZztcbn1cblxuLy8gRGVjbGFyZSB0eXBlIGFsaWFzXG5kZWNsYXJlIHR5cGUgTG9jYXRpb24gPSB7XG4gIGxhdDogbnVtYmVyLFxuICBsb246IG51bWJlclxufTtcblxuLy8gRGVjbGFyZSB2YXJpYWJsZVxuZGVjbGFyZSB2YXIgU09NRV9DT05TVDogc3RyaW5nO1xuXG4vLyBUeXBlIGFsaWFzXG50eXBlIFQgPSBzdHJpbmc7XG5cbi8vIEV4cG9ydCB0eXBlXG5leHBvcnQgdHlwZSB7IFQgfTtcblxuLy8gRXhwb3J0IHR5cGUgKlxuZXhwb3J0IHR5cGUgKiBmcm9tICdzb21lLW1vZHVsZSc7XG5cbi8vIFJlZ3VsYXIgZXhwb3J0XG5leHBvcnQgeyBXcmFwcGVyIH07XG5cbi8vIEV4cG9ydGVkIHR5cGUgYWxpYXNcbmV4cG9ydCB0eXBlIE9ORSA9IHsgb25lOiBudW1iZXIgfTtcblxuLy8gT2JqZWN0IHdpdGggdHlwZXMgd2l0aGluXG52YXIgc29tZU9iaiA9IHtcbiAgb2JqTWV0aG9kKCk6IHZvaWQge1xuICAgIC8vIGRvIG5vdGhpbmcuXG4gIH1cbn1cblxuLy8gRXhhbXBsZSBmcm9tIFJFQURNRVxuaW1wb3J0IFNvbWVDbGFzcyBmcm9tICdzb21lLW1vZHVsZSdcbmltcG9ydCB0eXBlIHsgU29tZUludGVyZmFjZSB9IGZyb20gJ3NvbWUtbW9kdWxlJ1xuXG5leHBvcnQgY2xhc3MgTXlDbGFzczxUPiBleHRlbmRzIFNvbWVDbGFzcyBpbXBsZW1lbnRzIFNvbWVJbnRlcmZhY2Uge1xuXG4gIHZhbHVlOiBUXG5cbiAgY29uc3RydWN0b3IodmFsdWU6IFQpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgfVxuXG4gIGdldCgpOiBUIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVxuICB9XG5cbn1cblxuLy8gVGVzdCBhc3luYy9hd2FpdCBmdW5jdGlvbnNcbmFzeW5jIGZ1bmN0aW9uIGFzeW5jRnVuY3Rpb248VD4oaW5wdXQ6IFQpOiBQcm9taXNlPFQ+IHtcbiAgcmV0dXJuIGF3YWl0IHQ7XG59XG5cbi8vIFRlc3QgcmVhZC1vbmx5IGRhdGFcbmV4cG9ydCB0eXBlIFRlc3RSZWFkT25seSA9IHt8XG4gICtyZWFkT25seTogJFJlYWRPbmx5QXJyYXk8PlxufH07XG5cbi8vIFRlc3QgY292YXJpYW50IHR5cGUgdmFyaWFudCBjbGFzcyB3aXRoIGNvbnN0YWludCBhbmQgZGVmYXVsdC5cbmV4cG9ydCBjbGFzcyBUZXN0Q2xhc3NXaXRoRGVmYXVsdDwrVDogVGVzdFJlYWRPbmx5ID0gVGVzdFJlYWRPbmx5PiB7XG5cbiAgY29uc3RydWN0b3IoKSB7fVxufVxuXG52YXIgbmV3bGluZV9hcnJvdyA9ICgpOlxubnVtYmVyID0+IDQyO1xuXG52YXIgbmV3bGluZV9hcnJvd18yID0gKCkgOlxubnVtYmVyPT40MjtcblxuLy8gVGVzdCBjYWxsaW5nIGEgZnVuY3Rpb24gd2l0aCBleHBsaWNpdCB0eXBlIGFyZ3VtZW50c1xuZG9Tb21ldGhpbmc8bnVtYmVyPigzKTtcbmRvU29tZXRoaW5nIDxULCBVPigzKTtcblxuLy8gVGVzdCBpbnZva2luZyBhIGNvbnN0cnVjdG9yIHdpdGggZXhwbGljaXQgdHlwZSBhcmd1bWVudHNcbm5ldyBFdmVudDxudW1iZXI+KCk7XG5cbi8vIFRlc3QgdHlwZSB1bmlvbiBhbmQgaW50ZXJzZWN0aW9uIHN5bnRheCB3aXRoIGxlYWRpbmcgXCJvcGVyYXRvclwiXG52YXIgdW5pb246IHwgVCB8IFU7XG52YXIgaW50ZXJzZWN0aW9uOiAmIFQgJiBVO1xuXG4vLyBUZXN0IGdlbmVyaWMgYXN5bmMgYXJyb3cgZnVuY2lvblxuY29uc3QgZiA9IGFzeW5jIDxUPigpOiBUID0+IHt9O1xuXG4vLyBDb21tZW50IHR5cGUgYW5ub3RhdGlvbnMgYXJlIHByZXNlcnZlZFxudmFyIFggLyo6IHtcbiAgdmVyc2lvbjogc3RyaW5nLFxufSAqLyA9IHsgdmVyc2lvbjogJzQyJ307XG5cbmZ1bmN0aW9uIG1ldGhvZChwYXJhbSAvKjogc3RyaW5nICovKSAvKjogbnVtYmVyICovIHtcbiAgLy8gLi4uXG59XG5cbi8vIGRlY2xhcmVkIGNsYXNzIGZpZWxkc1xuY2xhc3MgTXlDbGFzcyB7XG4gIGRlY2xhcmUgcHJvcDogc3RyaW5nO1xufVxuXG4vLyBDb21tZW50IHR5cGUgaW5jbHVkZXMgYXJlIG5vdCBlbXB0aWVkIG91dFxuY2xhc3MgTXlDbGFzcyB7XG4gIC8qOjogcHJvcDogc3RyaW5nOyAqL1xufVxuXG4vLyBJbmZlcnJlZCBwcmVkaWNhdGVcbmZ1bmN0aW9uIGluZmVycmVkUHJlZGljYXRlV2l0aFR5cGUoYXJnOiBtaXhlZCk6IGJvb2xlYW4gJWNoZWNrcyB7XG4gIHJldHVybiAhIWFyZztcbn1cblxuZnVuY3Rpb24gaW5mZXJyZWRQcmVkaWNhdGVXaXRob3V0VHlwZShhcmc6IG1peGVkKTogJWNoZWNrcyB7XG4gIHJldHVybiAhIWFyZztcbn1cblxuLy8gVHlwZSBndWFyZHNcbmZ1bmN0aW9uIHR5cGVHdWFyZEZ1bmN0aW9uKHg6IG1peGVkKTogeCBpcyBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSBcImJvb2xlYW5cIjtcbn1cblxuY29uc3QgdHlwZUd1YXJkQXJyb3cgPSAoeDogbWl4ZWQpOiB4IGlzIGJvb2xlYW4gPT4gKHR5cGVvZiB4ID09PSBcImJvb2xlYW5cIik7XG5cbmZ1bmN0aW9uIHR5cGVHdWFyZEluQ29tbWVudHMoeCAvKjogbWl4ZWQgKi8pIC8qOiB4IGlzIGJvb2xlYW4gKi8ge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwiYm9vbGVhblwiO1xufVxuXG5mdW5jdGlvbiB0eXBlQXNzZXJ0c0Z1bmN0aW9uMSh4OiBtaXhlZCk6IGFzc2VydHMgeCBpcyBib29sZWFuIHtcbiAgaWYgKHR5cGVvZiB4ICE9PSBcImJvb2xlYW5cIikgdGhyb3cgbmV3IEVycm9yO1xufVxuXG5mdW5jdGlvbiB0eXBlQXNzZXJ0c0Z1bmN0aW9uMih4OiBtaXhlZCk6IGFzc2VydHMgeCB7XG4gIGlmICgheCkgdGhyb3cgbmV3IEVycm9yO1xufVxuXG4vLyBUZXN0IGZ1bmN0aW9uIHdpdGggZGVmYXVsdCB0eXBlIHBhcmFtZXRlclxuZnVuY3Rpb24gZjxULCBTID0gVD4oKSB7fVxuXG4vLyBPcGFxdWUgdHlwZXNcbm9wYXF1ZSB0eXBlIEEgPSBudW1iZXI7XG5vcGFxdWUgdHlwZSBCOiBzdHJpbmcgPSBzdHJpbmc7XG5kZWNsYXJlIG9wYXF1ZSB0eXBlIEE7XG5kZWNsYXJlIG9wYXF1ZSB0eXBlIEI6IHN0cmluZztcbmV4cG9ydCBvcGFxdWUgdHlwZSBBID0gbnVtYmVyO1xuXG4vLyBEZWNsYXJlIGV4cG9ydFxuZGVjbGFyZSBleHBvcnQgb3BhcXVlIHR5cGUgQjtcbmRlY2xhcmUgZXhwb3J0IGZ1bmN0aW9uIHgoKTogdm9pZDtcbmRlY2xhcmUgZXhwb3J0IGRlZmF1bHQgVDtcblxuLy8gYHRoaXNgIHBhcmFtc1xuXG5kZWNsYXJlIGZ1bmN0aW9uIHkgKHRoaXMgOiBzdHJpbmcpIDogdm9pZFxudHlwZSBUID0gKHRoaXMgOiBzdHJpbmcpID0+IHZvaWRcbmZ1bmN0aW9uIHogKHRoaXMgOiBzdHJpbmcpIHt9XG5mdW5jdGlvbiB1ICh0aGlzIDogc3RyaW5nLCAuLi5hKSB7fVxuZnVuY3Rpb24gdiAodGhpcyA6IHN0cmluZ1xuICAgLCAuLi5hKSB7fVxuZnVuY3Rpb24gdyAodGhpc1xuICA6IHN0cmluZ1xuXG4gICAsKSB7fVxuZnVuY3Rpb24geCAodGhpc1xuICA6IHN0cmluZ1xuXG4gICAsXG4gICAuLi5hKSB7fVxuZnVuY3Rpb24gaShcbiAgdGhpczogWCxcbikge31cbmZ1bmN0aW9uIGooXG4gIHRoaXM6IFgsXG4gIGE6IHN0cmluZ1xuKSB7fVxuXG5mdW5jdGlvbiBqaihcbiAgdGhpczogWCxcbiAgYTogc3RyaW5nXG4pIHtcbiAgZnVuY3Rpb24gampqKHRoaXM6IFgsIGE6IHN0cmluZykge31cbn1cblxuY29uc3QgZiA9IGZ1bmN0aW9uKHRoaXM6IHN0cmluZykge31cbmNvbnN0IGcgPSBmdW5jdGlvbih0aGlzOiBzdHJpbmcsIC4uLmEpIHt9XG5jb25zdCBoID0gZnVuY3Rpb24odGhpc1xuOiBzdHJpbmcsXG4uLi5hKSB7fVxuY29uc3QgayA9IGZ1bmN0aW9uKHRoaXNcbjogc3RyaW5nXG5cbiwpIHt9XG5jb25zdCBrayA9IGZ1bmN0aW9uKHRoaXNcbjogc3RyaW5nLFxuYTogc3RyaW5nLCkge31cblxuLy8gYGFzYCBjYXN0XG4xIGFzIG51bWJlcjtcbjEgYXMgbnVtYmVyIGFzIG1peGVkO1xuWzFdIGFzIFsxXTtcblxuLy8gYGFzYCBjYXN0IHdpdGggZ2VuZXJpY3NcbidtJyBhcyAkTm9uTWF5YmVUeXBlPHN0cmluZz47XG5bJ2EnLCAnYicsICdjJ10gYXMgJEtleXM8e2E6IHN0cmluZywgYjogc3RyaW5nLCBjOiBudW1iZXJ9PjtcblsneCcsICd5JywgJ3onXSBhcyAkVmFsdWVzPHthOiAneCcsIGI6ICd5JywgYzogJ3onfT47XG5jb25zdCBnYSA9IHthOiAnYid9IGFzICRSZXN0PHthOiBzdHJpbmcsIGM6IG51bWJlcn0sIHtjOiBudW1iZXJ9PjtcbmNvbnN0IGdiID0ge2E6ICd4JywgYjogMX0gYXMgJFNoYXBlPHthOiBzdHJpbmcsIGI6IG51bWJlcn0+O1xuXG4vLyBgYXMgY29uc3RgXG4ncycgYXMgY29uc3Q7XG5bJ3MnXSBhcyBjb25zdDtcbiJdfQ==
