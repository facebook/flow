/*  */
// @nolint

// Regular import
import {
  Something,
} from 'some-module';

// Import types

// Typed function
async function test(x, y /*.*/ /*.*/ , z /*.*/ /*.*/ = 123) {
  // Typed expression
  return await (x);
}

// Interface

// Exported interface

// Interface extends

// Implements interface
class Bar extends Other /*.*/ {
  // Class Property with default value
  answer = 42;

  // Class Property with default value and variance
covariant = 42;

  // Class Property
  prop;

  // Class Property with variance
propCo;

  method() {
    return;
  }
}

// Class expression implements interface
var SomeClass = class Baz {
  prop;

  method() {
    return;
  }
};

// Parametric class
class Wrapper {
  get() {
    return this.value;
  }

  map() {
    // do something
  }
}

// Extends Parametric class
class StringWrapper extends Wrapper {
  // ...
}

// Declare class

// Declare funtion

// Declare interface

// Declare module

// Declare type alias

// Declare variable

// Type alias

// Export type

// Regular export
export { Wrapper };

// Exported type alias

// Object with types within
var someObj = {
  objMethod() {
    // do nothing.
  }
}

// Example from README
import SomeClass from 'some-module'

export class MyClass extends SomeClass {

  value

  constructor(value) {
    this.value = value
  }

  get() {
    return this.value
  }

}

// Test async/await functions
async function asyncFunction(input) {
  return await t;
}

// Test read-only data

// Test covariant type variant class with constaint and default.
export class TestClassWithDefault {

  constructor() {}
}

var newline_arrow = () => 42;

var newline_arrow_2 = ()=>42;

// Test calling a function with explicit type arguments
doSomething(3);
doSomething(3);

// Test invoking a constructor with explicit type arguments
new Event();

// Test type union and intersection syntax with leading "operator"
var union;
var intersection;

// Test generic async arrow funcion
const f = async() => {};

// Comment type annotations are preserved
var X /*: {
  version: string,
} */ = { version: '42'};

function method(param /*: string */) /*: number */ {
  // ...
}

// declared class fields
class MyClass {
}

// Comment type includes are emptied out
class MyClass {
  /*:: prop; */
}

// Inferred predicate
function testit(arg) {
  return !!arg;
}

// Test function with default type parameter
function f() {}

// Opaque types

// Declare export

// `this` params

function z () {}
function u ( ...a) {}
function v (
 ...a) {}
function w (
) {}
function x (
   ...a) {}
function i(
) {}
function j(
  a
) {}

function jj(
  a
) {
  function jjj( a) {}
}

const f = function() {}
const g = function( ...a) {}
const h = function(...a) {}
const k = function(
) {}
const kk = function(a,) {}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxzdGRpbj4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkdBQUcsQUFBSzs7Ozs7O0VBTU4sQUFBQSxBQUFJLENBQUMsQUFBQSxBQUFRLEFBQUMsQUFBQTtFQUNkLEFBQUEsQUFBTSxDQUFDLEFBQUEsQUFBYyxBQUFBOzs7O0FBSXZCLEFBQTRDLEFBQUE7OztxQkFHdkIsQUFBTSxVQUFVLEFBQUEsQUFBQyxpQkFBaUIsQUFBQSxBQUFDLE9BQU8sQUFBQSxBQUFjLE9BQU8sQUFBUTs7aUJBRTNFLEFBQUs7Ozs7QUFJdEIsQUFJQyxBQUFBOzs7QUFHRCxBQUVDLEFBQUE7OztBQUdELEFBRUMsQUFBQTs7O3dCQUd1QixBQUFBLEFBQVUsT0FBTyxBQUFBLEFBQUcsQUFBQyxDQUFDLEFBQUEsQUFBVTs7UUFFaEQsQUFBUTs7O0VBR2QsQUFBQSxBQUFDLFNBQVMsQUFBUTs7O01BR2QsQUFBSzs7O0VBR1QsQUFBQSxBQUFDLE1BQU0sQUFBUTs7VUFFUCxBQUFPOzs7Ozs7MEJBTVMsQUFBQSxBQUFVLENBQUMsQUFBQSxBQUFHO01BQ2xDLEFBQUs7O1VBRUQsQUFBTzs7Ozs7O2FBTUosQUFBRztPQUNULEFBQUc7Ozs7S0FJTCxBQUFHLEVBQUUsQUFBWTs7Ozs7O21DQU1hLEFBQVE7Ozs7O0FBSzNDLEFBRUMsQUFBQTs7O0FBR0QsQUFBa0MsQUFBQTs7O0FBR2xDLEFBRUMsQUFBQTs7O0FBR0QsQUFFQyxBQUFBOzs7QUFHRCxBQUdFLEFBQUE7OztBQUdGLEFBQStCLEFBQUE7OztBQUcvQixBQUFnQixBQUFBOzs7QUFHaEIsQUFBa0IsQUFBQTs7Ozs7O0FBTWxCLEFBQWtDLEFBQUE7Ozs7YUFJckIsQUFBTTs7Ozs7OztBQU9uQixBQUFnRCxBQUFBOztvQkFFNUIsQUFBRyxtQkFBbUIsQUFBQSxBQUFVLENBQUMsQUFBQSxBQUFhOztPQUUzRCxBQUFHOzttQkFFUyxBQUFHOzs7O09BSWYsQUFBRzs7Ozs7Ozs0QkFPa0IsQUFBRyxNQUFNLEFBQUcsQ0FBQyxBQUFZOzs7OztBQUtyRCxBQUVHLEFBQUE7OztpQ0FHOEIsQUFBaUM7Ozs7O3NCQUs1QyxBQUNoQjs7eUJBRW1CLEFBQUEsQUFDbkI7OztXQUdLLEFBQVE7WUFDUCxBQUFBLEFBQU07OztTQUdULEFBQVE7OztTQUdSLEFBQVM7Z0JBQ0YsQUFBUzs7O2dCQUdULEFBQUEsQUFBRyxFQUFFLEFBQUc7Ozs7Ozs7Ozs7Ozs7RUFhdEIsQUFBQSxBQUFxQixBQUFBOzs7OztXQUtaLEFBQVE7Ozs7bUJBSUEsQUFBTyxDQUFDLEFBQVMsQ0FBQyxBQUFBLEFBQU87Ozs7O1VBS2xDLEFBQVU7OztBQUdwQixBQUF1QixBQUFBO0FBQ3ZCLEFBQStCLEFBQUE7QUFDL0IsQUFBc0IsQUFBQTtBQUN0QixBQUE4QixBQUFBO0FBQzlCLEFBQThCLEFBQUE7OztBQUc5QixBQUE2QixBQUFBO0FBQzdCLEFBQWtDLEFBQUE7QUFDbEMsQUFBeUIsQUFBQTs7OztBQUl6QixBQUF5QyxBQUFBO0FBQ3pDLEFBQStCLEFBQUE7WUFDbkIsQUFBYTtZQUNiLEFBQWEsQUFBQztZQUNkLEFBQWE7R0FDdEIsQUFBQSxBQUFDO1lBQ1EsQUFDRixBQUFBOztHQUVQLEFBQUEsQUFBQztZQUNRLEFBQ0YsQUFBQTs7R0FFUCxBQUFBLEFBQUMsQUFBQTs7O0VBR0YsQUFBQSxBQUFPLEFBQUMsQUFBQTs7O0VBR1IsQUFBQSxBQUFPLEFBQUMsQUFBQTtHQUNQLEFBQVE7Ozs7RUFJVCxBQUFBLEFBQU8sQUFBQyxBQUFBO0dBQ1AsQUFBUTs7ZUFFSSxBQUFPLEFBQUMsRUFBRSxBQUFROzs7bUJBR2QsQUFBWTttQkFDWixBQUFZLEFBQUM7bUJBQ2IsQUFDWCxBQUFDLEFBQUE7O21CQUVVLEFBQ1gsQUFBQTs7QUFFUixBQUFDO29CQUNtQixBQUNaLEFBQUMsQUFBQTtDQUNSLEFBQVEiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBAZmxvdyAqL1xuLy8gQG5vbGludFxuXG4vLyBSZWd1bGFyIGltcG9ydFxuaW1wb3J0IHtcbiAgU29tZXRoaW5nLFxuICB0eXBlIFNvbWVUeXBlLFxuICB0eXBlb2YgU29tZU90aGVyVGhpbmdcbn0gZnJvbSAnc29tZS1tb2R1bGUnO1xuXG4vLyBJbXBvcnQgdHlwZXNcbmltcG9ydCB0eXBlIHsgU29tZVR5cGUgfSBmcm9tICdzb21lLW1vZHVsZSc7XG5cbi8vIFR5cGVkIGZ1bmN0aW9uXG5hc3luYyBmdW5jdGlvbiB0ZXN0KHg6IFR5cGUsIHkgLyouKi8gPyAvKi4qLyAsIHogLyouKi8gPyAvKi4qLyA6IC8qLiovIG51bWJlciA9IDEyMyk6IHN0cmluZyB7XG4gIC8vIFR5cGVkIGV4cHJlc3Npb25cbiAgcmV0dXJuIGF3YWl0ICh4OiBhbnkpO1xufVxuXG4vLyBJbnRlcmZhY2VcbmludGVyZmFjZSBGb28ge1xuICBwcm9wOiBhbnk7XG5cbiAgbWV0aG9kKCk6IG1peGVkO1xufVxuXG4vLyBFeHBvcnRlZCBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgSVRoaW5nIHtcbiAgZXhwb3J0ZWQ6IHRydWU7XG59XG5cbi8vIEludGVyZmFjZSBleHRlbmRzXG5pbnRlcmZhY2UgU2lsbHlGb28gZXh0ZW5kcyBGb28ge1xuICBzaWxseTogc3RyaW5nO1xufVxuXG4vLyBJbXBsZW1lbnRzIGludGVyZmFjZVxuY2xhc3MgQmFyIGV4dGVuZHMgT3RoZXIgaW1wbGVtZW50cyAvKi4qLyBGb28sIElTb21ldGhpbmcge1xuICAvLyBDbGFzcyBQcm9wZXJ0eSB3aXRoIGRlZmF1bHQgdmFsdWVcbiAgYW5zd2VyOiBudW1iZXIgPSA0MjtcblxuICAvLyBDbGFzcyBQcm9wZXJ0eSB3aXRoIGRlZmF1bHQgdmFsdWUgYW5kIHZhcmlhbmNlXG4gICtjb3ZhcmlhbnQ6IG51bWJlciA9IDQyO1xuXG4gIC8vIENsYXNzIFByb3BlcnR5XG4gIHByb3A6IGFueTtcblxuICAvLyBDbGFzcyBQcm9wZXJ0eSB3aXRoIHZhcmlhbmNlXG4gICtwcm9wQ286IG51bWJlcjtcblxuICBtZXRob2QoKTogbWl4ZWQge1xuICAgIHJldHVybjtcbiAgfVxufVxuXG4vLyBDbGFzcyBleHByZXNzaW9uIGltcGxlbWVudHMgaW50ZXJmYWNlXG52YXIgU29tZUNsYXNzID0gY2xhc3MgQmF6IGltcGxlbWVudHMgRm9vIHtcbiAgcHJvcDogYW55O1xuXG4gIG1ldGhvZCgpOiBtaXhlZCB7XG4gICAgcmV0dXJuO1xuICB9XG59O1xuXG4vLyBQYXJhbWV0cmljIGNsYXNzXG5jbGFzcyBXcmFwcGVyPFQ+IHtcbiAgZ2V0KCk6IFQge1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG5cbiAgbWFwPE0+KCk6IFdyYXBwZXI8TT4ge1xuICAgIC8vIGRvIHNvbWV0aGluZ1xuICB9XG59XG5cbi8vIEV4dGVuZHMgUGFyYW1ldHJpYyBjbGFzc1xuY2xhc3MgU3RyaW5nV3JhcHBlciBleHRlbmRzIFdyYXBwZXI8c3RyaW5nPiB7XG4gIC8vIC4uLlxufVxuXG4vLyBEZWNsYXJlIGNsYXNzXG5kZWNsYXJlIGNsYXNzIEJheiB7XG4gIG1ldGhvZCgpOiBtaXhlZDtcbn1cblxuLy8gRGVjbGFyZSBmdW50aW9uXG5kZWNsYXJlIGZ1bmN0aW9uIHNvbWVGdW5jKCk6IHZvaWQ7XG5cbi8vIERlY2xhcmUgaW50ZXJmYWNlXG5kZWNsYXJlIGludGVyZmFjZSBJU29tZXRoaW5nIHtcbiAgYW5zd2VyOiBudW1iZXI7XG59XG5cbi8vIERlY2xhcmUgbW9kdWxlXG5kZWNsYXJlIG1vZHVsZSAnZnMnIHtcbiAgZGVjbGFyZSBmdW5jdGlvbiByZWFkVGhpbmcocGF0aDogc3RyaW5nKTogc3RyaW5nO1xufVxuXG4vLyBEZWNsYXJlIHR5cGUgYWxpYXNcbmRlY2xhcmUgdHlwZSBMb2NhdGlvbiA9IHtcbiAgbGF0OiBudW1iZXIsXG4gIGxvbjogbnVtYmVyXG59O1xuXG4vLyBEZWNsYXJlIHZhcmlhYmxlXG5kZWNsYXJlIHZhciBTT01FX0NPTlNUOiBzdHJpbmc7XG5cbi8vIFR5cGUgYWxpYXNcbnR5cGUgVCA9IHN0cmluZztcblxuLy8gRXhwb3J0IHR5cGVcbmV4cG9ydCB0eXBlIHsgVCB9O1xuXG4vLyBSZWd1bGFyIGV4cG9ydFxuZXhwb3J0IHsgV3JhcHBlciB9O1xuXG4vLyBFeHBvcnRlZCB0eXBlIGFsaWFzXG5leHBvcnQgdHlwZSBPTkUgPSB7IG9uZTogbnVtYmVyIH07XG5cbi8vIE9iamVjdCB3aXRoIHR5cGVzIHdpdGhpblxudmFyIHNvbWVPYmogPSB7XG4gIG9iak1ldGhvZCgpOiB2b2lkIHtcbiAgICAvLyBkbyBub3RoaW5nLlxuICB9XG59XG5cbi8vIEV4YW1wbGUgZnJvbSBSRUFETUVcbmltcG9ydCBTb21lQ2xhc3MgZnJvbSAnc29tZS1tb2R1bGUnXG5pbXBvcnQgdHlwZSB7IFNvbWVJbnRlcmZhY2UgfSBmcm9tICdzb21lLW1vZHVsZSdcblxuZXhwb3J0IGNsYXNzIE15Q2xhc3M8VD4gZXh0ZW5kcyBTb21lQ2xhc3MgaW1wbGVtZW50cyBTb21lSW50ZXJmYWNlIHtcblxuICB2YWx1ZTogVFxuXG4gIGNvbnN0cnVjdG9yKHZhbHVlOiBUKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gIH1cblxuICBnZXQoKTogVCB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVcbiAgfVxuXG59XG5cbi8vIFRlc3QgYXN5bmMvYXdhaXQgZnVuY3Rpb25zXG5hc3luYyBmdW5jdGlvbiBhc3luY0Z1bmN0aW9uPFQ+KGlucHV0OiBUKTogUHJvbWlzZTxUPiB7XG4gIHJldHVybiBhd2FpdCB0O1xufVxuXG4vLyBUZXN0IHJlYWQtb25seSBkYXRhXG5leHBvcnQgdHlwZSBUZXN0UmVhZE9ubHkgPSB7fFxuICArcmVhZE9ubHk6ICRSZWFkT25seUFycmF5PD5cbnx9O1xuXG4vLyBUZXN0IGNvdmFyaWFudCB0eXBlIHZhcmlhbnQgY2xhc3Mgd2l0aCBjb25zdGFpbnQgYW5kIGRlZmF1bHQuXG5leHBvcnQgY2xhc3MgVGVzdENsYXNzV2l0aERlZmF1bHQ8K1Q6IFRlc3RSZWFkT25seSA9IFRlc3RSZWFkT25seT4ge1xuXG4gIGNvbnN0cnVjdG9yKCkge31cbn1cblxudmFyIG5ld2xpbmVfYXJyb3cgPSAoKTpcbm51bWJlciA9PiA0MjtcblxudmFyIG5ld2xpbmVfYXJyb3dfMiA9ICgpIDpcbm51bWJlcj0+NDI7XG5cbi8vIFRlc3QgY2FsbGluZyBhIGZ1bmN0aW9uIHdpdGggZXhwbGljaXQgdHlwZSBhcmd1bWVudHNcbmRvU29tZXRoaW5nPG51bWJlcj4oMyk7XG5kb1NvbWV0aGluZyA8VCwgVT4oMyk7XG5cbi8vIFRlc3QgaW52b2tpbmcgYSBjb25zdHJ1Y3RvciB3aXRoIGV4cGxpY2l0IHR5cGUgYXJndW1lbnRzXG5uZXcgRXZlbnQ8bnVtYmVyPigpO1xuXG4vLyBUZXN0IHR5cGUgdW5pb24gYW5kIGludGVyc2VjdGlvbiBzeW50YXggd2l0aCBsZWFkaW5nIFwib3BlcmF0b3JcIlxudmFyIHVuaW9uOiB8IFQgfCBVO1xudmFyIGludGVyc2VjdGlvbjogJiBUICYgVTtcblxuLy8gVGVzdCBnZW5lcmljIGFzeW5jIGFycm93IGZ1bmNpb25cbmNvbnN0IGYgPSBhc3luYyA8VD4oKTogVCA9PiB7fTtcblxuLy8gQ29tbWVudCB0eXBlIGFubm90YXRpb25zIGFyZSBwcmVzZXJ2ZWRcbnZhciBYIC8qOiB7XG4gIHZlcnNpb246IHN0cmluZyxcbn0gKi8gPSB7IHZlcnNpb246ICc0Mid9O1xuXG5mdW5jdGlvbiBtZXRob2QocGFyYW0gLyo6IHN0cmluZyAqLykgLyo6IG51bWJlciAqLyB7XG4gIC8vIC4uLlxufVxuXG4vLyBkZWNsYXJlZCBjbGFzcyBmaWVsZHNcbmNsYXNzIE15Q2xhc3Mge1xuICBkZWNsYXJlIHByb3A6IHN0cmluZztcbn1cblxuLy8gQ29tbWVudCB0eXBlIGluY2x1ZGVzIGFyZSBlbXB0aWVkIG91dFxuY2xhc3MgTXlDbGFzcyB7XG4gIC8qOjogcHJvcDogc3RyaW5nOyAqL1xufVxuXG4vLyBJbmZlcnJlZCBwcmVkaWNhdGVcbmZ1bmN0aW9uIHRlc3RpdChhcmc6IG1peGVkKTogYm9vbGVhbiAlY2hlY2tzIHtcbiAgcmV0dXJuICEhYXJnO1xufVxuXG4vLyBUZXN0IGZ1bmN0aW9uIHdpdGggZGVmYXVsdCB0eXBlIHBhcmFtZXRlclxuZnVuY3Rpb24gZjxULCBTID0gVD4oKSB7fVxuXG4vLyBPcGFxdWUgdHlwZXNcbm9wYXF1ZSB0eXBlIEEgPSBudW1iZXI7XG5vcGFxdWUgdHlwZSBCOiBzdHJpbmcgPSBzdHJpbmc7XG5kZWNsYXJlIG9wYXF1ZSB0eXBlIEE7XG5kZWNsYXJlIG9wYXF1ZSB0eXBlIEI6IHN0cmluZztcbmV4cG9ydCBvcGFxdWUgdHlwZSBBID0gbnVtYmVyO1xuXG4vLyBEZWNsYXJlIGV4cG9ydFxuZGVjbGFyZSBleHBvcnQgb3BhcXVlIHR5cGUgQjtcbmRlY2xhcmUgZXhwb3J0IGZ1bmN0aW9uIHgoKTogdm9pZDtcbmRlY2xhcmUgZXhwb3J0IGRlZmF1bHQgVDtcblxuLy8gYHRoaXNgIHBhcmFtc1xuXG5kZWNsYXJlIGZ1bmN0aW9uIHkgKHRoaXMgOiBzdHJpbmcpIDogdm9pZFxudHlwZSBUID0gKHRoaXMgOiBzdHJpbmcpIDogdm9pZFxuZnVuY3Rpb24geiAodGhpcyA6IHN0cmluZykge31cbmZ1bmN0aW9uIHUgKHRoaXMgOiBzdHJpbmcsIC4uLmEpIHt9XG5mdW5jdGlvbiB2ICh0aGlzIDogc3RyaW5nXG4gICAsIC4uLmEpIHt9XG5mdW5jdGlvbiB3ICh0aGlzXG4gIDogc3RyaW5nXG5cbiAgICwpIHt9XG5mdW5jdGlvbiB4ICh0aGlzXG4gIDogc3RyaW5nXG5cbiAgICxcbiAgIC4uLmEpIHt9XG5mdW5jdGlvbiBpKFxuICB0aGlzOiBYLFxuKSB7fVxuZnVuY3Rpb24gaihcbiAgdGhpczogWCxcbiAgYTogc3RyaW5nXG4pIHt9XG5cbmZ1bmN0aW9uIGpqKFxuICB0aGlzOiBYLFxuICBhOiBzdHJpbmdcbikge1xuICBmdW5jdGlvbiBqamoodGhpczogWCwgYTogc3RyaW5nKSB7fVxufVxuXG5jb25zdCBmID0gZnVuY3Rpb24odGhpczogc3RyaW5nKSB7fVxuY29uc3QgZyA9IGZ1bmN0aW9uKHRoaXM6IHN0cmluZywgLi4uYSkge31cbmNvbnN0IGggPSBmdW5jdGlvbih0aGlzXG46IHN0cmluZyxcbi4uLmEpIHt9XG5jb25zdCBrID0gZnVuY3Rpb24odGhpc1xuOiBzdHJpbmdcblxuLCkge31cbmNvbnN0IGtrID0gZnVuY3Rpb24odGhpc1xuOiBzdHJpbmcsXG5hOiBzdHJpbmcsKSB7fVxuIl19
